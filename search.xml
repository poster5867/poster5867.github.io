<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通信FPGA相关合集</title>
      <link href="/2024/10/31/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/02-FPGA/FPGA_Study/"/>
      <url>/2024/10/31/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/02-FPGA/FPGA_Study/</url>
      
        <content type="html"><![CDATA[<h1>通信FPGA相关</h1><h2 id="引言">引言</h2><h2 id="载波同步">载波同步</h2><a href="/2024/10/04/%E5%BC%80%E5%A7%8B/" title="一切从这里开始">一切从这里开始</a>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFT-S-OFDM 波形设计</title>
      <link href="/2024/10/31/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/DFT-s-OFDM/dft-s-ofdm_waveform/"/>
      <url>/2024/10/31/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/DFT-s-OFDM/dft-s-ofdm_waveform/</url>
      
        <content type="html"><![CDATA[<h1>DFT-s-OFDM体制</h1><h2 id="DFT相关回顾">DFT相关回顾</h2><blockquote><p>首先对离散傅里叶变换（Discrete Fourier Transform，DFT）的公式以及性质进行回顾，该部分是基础，对后边波形设计的优化以及整个系统的理解具有重要的作用。</p></blockquote><ul><li><p><strong>DFT公式</strong><br>$$<br>X(k)=\sum_{n=0}^{N-1} x(n)e^\frac{-j2\pi nk}{N}=\sum_{n=0}^{N-1} x(n)W_N^{kn}\qquad 0\le k\le N-1<br>$$</p></li><li><p><strong>IDFT公式</strong><br>$$<br>x(n)=\frac{1}{N}\sum_{k=0}^{N-1}X(k)e^\frac{j2\pi nk}{N}=\frac{1}{N}\sum_{k=0}^{N-1}X(k)W_N^{kn}\qquad 0\le n \le N-1<br>$$</p></li><li><p><strong>性质</strong></p><ul><li><p>时域补零——<strong>增加频率分辨率</strong></p><p>已知序列 $x(n), 0\le n \le N-1$ ，人为将序列补充至 $rN$，$r$为正整数，得到 $g(n)\quad 0\le n \le rN-1$，即</p><p>$$<br>g(n) =<br>\begin{cases}<br>x(n) &amp; \text{if } 0 \le n \le N-1 \ 0 &amp; \text{if } N \le n \le rN-1<br>\end{cases}<br>$$</p><p>$g(n)$的离散傅里叶变换为：</p><p>$$<br>\begin{equation*}<br>\begin{aligned}<br>G(k) &amp;= DFT[g(n)]=\sum_{n=0}^{rN-1} g(n)e^\frac{-j2\pi nk}{rN} \ &amp;=\sum_{n=0}^{N-1}x(n)e^\frac{-j2\pi n(\frac {n} {k})}{N}=X(\frac{k} {n})\qquad k=0,1,\dots,rN-1<br>\end{aligned}<br>\end{equation*}<br>$$</p><blockquote><p>上述公式表明，$g(n)$的频谱$G(k)$与$x(n)$的频谱$X(k)$相对应，$G(k)$的频谱间隔相比$X(k)$的频谱间隔降低$k/r$，即序列$x(n)$填充补零再做DFT，可以得到更为精细的频谱。</p><p>另外，若增加长度并未$N$的整数倍，例如 $g(n)$长度为$L&gt;N$，则列长为$L$的序列 $g(n)$的离散傅里叶变换 $G(k)$，可以得到序列 $x(n)$的$L$根谱线，此时比$X(k)$得出得谱线要多。</p></blockquote></li><li><p>时域插零（上采样）——<strong>频谱扩展复制</strong></p><p>已知序列 $x(n), 0\le n \le N-1$ ，人为将序列样本点之间插入$L-1$个零，$L$也叫上采样倍数，得到新的序列$g(n)$，其长度为$M=LN$，即<br>$$<br>g[n]=\begin{cases}x(n/L)&amp;\mathrm{if~}n\mod L=0\0&amp;\mathrm{otherwise}&amp;\end{cases}<br>$$<br>$g(n)$的离散傅里叶变换为记为$G(m)$，与前面的$X(k)$进行区分：</p><!-- $$  \begin{equation*}    \begin{aligned}      X(k)&=\sum_{n=0}^{N-1} x(n)e^\frac{-j2\pi nk}{N}\quad 0\le k\le N-1\\      G(m)&=DFT[g(n)]=\sum_{n=0}^{LN-1}g(n)e^{-\frac{j2\pi nm}{LN}}&\\      &=\sum_{n=0}^{N-1}x(n)e^{-\frac{j2\pi m\cdot nL}{LN}}=\sum_{n=0}^{N-1}x(n)e^{-\frac{j2\pi m\cdot n}{N}}\quad 0\le m\le M-1    \end{aligned}  \end{equation*} $$ --><p>可以看到，对于每个频率$m$，当$m=k+qN$时（$q$为正整数），会出现周期性重复，即：<br>$$<br>G(m)=X(k),\qquad m=k+qN,\qquad q=0,1,\dots,N-1<br>$$<br>即上采样之后频谱会在频率轴上以$N$为间隔重复$L$次。</p><blockquote><p>另一种推导过程如下：</p><p>$g(n)$是在序列$x(n)$每个采样点后加$L-1$个$0$，其可以表示为：<br>$$<br>g(n)=x(n/L)\cdot \delta(n\mod L)<br>$$<br>$\delta(n\mod L)$是一个周期为$L$得脉冲序列，根据DFT性质可以得到$G(k)$为<br>$$<br>G(k)=\sum_{n=0}^{L-1}X(k-m\cdot \frac{M}{N})<br>$$</p></blockquote></li><li><p>频域补零——<strong>时域内插</strong></p><p>已知序列$X(k),0\le k\le N-1$，人为将序列补充至 $rN$，$r$为正整数，得到$G(k)\quad 0\le k\le rN-1$，即：</p><p>$$<br>G(k)=\left{\begin{matrix} X(k)\qquad 0\le k\le N-1\0\qquad N\le k\le rN-1\end{matrix}\right.<br>$$<br>进一步地，得到时域序列$g(n)$<br>$$<br>g(n)=\frac{1}{rN}\sum_{k=0}^{rN-1}G(k)e^{\frac{j2\pi kn}{rN}}=\frac{1}{rN}\sum_{k=0}^{N-1}X(k)e^{\frac{j2\pi kn}{rN}}=\frac{1}{r}x(\frac{n}{r})\qquad n=0,1,\cdots,rN-1<br>$$</p><blockquote><p>上述公式表明，频域补零，时域信号内插出来更多的点，即时域信号更加密集，$1/r$是一个缩放因子，其主要保持信号得能量不变。</p></blockquote></li><li><p>频域内插——<strong>时域扩展</strong></p><p>已知序列$X(k),0\le k\le N-1$，人为将序列样本点之间插入$L-1$个零，得到的新序列即为$G(m)$，其长度为$M=LN$，表达式如下：<br>$$<br>G(m)=\begin{cases}X\left(\frac mL\right),&amp;m=0,L,2L,\ldots,(N-1)L \ 0,&amp;otherwise&amp;\end{cases}<br>$$<br>进一步地，得到时域序列$g(n)$<br>$$<br>g(n)=\frac1M\sum_{m=0}^{M-1}G(m)e^{j\frac{2\pi}Mmn}=\frac1M\sum_{m=0}^{N-1}X(k)e^{j\frac{2\pi}M(kL)n} \ =\frac1 {LN} \sum_{m=0}^{N-1}X(k)e^{j\frac{2\pi}Nkn}=\frac1Lx(n \mod N)\qquad 0\le n\le LN-1<br>$$</p><blockquote><p>这实际上表示$g(n)$ 是 $x(n)$的周期延长 $L$ 倍。也就是说，插零后时域信号$g(n)$ 是将原始信号 $x(n)$ 在时域上拉伸为 L倍长度，并重复出现.</p></blockquote></li></ul></li></ul><h2 id="DFT-s-OFDM子载波映射方式">DFT-s-OFDM子载波映射方式</h2><blockquote><p>DFT-s-OFDM子载波映射方式分为2种，即集中式（Localized）映射和分布式（Distributed）映射，集中式映射方便频域调度，分布式映射传输可以获得额外的频率分集增益。在LTE上行传输方案中，选用集中式映射方案。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推导 </tag>
            
            <tag> DFT-S-OFDM </tag>
            
            <tag> 仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技能总结</title>
      <link href="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>学习过程中的技能</h1><blockquote><p>本文主要记录日常学习到的一些技能，包括不限于：信息检索、电脑技巧、编程技巧……</p></blockquote><h2 id="信息检索">信息检索</h2><h3 id="国自然基金结题书下载">国自然基金结题书下载</h3><blockquote><p>国自然基金项目结项书对中文论文的撰写具有很高的参考价值，下面记录怎么下载结项书。</p></blockquote><ol><li>以Google浏览器为例，进入国家自然科学基金委员会官网：<a href="https://www.nsfc.gov.cn/%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%BE%E5%88%B0">https://www.nsfc.gov.cn/，然后找到</a> 申请资助–&gt;项目检索与查询–&gt;检索。</li></ol><img src="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/image-20241029211640489.png" alt="image-20241029211640489" style="zoom:50%;"><ol><li>在Google扩展应用商店中下载插件“国自然结题报告下载”，在项目页面右键可以找到下载结题报告即可下载。</li></ol><p><img src="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/image-20241029212121798.png" alt="image-20241029212121798"></p><p>至此，即可下载国自然基金的项目书了！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFDM相关学习</title>
      <link href="/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>OFDM相关学习</h1><h2 id="循环前缀相关">循环前缀相关</h2><blockquote><p>循环前缀（Cyclic Prefix，CP）的作用：避免符号间干扰和消除子载波间干扰，如何深入理解这个问题，主要从公式的角度进行推导和分析，再结合MATLAB仿真进行验证。</p></blockquote><h3 id="多径信道传输模型">多径信道传输模型</h3><p>考虑线性时不变系统：<br>$$<br>y(t)=h(t)*x(t)=\int h(t)x(t-\tau)d\tau\tag1<br>$$<br>其中，$x(t)$表示输入信号，$h(t)$表示信号冲激响应，$y(t)$表示接收信号。离散信号表达式为：<br>$$<br>y(n)=\sum_{l=0}^{L-1} h(l)x(n-l)\tag2<br>$$<br>上式为多径信道下的信号传输模型，其中$L$表示多径信道的阶数。</p><h3 id="OFDM循环前缀的作用">OFDM循环前缀的作用</h3><p>对于OFDM信号而言，发射信号$x(n)$由 IFFT 运算和添加CP得到，其有效信号的表达式为（即IDFT的公式）：<br>$$<br>x(n)=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} X(k)e^{j2\pi \frac{nk}{N}},n=1,\dots,N,k=1,\dots,N<br>$$<br>式中，$X(k)$为第$k$个子载波上的发射信号，$N$为IFFT的点数（也是一个OFDM符号时域有效信号 $x(n)$的样点数目。</p><blockquote><p>接下来，需要把式$(2)$中的卷积写成矩阵乘法的形式：</p><p>分析过程：假设$L$是多径的的数目，不失一般地，先考虑$y(0)$的表达式，然后利用数学归纳法，写出接收信号的矩阵表达。<br>$$<br>y(0)=\sum_{l=0}^{L-1}h(l)x(-l)=h(0)x(0)+h(1)x(-1)+\dots+h(L-1)x(-L+1)<br>$$</p></blockquote><p>对于单个OFDM符号，CP长度为$N_{CP}$，则接收信号的矩阵表达式为：<br>$$<br>\begin{bmatrix}y(-N_{CP})\ \vdots\y(-1)\y(0)\y(1)\y(2)\ \vdots\y(N-2)\y(N-1)\end{bmatrix}=\begin{bmatrix}h(0)&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\ \vdots &amp; \ddots&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\h(L-1)&amp;\cdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\0&amp;h(L-1)&amp;\cdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;\ddots&amp;\vdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;h(L-1)&amp;&amp;h(0)&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;\ddots&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;h(0)&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;h(L-1)&amp;\cdots&amp;h(0)\end{bmatrix}\begin{bmatrix}x(-N_{CP})\\vdots\x(-1)\x(0)\x(1)\x(2)\\vdots\x(N-2)\x(N-1)\end{bmatrix}\tag4<br>$$<br>==<strong>CP的第一个作用：避免符号间干扰。</strong>==由于多径的作用，前一时刻的信号会对当前时刻的信号造成影响。因此，为了保证上一个OFDM不会对当前OFDM符号造成影响，CP的长度必须满足$N_{CP}\ge L$，上式$(4)$中，$N_{CP}= L$。（从两个方向考虑问题，物理意义直观理解，如果多径时延大于$N_{CP}$，接收信号将不全是一个OFDM符号的信息，会有下一个符号信息的干扰，导致后续处理分不开来；数学公式角度理解：上述矩阵成立的边界，即为$N_{CP}\ge L-1$，因为$x,y$这两个列向量长度有系统决定，是确定的形式，L的范围只能存在边界条件，即可得出结论）。</p><p>==CP 的第二个作用：消除子载波干扰==。下面进行推导。</p><h3 id="循环前缀进一步理解（消除子载波干扰）">循环前缀进一步理解（消除子载波干扰）</h3><blockquote><p>由CP的定义可知，$x(-1)=x(N-1),\dots,x(-N_{CP})=x(N-N_{CP})$。</p><img src="/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image-20241028171132568.png" alt="image-20241028171132568" style="zoom:30%;"></blockquote><p>接收端去掉CP，可以将上式$(4)$进行化简（即考虑$N_{CP}= L$的情况）：<br>$$<br>\begin{bmatrix}y(0)\y(1)\y(2)\\vdots\y(N-2)\y(N-1)\end{bmatrix}=\begin{bmatrix}0&amp;h(L-1)&amp;\cdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;\ddots&amp;\vdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;h(L-1)&amp;&amp;h(0)&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;\ddots&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;h(0)&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;h(L-1)&amp;\cdots&amp;h(0)\end{bmatrix}\begin{bmatrix}x(-N_{CP})\\vdots\x(-1)\x(0)\x(1)\x(2)\\vdots\x(N-2)\x(N-1)\end{bmatrix}\tag5<br>$$<br>利用CP的性质，可以进一步得到：<br>$$<br>\begin{bmatrix}y(0)\y(1)\y(2)\\vdots\y(N-2)\y(N-1)\end{bmatrix}=\begin{bmatrix}h(0)&amp;0&amp;0&amp;0&amp;h(L-1)&amp;h(1)\\vdots&amp;h(0)&amp;0&amp;0&amp;0&amp;h(L-1)\h(L-1)&amp;&amp;h(0)&amp;0&amp;0&amp;0\0&amp;\ddots&amp;&amp;\ddots&amp;0&amp;0\0&amp;0&amp;\ddots&amp;&amp;h(0)&amp;0\0&amp;0&amp;0&amp;h(L-1)&amp;\cdots&amp;h(0)\end{bmatrix}\begin{bmatrix}x(0)\x(1)\x(2)\\vdots\x(N-2)\x(N-1)\end{bmatrix}\tag6<br>$$<br>观察式$(5)$和$(6)$的$h$矩阵，其实质上将式$(5)$中信道矩阵的左上角元素，搬移到式$(6)$中信道矩阵的右上角，这两个等式完全等价，即CP-OFDM将线性**==卷积运算转换为了循环卷积运算==**。</p><blockquote><p>实际上，时域线性卷积≠频域相乘，而是时域循环卷积=频域相乘，引入循环前缀，正好将线性卷积转到循环卷积。</p></blockquote><p>$$<br>\mathbf{y}=\mathbf{Gx}\tag7<br>$$</p><p>其中，$\mathbf{G}\in \mathbb{C} ^{N\times N}$为时域信道矩阵。根据OFDM接收端的操作，需对接收信号进行FFT运算，可以得到频域信号形式，即<br>$$<br>\mathbf{r}=\mathbf{F}\mathbf{y}=\frac{1}{N}\mathbf{F}\mathbf{G}\mathbf{F}^{H}\mathbf{s}\tag8<br>$$<br>式中，$\mathbf{F}\in \mathbb{C} ^{N\times N}$表示傅里叶矩阵，性质：$\mathbf{F}\mathbf{F}^{H}=NI$，$\mathbf{s}=[X(1),\dots,X(N)]^T\in ^{N\times 1}$表示频域发射信号。</p><p><strong>注意</strong>：式中$\mathbf{G}$是一个Toeplitz矩阵，具有循环移位特性。</p><p>定义 $\mathbf{H}=\frac{1}{N}\mathbf{F}\mathbf{G}\mathbf{F}^{H}$，利用 <a href="https://baike.baidu.com/item/%E6%89%98%E6%99%AE%E5%88%A9%E5%85%B9%E7%9F%A9%E9%98%B5/5735426?fr=aladdin">托普利兹矩阵_百度百科</a>的性质，则 $\mathbf{H}$是一个对角阵，式 $(8)$可以表示为：<br>$$<br>\begin{bmatrix}r(0)\r(1)\r(2)\\vdots\r(N-1)\end{bmatrix}=\begin{bmatrix}H(0)\&amp;\ddots\&amp;&amp;H(k)\&amp;&amp;&amp;\ddots\&amp;&amp;&amp;&amp;H(N-1)\end{bmatrix}\begin{bmatrix}X(0)\\vdots\X(k)\\vdots\X(N-1)\end{bmatrix}\tag9<br>$$<br>式中，$H(k)$表示 $\mathbf{H}$的第$k$个对角线元素，从式 $(9)$可以看到，每一个子载波的接收信号与发射信号一一对应，且其他子载波的信号对当前子载波完全没有影响。也就是说，子载波之间不会产生任何干扰，即消除了子载波间干扰。OFDM结合循环前缀，可以使信道均衡、信号解调等在频域并行处理，大大降低了系统复杂度。</p><p>有两种说法：CP --&gt; 实现OFDM的循环扩展（为了某种连续性）。</p><p>进一步地，分析OFDM频域与时域信道系数的关系，即$H$和$h$的关系：</p><p>解决这一问题，需要考虑矩阵的特征值和特征向量：</p><p>由$\mathbf{H}$是对角阵可知，$H(k)$是Toeplitz矩阵$\mathbf{G}$的特征值，相应的特征向量为 $\mathbf{F}^{H}$的第 $k$列。理由：$\mathbf{F}^H\mathbf{H}=\mathbf{G}\mathbf{F}^H$.（矩阵分析源头）</p><p>考虑矩阵两边的第$k$个列向量，可得$\mathbf{Gf}_k = H(k)\mathbf{f}_k$，其中$\mathbf{f}_k$是$\mathbf{F}^H$的第$k$列，也就是$\mathbf{F}$的第$k$行。这与特征值和特征向量的表达式相同。基于以上讨论，我们下面来说明如何计算$H(k)$。</p><p>定义：$W_N = e^{-\frac{j2\pi}{N}}$，$\mathbf{Gf}<em>k = H(k)\mathbf{f}<em>k$的等价形式，即<br>$$<br>\frac{1}{\sqrt{N}}\begin{bmatrix}p_0 &amp; p_1 &amp; p_2 &amp; \cdots &amp; p</em>{N-1} \p</em>{N-1} &amp; p_0 &amp; p_1 &amp; \cdots &amp; p_{N-2} \p_{N-2} &amp; p_{N-1} &amp; p_0 &amp; \cdots &amp; p_{N-3} \\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \p_1 &amp; p_2 &amp; p_3 &amp; \cdots &amp; p_0\end{bmatrix}\begin{bmatrix}W_N^{0} \W_N^{-k} \W_N^{-2k} \\vdots \W_N^{-(N-1)k}\end{bmatrix}=\frac{1}{\sqrt{N}}H(k)\begin{bmatrix}W_N^{0} \W_N^{-k} \W_N^{-2k} \\vdots \W_N^{-(N-1)k}\end{bmatrix}\tag{10}<br>$$<br>为了计算$H(k)$的表达式，我们观察式（6）和（10）中的Toeplitz矩阵$\mathbf{G}$和$\mathbf{P}$，有$\mathbf{P}<em>{m,n} = p</em>{(n-m)\mod N}$, $p_l = h_{(N-l)\mod N}$，其中$m, n, l = 0, 1, 2, \ldots, N-1$。</p><p>因此，式（10）等号左边：矩阵$\mathbf{P}$的第$(m+1)$行与IDFT矩阵第$k$列的内积有<br>$$<br>\frac{1}{\sqrt{N}} \sum_{n=0}^{N-1} p_{(n-m)<em>N} W_N^{-nk} = \frac{1}{\sqrt{N}} W_N^{-mk} \sum</em>{n=0}^{N-1} p_{(n-m)<em>N} W_N^{-(n-m)<em>N k} = \frac{1}{\sqrt{N}} W_N^{-mk} \sum</em>{l=0}^{N-1} p_l W_N^{-lk}\tag{11}<br>$$<br>式中，第1个等号利用了性质$W_N^{-(n-m)k} = W_N^{-(n-m)<em>N k}$（以$N$为周期的周期性）。为进一步计算式（11）的求和项，我们定义$H_k = \sum</em>{l=0}^{N-1} p_l W_N^{-lk}$ ，即<br>$$<br>H_k = \sum</em>{l=0}^{N-1} p_l W_N^{-lk} = \sum_{l=0}^{N-1} h_{(N-l)<em>N} W_N^{-lk} = \sum</em>{l=0}^{N-1} h_{(N-l)<em>N} W_N^{(N-l)<em>N k} = \sum</em>{l’=0}^{N-1} h</em>{l’} W_N^{l’k}\tag{12}<br>$$<br>式中，第3个等号利用了性质$W_N^{Nk} = 1$，$W_N^{(N-l)k} = W_N^{(N-l)_N k}$。</p><p>可以看到，频域信道系数$H_k$恰巧是时域信道系数$h_{l’}, l’ = 0, 1, \ldots, N-1$的傅里叶变换！</p><h3 id="线性卷积和循环卷积的转换">线性卷积和循环卷积的转换</h3><blockquote><p>参考书籍《<em>Wireless Communication Systems in Matlab, Second Edition</em>》</p></blockquote><p>下面给出一个简单的<em>MATLAB</em>程序：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%========================================================================%</span></span><br><span class="line"><span class="comment">%:此程序用来测试《Wireless Communication Systems in Matlab, Second Edition》</span></span><br><span class="line"><span class="comment">%:第14章OFDM的前向解调算法</span></span><br><span class="line"><span class="comment">%========================================================================%</span></span><br><span class="line"><span class="comment">%% 线性卷积与循环卷积转化</span></span><br><span class="line">N = <span class="number">8</span>; <span class="comment">%period of DFT</span></span><br><span class="line">s = <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">h = <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">lin_s_h = conv(h, s) <span class="comment">%linear convolution of h and s</span></span><br><span class="line">cir_s_h = cconv(h, s, N) <span class="comment">%#ok&lt;*NOPTS&gt; %circular convolution of h and s with period N</span></span><br><span class="line">Ncp = <span class="number">2</span>; <span class="comment">%number of symbols to copy and paste for CP</span></span><br><span class="line">s_cp = [s(<span class="keyword">end</span> - Ncp + <span class="number">1</span>:<span class="keyword">end</span>) s]; <span class="comment">%copy last Ncp syms from s, add as prefix</span></span><br><span class="line">lin_scp_h = conv(h, s_cp) <span class="comment">%linear conv. of CP-OFDM symbol s_cp and CIR h</span></span><br><span class="line">r = lin_scp_h(Ncp + <span class="number">1</span>:N + Ncp) <span class="comment">%cut from index Ncp+1 to N+Ncp</span></span><br><span class="line"><span class="comment">%% 验证循环卷积=IDFT&#123;DFT&#123;h[n]&#125; x DFT&#123;s[n]&#125;&#125;</span></span><br><span class="line">R = fft(r, N); <span class="comment">%frequency response of received signal</span></span><br><span class="line">H = fft(h, N); <span class="comment">%frequency response of CIR</span></span><br><span class="line">S = fft(s, N); <span class="comment">%frequency response of OFDM signal (non CP)</span></span><br><span class="line">r1 = ifft(S .* H); <span class="comment">%IFFT of product of individual DFTs</span></span><br><span class="line">display([<span class="string">&#x27;IFFT(DFT(H)*DFT(S)) : &#x27;</span>, num2str(r1)])</span><br><span class="line">display([<span class="string">&#x27;cconv(s,h): &#x27;</span>, num2str(r)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OFDM信号仿真部分代码">OFDM信号仿真部分代码</h3><blockquote><p>以下为一个OFDM误码率仿真示例：</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">% DATA: 2024-9-12-22:00</span></span><br><span class="line"><span class="comment">% Author: Poster</span></span><br><span class="line"><span class="comment">% Description: This is a simulation of OFDM over AWGN channel.</span></span><br><span class="line"><span class="comment">%:注:Tx-Signal采用列向量的形式;</span></span><br><span class="line"><span class="comment">%:注:MATLAB采用优先采用列向量进行存储,按列运算速度相对较快</span></span><br><span class="line"><span class="comment">%------------Simulation parameters---------%</span></span><br><span class="line">MOD_TYPE = <span class="string">&#x27;PSK&#x27;</span>; <span class="comment">% Modulation type&#x27;</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">% Constellation size</span></span><br><span class="line">phase_init = <span class="built_in">pi</span> / M; <span class="comment">% Initial phase</span></span><br><span class="line">N = <span class="number">64</span>; <span class="comment">% FFT size</span></span><br><span class="line">Ncp = <span class="number">16</span>; <span class="comment">% number of symbols in the cyclic prefix</span></span><br><span class="line">Num = <span class="number">1e5</span>; <span class="comment">% Number of OFDM Symbols to transmit</span></span><br><span class="line">EbN0dB = <span class="number">0</span>:<span class="number">2</span>:<span class="number">20</span>; <span class="comment">% bit to noise ratio</span></span><br><span class="line">k = <span class="built_in">log2</span>(M); <span class="comment">% number of bits per symbol</span></span><br><span class="line">EsN0dB = <span class="number">10</span> * <span class="built_in">log10</span>(k) + EbN0dB; <span class="comment">% convert to symbol energy to noise ratio</span></span><br><span class="line">errors = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(EsN0dB)); <span class="comment">%to store symbol errors</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(EsN0dB)</span><br><span class="line">    <span class="keyword">for</span> Sym = <span class="number">1</span>:Num <span class="comment">% Monte Carlo Simulation</span></span><br><span class="line">        <span class="comment">%--------Constellation Mapping-------%</span></span><br><span class="line">        symbols_data = randi([<span class="number">0</span> M - <span class="number">1</span>], N, <span class="number">1</span>); <span class="comment">% Random symbols</span></span><br><span class="line">        X = pskmod(symbols_data, M, phase_init); <span class="comment">% PSK modulation</span></span><br><span class="line">        <span class="comment">%--------------Transmitter-----------%</span></span><br><span class="line">        x = ifft(X, N); <span class="comment">% IDFT</span></span><br><span class="line">        s = add_cyclic_prefix(x, Ncp); <span class="comment">% Add CP</span></span><br><span class="line">        <span class="comment">%----------------Channel-------------%</span></span><br><span class="line">        r = add_awgn_noise(s, EsN0dB(<span class="built_in">i</span>)); <span class="comment">% Add AWGN noise r = s + n</span></span><br><span class="line">        <span class="comment">%---------------Receiver-------------%</span></span><br><span class="line">        y = remove_cyclic_prefix(r, Ncp, N); <span class="comment">% remove CP</span></span><br><span class="line">        Y = fft(y, N); <span class="comment">% DFT</span></span><br><span class="line">        symbols_data_cap = pskdemod(Y, M, phase_init); <span class="comment">% PSK demodulation</span></span><br><span class="line">        <span class="comment">%------------error count-------------%</span></span><br><span class="line">        numErrors = sum(symbols_data ~= symbols_data_cap); <span class="comment">% Count errors</span></span><br><span class="line">        errors(<span class="built_in">i</span>) = errors(<span class="built_in">i</span>) + numErrors; <span class="comment">% Update error count</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">simulatedSER = errors / (Num * N); <span class="comment">% Symbol Error Rate</span></span><br><span class="line">theoreticalSER = ser_awgn(EbN0dB, MOD_TYPE, M);</span><br><span class="line"><span class="comment">% Plot theoretical curves and simulated BER points</span></span><br><span class="line"><span class="built_in">plot</span>(EbN0dB, <span class="built_in">log10</span>(simulatedSER), <span class="string">&#x27;ro&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(EbN0dB, <span class="built_in">log10</span>(theoreticalSER), <span class="string">&#x27;r-&#x27;</span>); grid on;</span><br><span class="line">title([<span class="string">&#x27;Performance of &#x27;</span>, num2str(M), <span class="string">&#x27;-&#x27;</span>, MOD_TYPE, <span class="string">&#x27; OFDM over AWGN channel&#x27;</span>]);</span><br><span class="line">xlabel(<span class="string">&#x27;Eb/N0 (dB)&#x27;</span>); ylabel(<span class="string">&#x27;Symbol Error Rate&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;simulated&#x27;</span>, <span class="string">&#x27;theoretical&#x27;</span>);</span><br><span class="line"><span class="comment">%=============Function Definition==========%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span> = <span class="title">add_cyclic_prefix</span><span class="params">(x, Ncp)</span></span></span><br><span class="line">    <span class="comment">%function to add cyclic prefix to the generated OFDM symbol x that</span></span><br><span class="line">    <span class="comment">%is generated at the output of the IDFT block</span></span><br><span class="line">    <span class="comment">% x - ofdm symbol without CP (output of IDFT block)</span></span><br><span class="line">    <span class="comment">% Ncp-num. of samples at x&#x27;s end that will copied to its beginning</span></span><br><span class="line">    <span class="comment">% s - returns the cyclic prefixed OFDM symbol</span></span><br><span class="line">    s = [x(<span class="keyword">end</span> - Ncp + <span class="number">1</span>:<span class="keyword">end</span>); x]; <span class="comment">%Cyclic prefixed OFDM symbol</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[r, n, N0]</span> = <span class="title">add_awgn_noise</span><span class="params">(s, SNRdB, L)</span></span></span><br><span class="line">    <span class="comment">%Function to add AWGN to the given signal</span></span><br><span class="line">    <span class="comment">%[r,n,N0]= add_awgn_noise(s,SNRdB) adds AWGN noise vector to signal</span></span><br><span class="line">    <span class="comment">%&#x27;s&#x27; to generate a %resulting signal vector &#x27;r&#x27; of specified SNR</span></span><br><span class="line">    <span class="comment">%in dB. It also returns the noise vector &#x27;n&#x27; that is added to the</span></span><br><span class="line">    <span class="comment">%signal &#x27;s&#x27; and the spectral density N0 of noise added</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">%[r,n,N0]= add_awgn_noise(s,SNRdB,L) adds AWGN noise vector to</span></span><br><span class="line">    <span class="comment">%signal &#x27;s&#x27; to generate a resulting signal vector &#x27;r&#x27; of specified</span></span><br><span class="line">    <span class="comment">%SNR in dB. The parameter &#x27;L&#x27; specifies the oversampling ratio used</span></span><br><span class="line">    <span class="comment">%in the system (for waveform simulation). It also returns the noise</span></span><br><span class="line">    <span class="comment">%vector &#x27;n&#x27; that is added to the signal &#x27;s&#x27; and the spectral</span></span><br><span class="line">    <span class="comment">%density N0 of noise added</span></span><br><span class="line">    s_temp = s;</span><br><span class="line">    <span class="keyword">if</span> iscolumn(s), s = s.&#x27;; <span class="keyword">end</span> <span class="comment">%to return the result in same dim as &#x27;s&#x27;</span></span><br><span class="line">    <span class="built_in">gamma</span> = <span class="number">10</span> ^ (SNRdB / <span class="number">10</span>); <span class="comment">%SNR to linear scale</span></span><br><span class="line">    <span class="keyword">if</span> nargin == <span class="number">2</span>, L = <span class="number">1</span>; <span class="keyword">end</span> <span class="comment">%if third argument is not given, set it to 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isvector</span>(s)</span><br><span class="line">        P = L * sum(<span class="built_in">abs</span>(s) .^ <span class="number">2</span>) / <span class="built_in">length</span>(s); <span class="comment">%Actual power in the vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">%for multi-dimensional signals like MFSK</span></span><br><span class="line">        P = L * sum(sum(<span class="built_in">abs</span>(s) .^ <span class="number">2</span>)) / <span class="built_in">length</span>(s); <span class="comment">%if s is a matrix [MxN]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    N0 = P / <span class="built_in">gamma</span>; <span class="comment">%Find the noise spectral density</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isreal</span>(s))</span><br><span class="line">        n = <span class="built_in">sqrt</span>(N0 / <span class="number">2</span>) * <span class="built_in">randn</span>(<span class="built_in">size</span>(s)); <span class="comment">%computed noise</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="built_in">sqrt</span>(N0 / <span class="number">2</span>) * (<span class="built_in">randn</span>(<span class="built_in">size</span>(s)) + <span class="number">1</span><span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="built_in">size</span>(s))); <span class="comment">%computed noise</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    r = s + n; <span class="comment">%received signal</span></span><br><span class="line">    <span class="keyword">if</span> iscolumn(s_temp), r = r.&#x27;; <span class="keyword">end</span> <span class="comment">%return r in original format as s</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">remove_cyclic_prefix</span><span class="params">(r, Ncp, N)</span></span></span><br><span class="line">    <span class="comment">%function to remove cyclic prefix from the received OFDM symbol r</span></span><br><span class="line">    <span class="comment">% r - received ofdm symbol with CP</span></span><br><span class="line">    <span class="comment">% Ncp - num. of samples at beginning of r that need to be removed</span></span><br><span class="line">    <span class="comment">% N - number of samples in a single OFDM symbol</span></span><br><span class="line">    <span class="comment">% y - returns the OFDM symbol without cyclic prefix</span></span><br><span class="line">    y = r(Ncp + <span class="number">1</span>:N + Ncp); <span class="comment">%cut from index Ncp+1 to N+Ncp</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[SER]</span> = <span class="title">ser_awgn</span><span class="params">(EbN0dB, MOD_TYPE, M, COHERENCE)</span></span></span><br><span class="line">    <span class="comment">%Theoretical Symbol Error Rate for various modulations over AWGN</span></span><br><span class="line">    <span class="comment">%EbN0dB - list of SNR per bit values</span></span><br><span class="line">    <span class="comment">%MOD_TYPE - &#x27;BPSK&#x27;,&#x27;PSK&#x27;,&#x27;QAM&#x27;,&#x27;PAM&#x27;,&#x27;FSK&#x27;</span></span><br><span class="line">    <span class="comment">%M - Modulation level for the chosen modulation</span></span><br><span class="line">    <span class="comment">% - For PSK,PAM,FSK M can be any power of 2</span></span><br><span class="line">    <span class="comment">% - For QAM M must be even power of 2 (square QAM only)</span></span><br><span class="line">    <span class="comment">%Parameter COHERENCE is only applicable for FSK modulation</span></span><br><span class="line">    <span class="comment">%COHERENCE = &#x27;coherent&#x27; for coherent FSK detection</span></span><br><span class="line">    <span class="comment">% = &#x27;noncoherent&#x27; for noncoherent FSK detection</span></span><br><span class="line">    gamma_b = <span class="number">10</span> .^ (EbN0dB / <span class="number">10</span>); <span class="comment">%SNR per bit in linear scale</span></span><br><span class="line">    gamma_s = <span class="built_in">log2</span>(M) * gamma_b; <span class="comment">%SNR per symbol in linear scale</span></span><br><span class="line">    SER = <span class="built_in">zeros</span>(<span class="built_in">size</span>(EbN0dB));</span><br><span class="line">    <span class="keyword">switch</span> lower(MOD_TYPE)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;bpsk&#x27;</span></span><br><span class="line">            SER = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b));</span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;psk&#x27;</span>, <span class="string">&#x27;mpsk&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> M == <span class="number">2</span> <span class="comment">%for BPSK</span></span><br><span class="line">                SER = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> M == <span class="number">4</span> <span class="comment">%for QPSK</span></span><br><span class="line">                    Q = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b)); SER = <span class="number">2</span> * Q - Q .^ <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">%for other higher order M-ary PSK</span></span><br><span class="line">                    SER = <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_s) * <span class="built_in">sin</span>(<span class="built_in">pi</span> / M));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;qam&#x27;</span>, <span class="string">&#x27;mqam&#x27;</span>&#125;</span><br><span class="line">            SER = <span class="number">1</span> - (<span class="number">1</span> - (<span class="number">1</span> - <span class="number">1</span> / <span class="built_in">sqrt</span>(M)) * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>/<span class="number">2</span> * gamma_s / (M - <span class="number">1</span>)))) .^ <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;fsk&#x27;</span>, <span class="string">&#x27;mfsk&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> strcmpi(COHERENCE, <span class="string">&#x27;coherent&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">length</span>(gamma_s)</span><br><span class="line">                    fun = @(q) (<span class="number">0.5</span> * <span class="built_in">erfc</span>((-q - <span class="built_in">sqrt</span>(<span class="number">2</span> .* gamma_s(ii))) / <span class="built_in">sqrt</span>(<span class="number">2</span>))) .^ (M - <span class="number">1</span>) .* <span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>) .* <span class="built_in">exp</span>(-q .^ <span class="number">2</span>/<span class="number">2</span>);</span><br><span class="line">                    SER(ii) = <span class="number">1</span> - integral(fun, -<span class="built_in">inf</span>, <span class="built_in">inf</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">%Default compute for noncoherent</span></span><br><span class="line">                <span class="keyword">for</span> jj = <span class="number">1</span>:<span class="built_in">length</span>(gamma_s)</span><br><span class="line">                    summ = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M - <span class="number">1</span></span><br><span class="line">                        n = M - <span class="number">1</span>; r = <span class="built_in">i</span>; <span class="comment">%for nCr formula</span></span><br><span class="line">                        summ = summ + (<span class="number">-1</span>) .^ (<span class="built_in">i</span> + <span class="number">1</span>) ./ (<span class="built_in">i</span> + <span class="number">1</span>) .* prod((n - r + <span class="number">1</span>:n) ./ (<span class="number">1</span>:r)) .* <span class="built_in">exp</span>(-<span class="built_in">i</span> ./ (<span class="built_in">i</span> + <span class="number">1</span>) .* gamma_s(jj));</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    SER(jj) = summ; <span class="comment">%Theoretical SER for non-coherent detection</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;pam&#x27;</span>, <span class="string">&#x27;mpam&#x27;</span>&#125;</span><br><span class="line">            SER = <span class="number">2</span> * (<span class="number">1</span> - <span class="number">1</span> / M) * <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(<span class="number">3</span> * gamma_s / (M ^ <span class="number">2</span> - <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">otherwise</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;ser_awgn.m: Invalid modulation (MOD_TYPE) selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思考知识记录</title>
      <link href="/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>日常思考及知识点记录</h1><blockquote><p>此文档主要记录一些日常经过思考的问题，以及一些容易混淆的知识点，不限于专业知识，可能包括其他学科……</p></blockquote><h2 id="数学类">数学类</h2><h3 id="充要条件的充分和必要性">充要条件的充分和必要性</h3><blockquote><p>充要条件的充分性和必要性怎么区分？</p><p>记住一点：根据条件椎结论就是证明充分性，根据结论推条件就是证明必要性</p></blockquote><p>充要条件的表述一般有3钟表述方式：</p><ul><li>求证：$A$是$B$的充要条件</li><li>求证：$A$的充要条件是$B$</li><li>求证：$A\Longleftrightarrow B $（等价于第二条，即$A$的充要条件是$B$）</li></ul><blockquote><p>怎么看哪个是条件呢？如上提取主谓宾，谁是条件一目了然。在①中，A是条件，由A推出B就是证明充分性，反之由B推出A就是证明必要性;在②③中，条件是B，所以由B推出A就是证明充分性，反之由A推出B就是证明必要性。</p></blockquote><h3 id="集合类相关">集合类相关</h3><ul><li>常用集合的字母含义</li></ul><p>​$\mathbb{N}$：自然数集；$\mathbb{Z}$：整数集；$\mathbb{Q}$：有理数集；$\mathbb{R}$：实数集；$\mathbb{C} $：复数集；</p><h2 id="专业类">专业类</h2><h3 id="概率论">概率论</h3><h4 id="全概率公式和贝叶斯公式">全概率公式和贝叶斯公式</h4><blockquote><p>事件A和事件B，事件A先发生，事件B后发生，（事件B发生的第一步有$n$条路径）。全概率公式用于求事件B的概率，而贝叶斯公式用于反推事件$A_i$的概率。</p></blockquote><p><img src="/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/figure.png" alt="figure"></p><p>$$<br>\begin{aligned}<br>P(B) &amp;= P(A_1)P(B \mid A_1)+P(A_2)P(B \mid A_2)+\dots+P(A_n)P(B \mid A_n)\<br>&amp;= \sum_{i=1}^{n}P(A_i)P(B \mid A_i)<br>\end{aligned}\tag{1}<br>$$</p><p>$$<br>P(A_i\mid B)=\frac{P(A_i)P(B\mid A_i)}{P(B)}=\frac{P(A_i)P(B\mid A_i)}{\sum_{i=1}^{N}P(A_i)P(B\mid A_i)}\tag{2}<br>$$</p><blockquote><p>上式（1）即为全概率公式，式（2）为贝叶斯公式</p><p>在通信应用中，接收端收到的信号一般可视为事件B，因此推导接收端的最佳接收性能公式时，通常使用贝叶斯公式。</p></blockquote><h3 id="信号与系统">信号与系统</h3><h4 id="傅里叶变换的本质">傅里叶变换的本质</h4><blockquote><p>在此首先感谢B站UP主 《喵星考拉》的【硬核】系列视频讲解，本部分有很多的细节都是从她的视频学习得到。</p><p>数学是万物根本，是解释其核心原理最直观的体现。</p></blockquote><ul><li><p>傅里叶级数</p><ul><li><p>傅里叶级数的系数<br>$$<br>F(n)=\frac{1}{T}\int_Tf(t)e^{-jn2\pi f_0t}dt\tag1<br>$$</p></li><li><p>用傅里叶级数的系数复原原函数<br>$$<br>f(t)=\sum_{-\infty}^{+\infty}F(n)e^{jn2\pi f_0t}\tag2<br>$$<br>傅里叶级数主要用于周期函数的分解，频率间隔 $\Delta f=f_0=1/T$.</p></li></ul></li></ul><blockquote><p>个人觉得，这个视频最重要的一个结论：傅里叶级数的系数可以等价于<strong>函数内积</strong>；原函数可以理解为傅里叶系数的一堆<strong>线性组合</strong>；内积也可以理解为函数在另一空间的投影，对于复数而言，函数内积需对某一个复值取共轭，从距离的角度考虑这个问题，主要原因是$i^2=1$，例如：$(1+i)\times (1-i)=2=|(1+i)|^2$。所以在式$(1)$中$e$指数取了共轭。</p></blockquote><ul><li><p>傅里叶变换</p><p>傅里叶变换是从傅里叶级数推导而来，应用场景主要为非周期函数，当频率$\Delta f\to +\infty$，化简上式即可得到傅里叶变换的公式。</p><ul><li></li></ul></li></ul><h4 id="【进阶】拉普拉斯变换">【进阶】拉普拉斯变换</h4><h3 id="数字通信">数字通信</h3><h4 id="OFDM-System">OFDM System</h4>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代信号处理Ⅰ学习记录</title>
      <link href="/2024/10/14/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%861/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/14/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%861/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Modern Digital Signal Processing</h1><blockquote><p>Statistical Random</p></blockquote><hr><ol><li>Linear Processing</li></ol><ul><li>Fundamental<ul><li>Statistical Foundation</li><li>Orthogonal</li><li>Orthogonalization</li></ul></li><li>Typical<ul><li>Wiener,  Kalman</li></ul></li><li>Extension<ul><li>SVM, Kernel, Regularization</li></ul></li></ul><ol start="2"><li>Adaptive Processing</li></ol><ul><li>Adaptive Filter, LMS, RLS</li></ul><ol start="3"><li>Spectral Processing</li></ol><ul><li>Direct(Non-Parametric), Filter Banks</li></ul><hr><blockquote><p>1950’s~1980’s <strong>Linear, Orthogonal, Stationary, Gaussian</strong></p></blockquote><h2 id="Chapter-1">Chapter 1</h2><h3 id="Review-of-Probability-Theory">Review of Probability Theory</h3><p><strong>概率的定义：</strong></p><p>Uncertainty $\rightarrow$ Statistical Experiment $\rightarrow$ Sample Points $\rightarrow$ Sample Space $(\Omega)$ $\rightarrow$ Possibility(<strong>Prior</strong>)</p><p>$\rightarrow$ Probability(概率) $P: X^\Omega\rightarrow[0,1]$</p><p><strong>概率与统计</strong></p><p>Data $\longrightarrow$ <strong>Model</strong> $\longrightarrow$ Decision(Big Data: Data $\longrightarrow$ Decision)<br>   $\Downarrow$            $\Downarrow$<br>  Statistics   Probability</p><p>Random Variables: $X:\Omega\rightarrow R$ (Quantization)</p><p>$P(X=x)=P({w\in\Omega|Z(w)=x})$</p><p>Discrete: $\Omega = {w_1,w_2,\dots,w_n}$.   分布列：$P(X=x_k)=P_k$</p><p>Continue:</p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卫星链路计算</title>
      <link href="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/"/>
      <url>/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1>卫星链路计算相关学习</h1><h2 id="前言">前言</h2><blockquote><p>卫星链路计算是每次申请项目时必做的一个环节，我自己也参与计算了两三次，但总觉得自己理解的不够到位，尽管老师和师兄们说很简单，但我始终不相信自己，想从头到尾理解一遍，这也是写这篇博客的初衷。</p></blockquote><h2 id="卫星通信系统">卫星通信系统</h2><blockquote><p>卫星通信系统从发端地球站到收端地球站的信息传输过程中，要经过</p><p><strong>上行链路（uplink）、卫星转发器（transponder）、下行链路（downlink）</strong></p></blockquote><ul><li><p>上行链路信号质量</p><p>取决于：卫星收到的信号功率电平和卫星接收系统的噪声功率电平大小</p></li><li><p>下行链路信号质量</p><p>取决于：收端地球站接收的信号功率电平和地球站接收系统的噪声功率电平的大小</p></li></ul><p>主要目的：尽量有效地在地球上两个通信点之间提供可靠有高质量的连接手段</p><h2 id="卫星链路计算中的相关参数">卫星链路计算中的相关参数</h2><p>卫星链路计算中主要用到的相关参数有：</p><ul><li><strong>天线的增益与波束宽度</strong><ul><li><strong>有效全向辐射功率</strong></li><li><strong>自由空间传输损耗</strong></li><li><strong>噪声与损耗</strong></li><li><strong>转发器工作点</strong></li><li><strong>转发器的饱和通量密度</strong></li><li><strong>品质因数G/T</strong></li></ul></li></ul><h3 id="天线的增益与波束宽度">天线的增益与波束宽度</h3><blockquote><p>卫星通信中，一般使用<strong>定向天线</strong>，即电磁能量聚焦在某一方向辐射</p></blockquote><p>天线的增益定义为：<br>$$<br>G=\frac{定向天线辐射时，接收点收到的最大功率}{全向天线辐射时，接收点收到的功率}<br>$$<br>对于喇叭天线：<br>$$<br>G=\frac{4\pi A}{\lambda^2}\eta<br>$$<br>式中，$A$为天线的口面面积；$\lambda$为工作波长$(m)$；$\eta$为天线效率（电功率与电磁波形式的功率转换时，会造成损失）。</p><p>由公式可以看出，<strong>采用较高的工作频率可以使较小口径天线获得同样大的天线增益</strong>。</p><p>抛物面天线波束的半功率点宽度近似为：<br>$$<br>\theta_\frac{1}{2}\approx70\frac{\lambda}{D}(°)<br>$$<br>半功率角是指<strong>主瓣上场强为主射方向场强的</strong>$1/\sqrt2=0.707$时，即功率下降$1/2$时，两方向的夹角。</p><img src="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/image-20241012151251243.png" alt="image-20241012151251243" style="zoom:80%;"><h3 id="全向辐射功率">全向辐射功率</h3><blockquote><p>卫星通信中用**有效全向辐射功率$EIRP$**来代表地球站或卫星发射系统的发射能力</p></blockquote><p>EIRP是天线所发射的功率$P_t$与该天线增益的乘积：<br>$$<br>EIRP=P_t\times G_t<br>$$<br>上式表明：<strong>在最大辐射方向，定向天线所辐射的功率是全向天线在相同方向辐射功率的 $G_t$ 倍。</strong></p><p>描述了天线在轴线方向上的最大辐射功率<br>$$<br>EIRP(dBW)=P_T(dBW)+G_T(dBi)<br>$$</p><h3 id="自由空间损耗（Free-Space-Path-Loss-FSPL）">自由空间损耗（Free Space Path Loss,  FSPL）</h3><p>考虑理想通信系统，假设系统各部件没有损耗，传输媒质为自由空间，系统框图如下所示：</p><img src="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/image-20241012160040773.png" alt="image-20241012160040773" style="zoom:60%;"><p>$P_t$ 是发射功率；$Gt，Gr$ 分别为发射，接收天线增益； $d$ 为通信距离； $P_r$ 为接收机接收到的信号功率。</p><p>接收功率：<br>$$<br>P_R=P_TG_TG_R(\lambda/(4\pi d))^2=EIRP\cdot G_R(\lambda/(4\pi d))^2<br>$$<br>定义自由空间损耗<br>$$<br>L_f=(4\pi d/\lambda)^2=(4\pi df/c)^2<br>$$<br>自由空间传输损耗表征了两个全向天线闸，发射功率和接收功率之间的比值，即是天线间的传输损耗</p><p>实际中，定义距离$d$的单位为$km$，频率$f$的单位$GHz$，则自由空间损耗可表示为：<br>$$<br>L_f(dB)=92.44+20lg(d)+20lg(f)<br>$$<br>当然，最常见的公式如下，其只是单位换算导致常数项产生差异：<br>$$<br>L_f(dB)=32.45+20lg d(km)+20lg f(MHz)<br>$$</p><h3 id="雨衰">雨衰</h3><p>雨衰随频率的增加而增加</p><p>雨衰对水平极化的影响远大于垂直极化的影响</p><h3 id="载波功率">载波功率</h3><ul><li>载波接收功率$C$</li></ul><p>$$<br>[C]=[EIRP]+[G_R]-[L_p]<br>$$</p><p>$[G_R]$：接收天线的增益（dBi）</p><p>$L_p$：自由空间损耗（dB）</p><p>$EIRP$：发射机的有效全向辐射功率（dBW）</p><ul><li>考虑发射馈线损耗$[L_{FT}]$(dB)，则$[EIRP]$为：</li></ul><p>$$<br>[EIRP]=[P_T]-[L_{FT}]+[G_T]<br>$$</p><ul><li><p>接收机输入端的载波功率</p><!-- 同时考虑接收馈线损耗$[L_{FR}](dB)$、大气损耗$[L_a(dB)]$、其他损耗$[L_r(dB)]$，则接收机输入端的实际载波接收功率$[C(dBW)]$可以表示为 --><p>同时考虑接收馈线损耗$[L_{FR}]$(dB)、大气损耗$[L_a]$(dB)、其他损耗$[L_r]$(dB)，则接收机输入端的实际载波接收功率$[C]$(dBW)可以表示为<br>$$<br>[C]=\textcolor{ #BF3EFF}{[P_T]}-[L_{FT}]+\textcolor{ #BF3EFF}{[G_T]}+\textcolor{ #BF3EFF}{[G_R]}-\textcolor{ #BF3EFF}{[L_p]}-[L_{FR}]-[L_a]-[L_r]<br>$$</p><p>$$<br>EIRP = \textcolor{ #BF3EFF}{[P_T]}-[L_{FT}]+\textcolor{ #BF3EFF}{[G_T]}<br>$$</p></li></ul><h3 id="接收系统的噪声功率">接收系统的噪声功率</h3><p>$$<br>N=kT_tB<br>$$</p><p>N为进入接收系统的噪声功率；$T_t$为天线的等效噪声温度；$k=1.38\times 10^{-23}J/K$玻尔兹曼常数；$B$为接收系统的等效噪声带宽</p><h3 id="接收机输入端的载噪比与地球站性能因数">接收机输入端的载噪比与地球站性能因数</h3><p>$$<br>\frac{C}{N}=\frac{P_TG_TG_R}{L_P}\cdot\frac{1}{kT_tB}<br>$$</p><p>$$<br>\left [ \frac{C}{N}\right]=\left [EIRP\right]-\left [L_p\right]-\left [G_R\right]-10\lg (kT_tB)<br>$$</p><p>$$<br>\left [EIRP\right]=\left [P_T\cdot G_T\right]=\left [P_T\right]+\left [G_T\right]<br>$$</p><p>地球站接收机输入端的$[C/N]_E$</p><p>$$<br>\left [ \frac{C}{N} \right]_E=\left [EIRP\right]_S-\left [L_D\right]-\left [G{RE}\right]-10\lg (kT_tB)<br>$$</p><h3 id="计算程序">计算程序</h3><blockquote><p>下面是下行链路计算的一个MATLAB简单程序</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% @ DATA: 2024-10-12-17:19:49</span></span><br><span class="line"><span class="comment">% @ Author: Poster</span></span><br><span class="line"><span class="comment">% @ Description:</span></span><br><span class="line"><span class="comment">% @ Notes:</span></span><br><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 通信距离计算</span></span><br><span class="line">h = <span class="number">550</span>; <span class="comment">% 轨道高度(km)</span></span><br><span class="line">theta_deg = <span class="number">25</span>; <span class="comment">% 地球站至卫星的仰角(°)</span></span><br><span class="line">theta = deg2rad(theta_deg); <span class="comment">% rad</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;地面通信终端天线仰角: &#x27;</span>, num2str(theta_deg), <span class="string">&#x27;°&#x27;</span>]);</span><br><span class="line">RE = <span class="number">6378.14</span>; <span class="comment">% 地球半径(km)</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="built_in">asin</span>(RE / (RE + h) * <span class="built_in">cos</span>(theta)); <span class="comment">% 卫星到地心与到地球站的夹角(rad)</span></span><br><span class="line">beta_deg = <span class="built_in">beta</span> * <span class="number">180</span> / <span class="built_in">pi</span>; <span class="comment">% °</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;卫星天线对地张角: &#x27;</span>, num2str(beta_deg), <span class="string">&#x27;°&#x27;</span>]);</span><br><span class="line">alpha = <span class="built_in">pi</span> / <span class="number">2</span> - <span class="built_in">beta</span> - theta; <span class="comment">% 地心角(rad)</span></span><br><span class="line">d = RE * <span class="built_in">sin</span>(alpha) / <span class="built_in">sin</span>(<span class="built_in">beta</span>); <span class="comment">% 通信距离(km)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;通信距离: &#x27;</span>, num2str(d), <span class="string">&#x27;km&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 自由空间损耗计算</span></span><br><span class="line">fc = <span class="number">11.7e3</span>; <span class="comment">% carrier frequency(MHz)</span></span><br><span class="line">Lp = <span class="number">32.45</span> + <span class="number">20</span> * <span class="built_in">log10</span>(fc) + <span class="number">20</span> * <span class="built_in">log10</span>(d); <span class="comment">% Free Space Path Loss(dB)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;自由空间损耗: &#x27;</span>, num2str(Lp), <span class="string">&#x27;dB&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line">EIRP = <span class="number">36.7</span>; <span class="comment">% Effective Isotropic Radiated Power(dBm)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;有效全向辐射功率EIRP: &#x27;</span>, num2str(EIRP), <span class="string">&#x27;dBm&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 其他损耗</span></span><br><span class="line">La = <span class="number">2.4</span>; <span class="comment">% Atmospheric Loss(dB)</span></span><br><span class="line">Lr = <span class="number">1</span>; <span class="comment">% Other Loss(dB)</span></span><br><span class="line">Lfr = <span class="number">0</span>; <span class="comment">% 接收馈线损耗(dB)(天线指向损失;极化损失)</span></span><br><span class="line">L = Lp + La + Lr + Lfr; <span class="comment">% Total Loss(dB)</span></span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 地面终端 G/T</span></span><br><span class="line">G = <span class="number">32.8</span>; <span class="comment">% 天线增益(dBi)</span></span><br><span class="line">eta = <span class="number">0.5</span>; <span class="comment">% 天线效率</span></span><br><span class="line">aperture = <span class="number">2</span>; <span class="comment">% 天线孔径(m)</span></span><br><span class="line">lambda = <span class="number">3e8</span> / (fc * <span class="number">1e6</span>); <span class="comment">% 波长(m)</span></span><br><span class="line">G_c = <span class="number">10</span> * <span class="built_in">log10</span>(eta * <span class="number">4</span> * <span class="built_in">pi</span> * aperture / (lambda ^ <span class="number">2</span>)); <span class="comment">% 抛物面天线增益(dBi)</span></span><br><span class="line">T = <span class="number">300</span>; <span class="comment">%系统噪声温度</span></span><br><span class="line">GT = G - <span class="number">10</span> * <span class="built_in">log10</span>(T); <span class="comment">% 系统G/T比率(dB/K)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;系统G/T值: &#x27;</span>, num2str(GT), <span class="string">&#x27; dB/K&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 接收机载噪比</span></span><br><span class="line">B = <span class="number">250e6</span>; <span class="comment">% 接收机带宽(MHz)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;接收机带宽: &#x27;</span>, num2str(B / <span class="number">1e6</span>), <span class="string">&#x27;MHz&#x27;</span>]);</span><br><span class="line">cons = <span class="number">-228.6</span>; <span class="comment">% 玻尔兹曼常数(dBW/K/Hz)</span></span><br><span class="line">CN = EIRP - L + GT - <span class="number">10</span> * <span class="built_in">log10</span>(B) - cons; <span class="comment">% 接收机接收功率(dBm)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;载噪比C/N: &#x27;</span>, num2str(CN), <span class="string">&#x27;dB&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>通过载噪比，后续结合调制方式可以计算$E_b/N_0$，从而推算整个通信系统BER等系统参数。</p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 公式推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青春语句</title>
      <link href="/2024/10/07/%E7%94%9F%E6%B4%BB%E5%A8%B1%E4%B9%90/%E9%9D%92%E6%98%A5/"/>
      <url>/2024/10/07/%E7%94%9F%E6%B4%BB%E5%A8%B1%E4%B9%90/%E9%9D%92%E6%98%A5/</url>
      
        <content type="html"><![CDATA[<h1>青春</h1><blockquote><p>“碧华映朱实，攀折青春时”。青春是“草长莺飞二月天，拂堤杨柳醉春烟”的年华美好，青春带着“倚门回首，却把青梅嗅”的甜蜜，青春也会走过“雾失楼台，月迷津渡”的困惑，但“少年负壮气，奋烈自有时”，青春总会激荡出“一身能擘两雕弧，虏骑千重只似无”的力量；张扬着“大鹏一日同风起，扶摇直上九万里”的义气；因为青春意味着奋发与成长，愿每个人都能永葆青春的状态，依旧“满身花雨又归来”。​</p></blockquote><h1>君子志向：坚韧</h1><blockquote><p>月缺不改光，剑折不改刚”，有志向的人自信自强；“君子量不极，胸吞百川流”，有志向的人心有远方；“丈夫非无泪，不洒离别间”，有志向的人情深意长；“及时当勉励，岁月不待人”，有志向的人不会虚度时光；“人生感意气，功名谁复论”，有志向的人看淡名利；“感时思报国，拔剑起蒿莱”，有志向的人是最可靠的力量；“愿君学长松，慎勿作桃李”，新时代，新舞台，让我们“共矜然诺心，各负纵横志”。<br>“无情未必真豪杰”，英雄的身上，闪耀着人性的熠熠光辉，他们有“若遇早梅开，一枝应寄来”的高尚友情；有“不思量，自难忘”的真挚爱情；有“从今别去江南路，化作啼鹃带血归”的不舍乡情；有“生民百遗一，念之断人肠”的痛楚悲情；有“一寸丹心图报国，两行清泪为相思”的拳拳亲情；更有“生当作人杰，死亦为鬼雄”的满腔豪情；英雄的真情总会化为人间甘霖，“赤风洒雨露，春日在天涯”。 ​<br>“成败何足论，英雄自有真”。每一位英雄都在书写最真实的人生。“亦余心之所善兮，虽九死其犹未悔”，屈原的炽热情怀；“旄尽风霜节，心悬日月光”，苏武的不灭气节；“出师一表真名世，千载谁堪伯仲间”，诸葛亮的鞠躬尽瘁；“做事循天理，博爱惜生灵”，范仲淹的爽直磊落；“镜里朱颜都变尽，只有丹心难灭”，文天祥的至死不渝。英雄探寻着生命的真谛，“若有人知春去处，唤取归来同住”，让我们在经典中与英雄相伴。<br>英雄的本色是什么，是“雨打灯难灭，风吹色更明”的坚韧；是“一年三百六十日，多是横戈马上行”的不辞艰辛；是“高情已逐晓云空，不与梨花同梦”的超越平庸；是“男儿何不带吴钩，收取关山五十州”的满腔壮志；是“一腔热血勤珍重，洒去犹能化碧涛”的不惧牺牲；是“回看射雕处，千里暮云平”的襟怀坦荡；是“富贵非所愿，与人驻颜光”的无私奉献；“英雄自古常如此，愿逐月华流照君”，让我们在经典中，追随那些铿锵前行的脚步。<br>一首经典就是一个良师益友。“纷吾既有此内美兮，又重之以修能”教会我们成长；“谁知盘中餐，粒粒皆辛苦”教会我们珍惜；“我生本无乡，心安是归处”教会我们旷达；“纵浪大化中，不喜亦不惧”教会我们放下；“埋骨何须桑梓地，人生无处不青山”教会我们志向；与经典同行，诗词为伴。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切从这里开始</title>
      <link href="/2024/10/04/%E5%BC%80%E5%A7%8B/"/>
      <url>/2024/10/04/%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<pre><code>【主题配置】    https://butterfly.js.org/posts/ceeb73f/    记录我的学习之旅</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>硬件培训2022</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h1>硬件培训2022</h1><blockquote><p>主要记录硬件培训的学习笔记和仿真记录。</p></blockquote><h2 id="培训系列学习及仿真记录">培训系列学习及仿真记录</h2><h3 id="文章-swig￼0">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/" title="BPSK收发系统">BPSK学习及仿真</a></h3><h3 id="文章-swig￼1">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/" title="BPSK-DSSS收发系统">BPSK-DSSS学习及仿真</a></h3><h3 id="文章-swig￼2">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/" title="DDS原理及简单应用">DDS原理及简单应用</a></h3><h3 id="文章-swig￼3">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/" title="载波同步学习及仿真">载波同步学习及仿真</a></h3><h3 id="文章-swig￼4">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/" title="定时同步学习及仿真">定时同步学习及仿真</a></h3><h3 id="文章-swig￼5">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/06%E7%A0%81%E7%8E%AF/%E7%A0%81%E7%8E%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/" title="码环学习及仿真">码环学习及仿真</a></h3><h3 id="文章-swig￼6">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/" title="捕获和积累学习及仿真">捕获和积累学习及仿真</a></h3><h3 id="文章-swig￼7">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/" title="FPGA发端设计">FPGA发端设计</a></h3><h3 id="参考-师兄的笔记">[参考] 师兄的笔记</h3><p><a href="https://www.wolai.com/benko/v4ir4nzYagWPGRSPcu8j4X" title="Benko's Notes 这是Benko的笔记本，精选笔者认为比较重要的一些笔记供大家参考，欢迎一起交流。 https://www.wolai.com/benko/v4ir4nzYagWPGRSPcu8j4X">Benko’s Notes 这是Benko的笔记本，精选笔者认为比较重要的一些笔记供大家参考，欢迎一起交流。 https://www.wolai.com/benko/v4ir4nzYagWPGRSPcu8j4X</a></p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>载波同步学习及仿真</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1>载波同步相关知识</h1><h2 id="简单回顾">简单回顾</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_xo7bUoSg1x.png" alt></p><h2 id="需要同步的原因">需要同步的原因</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_jcq_LZ1B5Z.png" alt></p><h3 id="载波环">载波环</h3><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_w2y1dWV8Dc.png" alt></p><h2 id="锁相环关注的是信号的相位分量">锁相环关注的是信号的相位分量</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_lRd5nOUzo3.png" alt></p><hr><blockquote><p>在锁相环中，要时刻记住，我们所关注的对象是相位信息，不是输入输出电压或电流的幅值，而是电压信号的瞬时相位；<br>在有些说法中，锁相环关注的是相位信息或者频率信息，这是因为对瞬时相位进行微分就可以得到瞬时频率，因此也可以说关注的是输入输出信号的频率，这二者并不矛盾。</p></blockquote><h2 id="VCO是一个积分器件">VCO是一个积分器件</h2><blockquote><p>对于VCO是一个积分器件，刚开始很容易不理解，单从VCO的功能上来看，它是一个电压与频率的变换装置在环路中作为压控振荡器，它的振荡频率随输入控制电压线性地变化。</p></blockquote><p>$$<br>w_v(t)=w_o+K_0u_c(t)<br>$$</p><blockquote><p>式中，$w_v(t)$是压控振荡器的瞬时角频率(rad/s)；$w_o$为压控振荡器的固有角频率，即无输入控制电压情况下的振荡角频率(rad/s)；$K_0$为VCO的频率灵敏度或称增益系数rad/(s·V)；<br>模拟压控振荡器的控制特性只有有限的控制范围，超出范围之后控制灵敏度会下降。数字则在范围内都是线性关系。</p></blockquote><hr><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_GfwEOGsm7r.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_C0Z0aPTLRR.png" alt></p><h3 id="《GPS原理与接收机设计》谢钢—学习">《GPS原理与接收机设计》谢钢—学习</h3><h2 id="环路带宽">环路带宽</h2><blockquote><p>环路带宽又称噪声带宽，它控制着进入环路的噪声量的多少。噪声带宽越窄，则由于越少频率成分的噪声被允许进入环路，因而环路的滤波效果越好，环路对信号的跟踪就越准确；反之，噪声带宽越宽，环路的噪声性能越差，信号跟踪越不准确，以Hz为单位的定义式如下：</p></blockquote><p>$$<br>\small B_L=\int^{\infty}_0|H(f)|^2df<br>$$</p><blockquote><p>$w=2\pi f$ $ s→j2\pi f$</p><p>得到一阶环路噪声带宽</p></blockquote><p>$$<br>{B_L = } {w_n \over 4}<br>$$</p><blockquote><p>二阶锁相环噪声带宽</p></blockquote><p>$$<br>B_L = {w_n \over 2} \bigg( \xi + {1\over 4\xi}\bigg)<br>$$</p><blockquote><p>噪声带宽$B_L$并不能无限的小，由于高动态应力会引起接收信号载波频率和相位跟踪误差的激烈振荡，所以我们希望环路带宽$B_L$能大到足够容忍这种由于用户运动而引起的载波频率和相位的正常波动，以保证环路对信号的持续跟踪；否则，若$B_L$过小，可能将有用信号一起滤除，使环路容易发生信号失锁。<br>可见，环路带宽$B_L$是锁相环的一个重要参量，越大的环路带宽可使接收机具有越强的支持用户高动态性的能力，但这也同时降低了它的噪声性能。</p></blockquote><blockquote><p>对于二阶环路来说，给定一个$w_n$，则当阻尼系数$\xi$等于$0.5$时，环路带宽$B_L$达到最小值，此时应当具有最好的噪声性能，然而阻尼系数经常选取$0.7071(即{\sqrt2\over2})$，此时</p></blockquote><p>$$<br>B_L=0.53w_n<br>\a_2=1.414 ;B_L={1+a^2_2\over4a_2}w_n=0.53w_n<br>$$</p><blockquote><p>补充：</p></blockquote><h2 id="I-Q解调">I/Q解调</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_cE-hkQwFRx.png" alt></p><h1>MATLAB仿真</h1><h2 id="仿真代码">仿真代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%%%%%%%%%---------数字锁相环的实现----------%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%%%%%%%%%-----BPSK基础上加上频偏，实现载波同步-----%%%%%%%%%%%%%%%%%</span></span><br><span class="line">symbol_rate = <span class="number">10000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = fs / <span class="number">4</span>; <span class="comment">% 载波频率40000/4</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">500</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(data_up, fir_rcos); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx_valid) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs .* t); <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx_valid .* carrier; <span class="comment">%上变频</span></span><br><span class="line">r_n = awgn(s_up, <span class="number">10</span>, <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%加高斯白噪声</span></span><br><span class="line"><span class="comment">%正交下变频</span></span><br><span class="line">delta_f = <span class="number">100</span>; <span class="comment">%设置频偏参数</span></span><br><span class="line">carrier_cos = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc + delta_f) / fs * t); <span class="comment">%加频偏</span></span><br><span class="line">carrier_sin = <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc + delta_f) / fs * t);</span><br><span class="line">sig_I = r_n .* carrier_cos;</span><br><span class="line">sig_Q = r_n .* carrier_sin;</span><br><span class="line">r_bx_I = conv(sig_I, fir_rcos);</span><br><span class="line">r_bx_I_valid = r_bx_I(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">r_bx_Q = conv(sig_Q, fir_rcos);</span><br><span class="line">r_bx_Q_valid = r_bx_Q(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">r_complex = <span class="built_in">complex</span>(r_bx_I_valid, r_bx_Q_valid);</span><br><span class="line">r_complex_de = r_complex(<span class="number">1</span>:sps:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%%%%%载波同步</span></span><br><span class="line">pll_detector = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">nco = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line"></span><br><span class="line">BL = <span class="number">300</span>;</span><br><span class="line">Wn = BL / <span class="number">0.53</span>;</span><br><span class="line">T = <span class="number">1</span> / symbol_rate;</span><br><span class="line"><span class="comment">%近似求法</span></span><br><span class="line">c1 = <span class="built_in">sqrt</span>(<span class="number">2</span>) * Wn * T;</span><br><span class="line">c2 = (Wn * T)^<span class="number">2</span>;</span><br><span class="line"><span class="comment">%准确求法</span></span><br><span class="line"><span class="comment">%c1 = (4 * (Wn * T)^2 + 4 * sqrt(2) * Wn * T) / (4 + 2 * sqrt(2) * Wn * T + (Wn * T)^2);</span></span><br><span class="line"><span class="comment">%c2 = (4 * (Wn * T)^2) / (4 + 2 * sqrt(2) * Wn * T + (Wn * T)^2);</span></span><br><span class="line"><span class="comment">%c1 = 1/2^8; c2 = 1/2^17; %环路滤波器系数</span></span><br><span class="line">w = [<span class="number">1</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)]; <span class="comment">%环路滤波器输出寄存器，初值设为0.5</span></span><br><span class="line">I_pll = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">Q_pll = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">pll_out = [r_complex_de(<span class="number">1</span>), <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)];</span><br><span class="line"><span class="comment">%w = zeros(1,sps*N);</span></span><br><span class="line">A = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line"><span class="comment">%% 载波环</span></span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">2</span>:N</span><br><span class="line">    pll_out(ii) = r_complex_de(ii) * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span> * <span class="built_in">mod</span>(nco(ii - <span class="number">1</span>), <span class="number">2</span> * <span class="built_in">pi</span>));</span><br><span class="line">    <span class="comment">%数字鉴相器</span></span><br><span class="line">    I_pll(ii) = <span class="built_in">real</span>(pll_out(ii));</span><br><span class="line">    Q_pll(ii) = <span class="built_in">imag</span>(pll_out(ii));</span><br><span class="line">    pll_detector(ii) = <span class="built_in">atan</span>(Q_pll(ii) / I_pll(ii)); <span class="comment">%鉴相器输出</span></span><br><span class="line">    <span class="comment">%通过环路滤波器</span></span><br><span class="line">    <span class="comment">%     if (ii &gt; 1)</span></span><br><span class="line">    <span class="comment">%     w(ii + 1) = w(ii) + c1 * (pll_detector(ii) - pll_detector(ii - 1)) + c2 * pll_detector(ii);</span></span><br><span class="line">    <span class="comment">%     else</span></span><br><span class="line">    <span class="comment">%     w(ii + 1) = w(ii) + c1 * pll_detector(ii) + c2 * pll_detector(ii);</span></span><br><span class="line">    <span class="comment">%     end</span></span><br><span class="line">    A(ii) = c2 * pll_detector(ii) + A(ii - <span class="number">1</span>);</span><br><span class="line">    w(ii) = c1 * pll_detector(ii) + A(ii - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">%NCO</span></span><br><span class="line">    nco(ii) = nco(ii - <span class="number">1</span>) + w(ii);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y_decision = <span class="built_in">real</span>(pll_out) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">%y_decision = pll_out(1:1:end) &gt; 0;</span></span><br><span class="line">error_bit = sum(<span class="built_in">abs</span>(y_decision - data));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_plot</span><br><span class="line">    <span class="comment">%figure(1);</span></span><br><span class="line">    <span class="comment">%plot(w); title(&#x27;环路滤波器输出&#x27;);</span></span><br><span class="line">    <span class="comment">%figure(2);</span></span><br><span class="line">    <span class="comment">%plot(nco); title(&#x27;NCO输出&#x27;);</span></span><br><span class="line"></span><br><span class="line">    scatterplot(r_complex_de);</span><br><span class="line">    grid on; axis tight;</span><br><span class="line">    scatterplot(pll_out);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="输出结果">输出结果</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_J-E0VYI50m.png" alt></p><blockquote><p><strong>验证输出结果是否正确，直观检验误码率</strong></p></blockquote><p><strong>修改</strong>**<code>N = 50000; %数据长度</code>**<strong>输出星座图</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_zKlcvr1Hem.png" alt></p><p><strong>环路滤波器输出图像和NCO输出图像</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_VM4HN1sVx0.png" alt></p><blockquote><p>完成上述操作之后，再进行误码率分析即可减少错误来源，即模块化分析；</p></blockquote><hr><p>😌</p><p><strong>误码率仿真分析</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%%%%%%%%%---------数字锁相环的实现----------%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%%%%%%%%%-----BPSK基础上加上频偏，实现载波同步-----%%%%%%%%%%%%%%%%%</span></span><br><span class="line">symbol_rate = <span class="number">10000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = fs / <span class="number">4</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">500000</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(fir_rcos, data_up); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx_valid) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx_valid .* carrier; <span class="comment">%上变频</span></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span> * <span class="built_in">log10</span>(sps); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">    r_n = awgn(s_up, snr(<span class="built_in">i</span>), <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%加高斯白噪声</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%%%%正交下变频</span></span><br><span class="line">    delta_f = <span class="number">100</span>; <span class="comment">%设置频偏参数</span></span><br><span class="line">    carrier_cos = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc + delta_f) / fs * t); <span class="comment">%加频偏</span></span><br><span class="line">    carrier_sin = <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc + delta_f) / fs * t);</span><br><span class="line">    sig_I = r_n .* carrier_cos;</span><br><span class="line">    sig_Q = r_n .* carrier_sin;</span><br><span class="line">    r_bx_I = conv(sig_I, fir_rcos);</span><br><span class="line">    r_bx_I_valid = r_bx_I(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    r_bx_Q = conv(sig_Q, fir_rcos);</span><br><span class="line">    r_bx_Q_valid = r_bx_Q(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    r_complex = <span class="built_in">complex</span>(r_bx_I_valid, r_bx_Q_valid);</span><br><span class="line">    r_complex_de = r_complex(<span class="number">1</span>:sps:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%%%%%%%载波同步</span></span><br><span class="line">    BL = <span class="number">300</span>;</span><br><span class="line">    Wn = BL / <span class="number">0.53</span>;</span><br><span class="line">    T = <span class="number">1</span> / symbol_rate;</span><br><span class="line">    <span class="comment">%近似求法</span></span><br><span class="line">    <span class="comment">%     c1 = sqrt(2) * Wn * T;</span></span><br><span class="line">    <span class="comment">%     c2 = (Wn * T)^2;</span></span><br><span class="line">    <span class="comment">%准确求法</span></span><br><span class="line">    c1 = (<span class="number">4</span> * (Wn * T)^<span class="number">2</span> + <span class="number">4</span> * <span class="built_in">sqrt</span>(<span class="number">2</span>) * Wn * T) / (<span class="number">4</span> + <span class="number">2</span> * <span class="built_in">sqrt</span>(<span class="number">2</span>) * Wn * T + (Wn * T)^<span class="number">2</span>);</span><br><span class="line">    c2 = (<span class="number">4</span> * (Wn * T)^<span class="number">2</span>) / (<span class="number">4</span> + <span class="number">2</span> * <span class="built_in">sqrt</span>(<span class="number">2</span>) * Wn * T + (Wn * T)^<span class="number">2</span>);</span><br><span class="line">    <span class="comment">%     c1 = 1/2^8; c2 = 1/2^17; %环路滤波器系数</span></span><br><span class="line">    w = [<span class="number">1</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)]; <span class="comment">%环路滤波器输出寄存器，初值设为1</span></span><br><span class="line">    I_pll = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">    Q_pll = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">    pll_out = [r_complex_de(<span class="number">1</span>), <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)];</span><br><span class="line">    pll_detector = [<span class="built_in">atan</span>(Q_pll(<span class="number">1</span>) / I_pll(<span class="number">1</span>)), <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)];</span><br><span class="line">    nco = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">    <span class="comment">%w = zeros(1,sps*N);</span></span><br><span class="line">    A = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line">    <span class="comment">%% 载波环</span></span><br><span class="line">    <span class="keyword">for</span> ii = <span class="number">2</span>:N</span><br><span class="line">        pll_out(ii) = r_complex_de(ii) * <span class="built_in">exp</span>(<span class="number">-1</span><span class="built_in">i</span> * <span class="built_in">mod</span>(nco(ii - <span class="number">1</span>), <span class="number">2</span> * <span class="built_in">pi</span>));</span><br><span class="line">        <span class="comment">%数字鉴相器</span></span><br><span class="line">        I_pll(ii) = <span class="built_in">real</span>(pll_out(ii));</span><br><span class="line">        Q_pll(ii) = <span class="built_in">imag</span>(pll_out(ii));</span><br><span class="line">        pll_detector(ii) = <span class="built_in">atan</span>(Q_pll(ii) / I_pll(ii)); <span class="comment">%鉴相器输出</span></span><br><span class="line">        <span class="comment">%通过环路滤波器</span></span><br><span class="line">        <span class="comment">%     if (ii &gt; 1)</span></span><br><span class="line">        <span class="comment">%     w(ii + 1) = w(ii) + c1 * (pll_detector(ii) - pll_detector(ii - 1)) + c2 * pll_detector(ii);</span></span><br><span class="line">        <span class="comment">%     else</span></span><br><span class="line">        <span class="comment">%     w(ii + 1) = w(ii) + c1 * pll_detector(ii) + c2 * pll_detector(ii);</span></span><br><span class="line">        <span class="comment">%     end</span></span><br><span class="line">        A(ii) = c2 * pll_detector(ii) + A(ii - <span class="number">1</span>);</span><br><span class="line">        w(ii) = c1 * pll_detector(ii) + A(ii - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">%NCO</span></span><br><span class="line">        nco(ii) = nco(ii - <span class="number">1</span>) + w(ii);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%抽样判决</span></span><br><span class="line">    y_decision = <span class="built_in">real</span>(pll_out) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">%errbit(i) = sum(abs(y_decision(301:N) - data(301:N))) / (N - 300);</span></span><br><span class="line">    errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(y_decision - data)) / N;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_plot</span><br><span class="line">    <span class="comment">%     figure;</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 1);</span></span><br><span class="line">    <span class="comment">%     stem(data, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 2);</span></span><br><span class="line">    <span class="comment">%     stem(yI_decision, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">    ber_theory = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>, ebn0 / <span class="number">10</span>))); <span class="comment">%理论误码率</span></span><br><span class="line">    semilogy(ebn0, ber_theory, <span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    semilogy(ebn0, errbit, <span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>); ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">    title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>, <span class="string">&#x27;仿真误码率曲线&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_5_UqO0SRBd.png" alt></p><ul><li><p><strong>验证一行代码</strong> <code>conv(a,b,'same')</code></p><blockquote><p>根据信号与系统中卷积的知识，卷积完的序列长度为$M+N-1$，通过滤波器，相当于卷积，但输出应该和原来的数据长度一致，比如输入长度为$N$，输出也应该为$N$，其余数据是无用数据，包括滤波器的时延以及拖尾带来的无用数据，对此需要截断处理，越早截断，越不容易出错。<br>滤波器时延为${\tau-2}\over 2$；根据公式结合滤波器长度即可截断，当然 <code>conv(a,b,'same')</code> 更为方便，输出长度与$a$一致，且为有效数据，下面举相关的例子进行验证。</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">symbol_rate = <span class="number">10000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = fs / <span class="number">4</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">500</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(data_up, fir_rcos); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">data_bx_2 = conv(data_up, fir_rcos,<span class="string">&#x27;same&#x27;</span>);</span><br><span class="line">y = data_bx_valid - data_bx_2;</span><br><span class="line"><span class="built_in">plot</span>(y);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/04%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5/%E8%BD%BD%E6%B3%A2%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_mKlIamSAj3.png" alt></p><blockquote><p>对上述结果进行分析， <code>data_bx</code> 为直接卷积输出， <code>fir_rcos</code> 为滤波器序列（长度为$25$），<code>s_up</code>为输入滤波器的信号序列（长度为$2000$），根据卷积理论，<code>data_bx</code>长度为（$25+2000-1=2024$）；时延为$(25-1)/2=12$，所以根据<em>MATLAB</em>语法，有效序列应该从第$13$个数算起，即：${ {(length-1)} \over{2} }+1={ {(length+1)} \over{2} }$，和代码<code>data_bx(1, (1 + length(fir_rcos)) / 2:end - (length(fir_rcos) - 1) / 2)</code>对应。<br><code>data_bx_2 = conv(data_up, fir_rcos,'same');</code> <code>y = data_bx_valid - data_bx_2;</code>由图中可以看出，y恒为0，说明两者得出的结果完全一致；<br>就以后编程而言，优先选择加“$same$”，简单而不容易错，但从理解卷积与滤波器的角度来看，显然从数学公式的截断角度更为直观。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BPSK-DSSS收发系统</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>MATLAB仿真</h1><h2 id="目录">目录</h2><ul><li><a href="#matlab%E4%BB%BF%E7%9C%9F">MATLAB仿真</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">系统实现</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE">系统框图</a></li></ul></li><li><a href="#%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81">仿真代码</a><ul><li><a href="#%E7%94%9F%E6%88%90m%E5%BA%8F%E5%88%97">生成m序列</a></li><li><a href="#%E6%89%A9%E9%A2%91%E7%A0%81%E4%B8%8E%E6%98%A0%E5%B0%84%E5%BA%8F%E5%88%97%E7%9B%B8%E4%B9%98">扩频码与映射序列相乘</a></li><li><a href="#%E6%A0%B9%E5%8D%87%E4%BD%99%E5%BC%A6%E6%BB%A4%E6%B3%A2">根升余弦滤波</a></li><li><a href="#%E4%B8%8A%E5%8F%98%E9%A2%91%E4%B9%98%E4%BB%A5%E8%BD%BD%E6%B3%A2">上变频（乘以载波）</a></li><li><a href="#%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93%E6%B7%BB%E5%8A%A0%E5%99%AA%E5%A3%B0">物理信道（添加噪声）</a></li><li><a href="#%E4%B8%8B%E5%8F%98%E9%A2%91%E4%B9%98%E4%BB%A5%E8%BD%BD%E6%B3%A2">下变频（乘以载波）</a></li><li><a href="#%E8%A7%A3%E6%89%A9%E5%8C%B9%E9%85%8D%E6%BB%A4%E6%B3%A2">解扩+匹配滤波</a></li><li><a href="#%E9%87%87%E6%A0%B7%E5%88%A4%E5%86%B3">采样+判决</a></li><li><a href="#%E7%94%BB%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E5%AF%B9%E6%AF%94">画出系统输入输出序列对比</a></li></ul></li><li><a href="#%E8%AF%AF%E7%A0%81%E7%8E%87%E6%9B%B2%E7%BA%BF%E4%BB%BF%E7%9C%9F">误码率曲线仿真</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E8%BE%93%E5%87%BA%E5%9B%BE%E5%83%8F">输出图像</a></li></ul></li><li><a href="#%E9%99%84%E5%BD%95%E4%BB%A3%E7%A0%81">附录代码</a><ul><li><a href="#%E4%BB%A3%E7%A0%811">代码1</a></li><li><a href="#%E4%BB%A3%E7%A0%812">代码2</a></li></ul></li></ul></li></ul><h2 id="系统实现">系统实现</h2><h3 id="系统框图">系统框图</h3><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_n8FxyoHoBx.png" alt></p><p><em><strong>唯一与BPSK不同的是，对极信号与扩频码进行相乘。</strong></em></p><h2 id="仿真代码">仿真代码</h2><h4 id="生成m序列">生成m序列</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成m序列</span></span><br><span class="line">data_len = <span class="number">10</span>;               <span class="comment">%数据长度 </span></span><br><span class="line">n = <span class="number">3</span>;                       <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>;                 <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p,<span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line">mg = <span class="built_in">repmat</span>(ms&#x27;,<span class="number">1</span>,data_len); <span class="comment">%重复m序列</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">121</span>);</span><br><span class="line">stairs(ms);title(<span class="string">&#x27;m序列时域波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">c = xcorr(ms,<span class="string">&#x27;normalized&#x27;</span>);</span><br><span class="line">subplot(<span class="number">122</span>);</span><br><span class="line"><span class="built_in">plot</span>(c);title(<span class="string">&#x27;m序列自相关函数&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_bWuqWQobM0.png" alt></p><h4 id="扩频码与映射序列相乘">扩频码与映射序列相乘</h4><ul><li><p>方法一：（方便理解）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data_len = <span class="number">10</span>;                       <span class="comment">%数据长度 </span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);      <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;             <span class="comment">%映射，0变-1</span></span><br><span class="line">s = rectpulse(data_bio,p);           <span class="comment">%序列重复p倍</span></span><br><span class="line">y = s.*mg;                           <span class="comment">%信号与扩频码相乘</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stairs(s);title(<span class="string">&#x27;扩频之前的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stairs(y);title(<span class="string">&#x27;扩频之后的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_QDPDA1532B.png" alt></p></li><li><p>方法二：（矩阵重组）</p><p>思路，生成的m序列为列向量<code>ms</code>，乘以之前的映射序列<code>data_bio</code>；生成一个数组，然后利用reshape函数重组数组，得到y（相乘之后的序列）；</p><blockquote><p><code>reshape</code>函数按<strong>列</strong>取元素</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">3</span>;          <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>;     <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p,<span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line">m_1 = ms.*data_bio;</span><br><span class="line">y1 = <span class="built_in">reshape</span>(m_1,[<span class="number">1</span>,p*data_len]);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stairs(s);title(<span class="string">&#x27;扩频之前的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stairs(y1);title(<span class="string">&#x27;扩频之后的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_lKMEXrNUiW.png" alt></p></li></ul><h4 id="根升余弦滤波">根升余弦滤波</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">osr = <span class="number">8</span>;                      <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(y,osr); <span class="comment">% 上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up,fir_rcos);            <span class="comment">%根升余弦滤波</span></span><br></pre></td></tr></table></figure><h4 id="上变频（乘以载波）">上变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">16000</span>;                   <span class="comment">% 采样率 </span></span><br><span class="line">fc = <span class="number">2000</span>;                    <span class="comment">% 载波频率</span></span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier.*data_bx;                    <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="物理信道（添加噪声）">物理信道（添加噪声）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_n = awgn(s_up,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);               <span class="comment">%添加噪声</span></span><br></pre></td></tr></table></figure><h4 id="下变频（乘以载波）">下变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_down = r_n .* carrier;                    <span class="comment">%下变频</span></span><br></pre></td></tr></table></figure><h4 id="解扩-匹配滤波">解扩+匹配滤波</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mg_up = upsample(<span class="built_in">fliplr</span>(ms&#x27;),osr);        <span class="comment">%先把序列进行反序</span></span><br><span class="line">fir_m = conv(mg_up,fir_rcos);             <span class="comment">%本地广义成形</span></span><br><span class="line"></span><br><span class="line">r_bx = conv(r_down,fir_m);                <span class="comment">%接收匹配滤波器</span></span><br></pre></td></tr></table></figure><h4 id="采样-判决">采样+判决</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">recv_data = (r_bx(<span class="number">97</span>:<span class="number">56</span>:<span class="keyword">end</span><span class="number">-104</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">%recv_data = (r_bx(osr*6+p*osr-osr+1:p*osr:end-osr*6-p*osr)) &gt; 0;</span></span><br></pre></td></tr></table></figure><p><em>本代码中滤波器的长度</em>*<code>fir_rcos</code>**为49，7位m序列，8倍上采样，即56个点；所以总延时为49-1+56=104，由于最后面是7个0，所以卷积处理时不会体现，即最开始为104-7=97，当然也可以取序列长度为1，寻找第一个最佳相关峰；一般地，如下：<em><code>recv_data = (r_bx(osr*</code></em><code>6+p</code><em><code>*osr-osr+1 : p*</code></em><code>osr : end-osr</code>*<code>*6-p*osr)) &gt; 0;</code></p><h4 id="画出系统输入输出序列对比">画出系统输入输出序列对比</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stem(data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&#x27;原始数据&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stem(recv_data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&#x27;输出序列&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_uao4jJQz08.png" alt></p><p><em>由于序列长度较少，所以理论上出错的可能性较小，即输出序列应该和输入序列完全一致，即可认为系统设计初步验证无误。</em></p><h2 id="误码率曲线仿真">误码率曲线仿真</h2><h4 id="代码">代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 误码率仿真（输出bpsk及bpsk-dsss）</span></span><br><span class="line">clc;clear all;close all;</span><br><span class="line">fs = <span class="number">16000</span>;                   <span class="comment">% 采样率 </span></span><br><span class="line">fc = <span class="number">2000</span>;                    <span class="comment">% 载波频率</span></span><br><span class="line"><span class="comment">%symbol_rate = 1000;           %符号速率</span></span><br><span class="line"><span class="comment">% Rb = 1000;                    % bit速率</span></span><br><span class="line">alfs = <span class="number">0.35</span>;                   <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">100000</span>;               <span class="comment">%数据长度</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);      <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;             <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% bpsk-dsss相关操作</span></span><br><span class="line"><span class="comment">% 生成m序列</span></span><br><span class="line">n = <span class="number">3</span>;          <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>;     <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p,<span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line">mg = <span class="built_in">repmat</span>(ms&#x27;,<span class="number">1</span>,data_len);  <span class="comment">%重复m序列</span></span><br><span class="line"></span><br><span class="line">s = rectpulse(data_bio,p);</span><br><span class="line">y = s.*mg;        <span class="comment">%信号与扩频码相乘</span></span><br><span class="line"></span><br><span class="line">osr = <span class="number">8</span>;                      <span class="comment">% 8倍上采样</span></span><br><span class="line">s_up_d = upsample(y,osr); <span class="comment">% 上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx_d = conv(s_up_d,fir_rcos);            <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line">carrier_d = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx_d)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_carrier_d = carrier_d.*data_bx_d;                    <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% bpsk(无扩频操作)</span></span><br><span class="line">s_up = upsample(data_bio,osr);   <span class="comment">%直接上采样</span></span><br><span class="line">data_bx = conv(s_up,fir_rcos);</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_carrier = carrier.*data_bx;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求误码率</span></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">errbit_d =<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">snr_d = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span>*<span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span>*<span class="built_in">log10</span>(osr); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">  <span class="comment">%snr_d(i) = ebn0 + 10*log10(2) - 10*log10(osr) - 10*log10(p);</span></span><br><span class="line">    snr_d(<span class="built_in">i</span>) = snr(<span class="built_in">i</span>) - <span class="number">10</span>*<span class="built_in">log10</span>(p);</span><br><span class="line">  <span class="comment">%物理信道（加性高斯白噪声）</span></span><br><span class="line">  r_noise = awgn(s_carrier,snr(<span class="built_in">i</span>),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">  r_noise_d = awgn(s_carrier_d,snr_d(<span class="built_in">i</span>),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%下变频（乘以载波）</span></span><br><span class="line">  r_signal_down = r_noise.*carrier;</span><br><span class="line">  r_signal_down_d = r_noise_d.*carrier_d;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%匹配滤波器 根升余弦滤波</span></span><br><span class="line">  r_bx = conv(r_signal_down,fir_rcos);</span><br><span class="line">  <span class="comment">%解扩加匹配滤波</span></span><br><span class="line">  mg_upsample = upsample(<span class="built_in">fliplr</span>(ms&#x27;),osr) ;</span><br><span class="line">  fir_m = conv(mg_upsample,fir_rcos);              <span class="comment">%本地广义成形</span></span><br><span class="line">  r_bx_d = conv(r_signal_down_d,fir_m);                <span class="comment">%接收匹配滤波器</span></span><br><span class="line">  <span class="comment">%判决</span></span><br><span class="line">  recv_data = (r_bx(osr*<span class="number">6</span>+<span class="number">1</span>:osr:<span class="keyword">end</span>-osr*<span class="number">6</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">  errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(recv_data-data))/data_len;</span><br><span class="line">  recv_data_d = (r_bx_d(<span class="number">97</span>:<span class="number">56</span>:<span class="keyword">end</span><span class="number">-96</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">  errbit_d(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(recv_data_d-data))/data_len;</span><br><span class="line">  <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">ber_theory = <span class="number">0.5</span>*<span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>,ebn0/<span class="number">10</span>)));<span class="comment">%理论误码率</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(ebn0,ber_theory,<span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">semilogy(ebn0,errbit,<span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line"></span><br><span class="line">semilogy(ebn0,errbit_d,<span class="string">&#x27;-xg&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line">xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>);ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;BPSK-DSSS误码率曲线图&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>,<span class="string">&#x27;bpsk仿真误码率曲线&#x27;</span>,<span class="string">&#x27;bpsk-dsss仿真误码率&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="输出图像">输出图像</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_yRtvMRDa5a.png" alt></p><h2 id="附录代码">附录代码</h2><h3 id="代码1">代码1</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%:本程序用于实现QPSK直接扩频系统</span></span><br><span class="line"><span class="comment">%========================基本参数===========================%</span></span><br><span class="line">Rs = <span class="number">100e6</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%上采样倍数</span></span><br><span class="line">fs = sps * Rs; <span class="comment">%采样率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1e3</span>; <span class="comment">%数据长度</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">%调制阶数</span></span><br><span class="line">offset = <span class="built_in">pi</span> / <span class="number">4</span>; <span class="comment">%偏移量</span></span><br><span class="line">rng(<span class="number">9</span>);</span><br><span class="line">EbN0 = <span class="number">0</span>:<span class="number">2</span>:<span class="number">10</span>;</span><br><span class="line">snr = EbN0 - <span class="number">10</span> * <span class="built_in">log10</span>(sps) - <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span> ^ n) + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">% snr = 100;</span></span><br><span class="line">ber = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(snr));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(snr)</span><br><span class="line">    bit_error = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bit_error &gt; <span class="number">100</span> &amp;&amp; k * data_len &gt; <span class="number">1e4</span>)</span><br><span class="line">        <span class="comment">%========================调制==============================%</span></span><br><span class="line">        bit_send = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%bit数据</span></span><br><span class="line">        data = bit2int(bit_send.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">        <span class="comment">% data = randi([0 M - 1], 1, data_len); %随机数据</span></span><br><span class="line">        data_mod = pskmod(data, M, offset); <span class="comment">%PSK调制</span></span><br><span class="line">        <span class="comment">% scatterplot(data_mod); title(&#x27;QPSK-Constellation Diagram&#x27;);</span></span><br><span class="line">        <span class="comment">%========================扩频==============================%</span></span><br><span class="line">        n = <span class="number">10</span>; <span class="comment">%m序列级数</span></span><br><span class="line">        C = <span class="number">435</span>; <span class="comment">%八进制反馈系数</span></span><br><span class="line">        tap_set = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">%二进制</span></span><br><span class="line">        m_sequence = <span class="number">1</span> - <span class="number">2</span> * [m_serial_generator(tap_set) <span class="number">1</span>]; <span class="comment">%生成扩频序列</span></span><br><span class="line">        data_matrix = (m_sequence.&#x27;) .* data_mod; <span class="comment">%扩频矩阵</span></span><br><span class="line">        data_dsss = <span class="built_in">reshape</span>(data_matrix, <span class="number">1</span>, []);</span><br><span class="line">        <span class="comment">%=======================成形滤波器==========================%</span></span><br><span class="line">        Fir_rcos = rcosdesign(alfs, <span class="number">8</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">        data_dsss_up = upsample(data_dsss, sps);</span><br><span class="line">        data_dsss_shape = conv(data_dsss_up, Fir_rcos);</span><br><span class="line">        <span class="comment">%=========================噪声=============================%</span></span><br><span class="line">        data_awgn = awgn(data_dsss_shape, snr(<span class="built_in">i</span>), <span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">        <span class="comment">%=======================解扩+匹配===========================%</span></span><br><span class="line">        m_sequence_up = upsample(<span class="built_in">fliplr</span>(m_sequence), sps);</span><br><span class="line">        Fir_match = conv(m_sequence_up, Fir_rcos); <span class="comment">%本地广义匹配滤波器</span></span><br><span class="line">        data_matched = conv(data_awgn, Fir_match); <span class="comment">%解扩+匹配</span></span><br><span class="line">        <span class="comment">%========================解调===============================%</span></span><br><span class="line">        data_matched_down = data_matched(<span class="number">4125</span>:sps * <span class="number">1024</span>:<span class="keyword">end</span> - <span class="number">4124</span>);</span><br><span class="line">        data_demod = pskdemod(data_matched_down, M, offset);</span><br><span class="line">        bit_recv = int2bit(data_demod.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">        bit_error = bit_error + biterr(bit_send, bit_recv);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;Bit Error = &#x27;</span>, num2str(bit_error)]);</span><br><span class="line">        k = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ber(<span class="built_in">i</span>) = bit_error / (k * data_len);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;BER = &#x27;</span>, num2str(ber(<span class="built_in">i</span>))]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%==========================画图=============================%</span></span><br><span class="line">ber_theory = berawgn(EbN0.&#x27;, <span class="string">&quot;psk&quot;</span>, M, <span class="string">&quot;nondiff&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(EbN0, ber, <span class="string">&#x27;-*g&#x27;</span>); grid on; <span class="built_in">hold</span> on;</span><br><span class="line">semilogy(EbN0, ber_theory, <span class="string">&#x27;-r&#x27;</span>); grid on; <span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%===================扩频码生成函数===========================%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m]</span> = <span class="title">m_serial_generator</span><span class="params">(tap_set)</span></span></span><br><span class="line">    L = <span class="number">2</span> ^ (<span class="built_in">length</span>(tap_set) - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    x = [<span class="built_in">zeros</span>(<span class="number">1</span>, (<span class="built_in">length</span>(tap_set) - <span class="number">2</span>)) <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:L</span><br><span class="line">        m(<span class="built_in">i</span>) = x(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(tap_set) - <span class="number">1</span></span><br><span class="line">            sum_vector(<span class="built_in">j</span>) = tap_set(<span class="built_in">j</span> + <span class="number">1</span>) * x(<span class="built_in">j</span>); <span class="comment">%#ok&lt;*AGROW&gt;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        sum_x = <span class="built_in">mod</span>(sum(sum_vector), <span class="number">2</span>);</span><br><span class="line">        x = [sum_x x(<span class="number">1</span>:<span class="keyword">end</span> - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="代码2">代码2</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%:本程序用于实现QPSK直接扩频系统</span></span><br><span class="line"><span class="comment">%========================基本参数===========================%</span></span><br><span class="line">Rs = <span class="number">100e6</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%上采样倍数</span></span><br><span class="line">fs = sps * Rs; <span class="comment">%采样率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1e4</span>; <span class="comment">%数据长度</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">%调制阶数</span></span><br><span class="line">offset = <span class="built_in">pi</span> / <span class="number">4</span>; <span class="comment">%偏移量</span></span><br><span class="line">rng(<span class="number">9</span>);</span><br><span class="line"><span class="comment">%========================调制==============================%</span></span><br><span class="line">bit_send = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%bit数据</span></span><br><span class="line"><span class="comment">% bit_send = repmat([0 1],[1 data_len/2]);</span></span><br><span class="line">data = bit2int(bit_send.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line"><span class="comment">% data = randi([0 M - 1], 1, data_len); %随机数据</span></span><br><span class="line">data_mod = pskmod(data, M, offset); <span class="comment">%PSK调制</span></span><br><span class="line">scatterplot(data_mod); title(<span class="string">&#x27;QPSK-Constellation Diagram&#x27;</span>);</span><br><span class="line"><span class="comment">%========================扩频==============================%</span></span><br><span class="line">n = <span class="number">10</span>; <span class="comment">%m序列级数</span></span><br><span class="line">C = <span class="number">435</span>; <span class="comment">%八进制反馈系数</span></span><br><span class="line">tap_set = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">%二进制</span></span><br><span class="line"><span class="comment">% m_sequence = [idinput(2^n-1,&#x27;prbs&#x27;).&#x27; 1];</span></span><br><span class="line">m_sequence = <span class="number">1</span> - <span class="number">2</span> * [m_serial_generator(tap_set) <span class="number">0</span>]; <span class="comment">%生成扩频序列</span></span><br><span class="line">data_matrix = (m_sequence.&#x27;) .* data_mod; <span class="comment">%扩频矩阵</span></span><br><span class="line">data_dsss = <span class="built_in">reshape</span>(data_matrix, <span class="number">1</span>, []);</span><br><span class="line"><span class="comment">% data_mod_repmat = rectpulse(data_mod,1024);</span></span><br><span class="line"><span class="comment">% mg = repmat(m_sequence,[1,length(data_mod)]);</span></span><br><span class="line"><span class="comment">% data_dsss = data_mod_repmat.*mg;</span></span><br><span class="line"><span class="comment">%=======================成形滤波器==========================%</span></span><br><span class="line">Fir_rcos = rcosdesign(alfs, <span class="number">8</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_qpsk = conv(upsample(data_mod, sps), Fir_rcos);</span><br><span class="line">data_dsss_up = upsample(data_dsss, sps);</span><br><span class="line">data_dsss_shape = conv(data_dsss_up, Fir_rcos);</span><br><span class="line"><span class="comment">%=========================噪声=============================%</span></span><br><span class="line">snr = <span class="number">10</span>;</span><br><span class="line">data_qpsk_awgn = awgn(data_qpsk, snr, <span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">data_awgn = awgn(data_dsss_shape, snr, <span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line"><span class="comment">%=======================解扩+匹配===========================%</span></span><br><span class="line">data_qpsk_matched = conv(data_qpsk_awgn, Fir_rcos); <span class="comment">%匹配滤波</span></span><br><span class="line">m_sequence_up = upsample(<span class="built_in">fliplr</span>(m_sequence), sps);</span><br><span class="line">Fir_match = conv(m_sequence_up, Fir_rcos); <span class="comment">%本地广义匹配滤波器</span></span><br><span class="line">data_matched = conv(data_awgn, Fir_match); <span class="comment">%解扩+匹配</span></span><br><span class="line"><span class="comment">%========================解调===============================%</span></span><br><span class="line">data_qpsk_matched_down = data_qpsk_matched(<span class="number">33</span>:sps:<span class="keyword">end</span> - <span class="number">32</span>);</span><br><span class="line">scatterplot(data_qpsk_matched_down); title(<span class="string">&#x27;SNR=10dB QPSK无扩频&#x27;</span>);</span><br><span class="line">data_matched_down = data_matched(<span class="number">4125</span>:sps * <span class="number">1024</span>:<span class="keyword">end</span> - <span class="number">4124</span>);</span><br><span class="line">scatterplot(data_matched_down); title(<span class="string">&#x27;SNR=10dB QPSK有扩频&#x27;</span>);</span><br><span class="line">data_qpsk_demod = pskdemod(data_qpsk_matched_down, M, offset);</span><br><span class="line">bit_qpsk = int2bit(data_qpsk_demod.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">bit_error = biterr(bit_send, bit_qpsk);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK Bit Error = &#x27;</span>, num2str(bit_error)]);</span><br><span class="line">ber = bit_error / data_len;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK BER = &#x27;</span>, num2str(ber)]);</span><br><span class="line">data_demod = pskdemod(data_matched_down, M, offset);</span><br><span class="line">bit_recv = int2bit(data_demod.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">bit_error = biterr(bit_send, bit_recv);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK-DSSS Bit Error = &#x27;</span>, num2str(bit_error)]);</span><br><span class="line">ber = bit_error / data_len;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK-DSSS BER = &#x27;</span>, num2str(ber)]);</span><br><span class="line"><span class="comment">%========================频谱分析===========================%</span></span><br><span class="line">fft_n = <span class="number">16384</span>; <span class="comment">%FFT点数</span></span><br><span class="line">f_1 = (-fft_n / <span class="number">2</span>:fft_n / <span class="number">2</span> - <span class="number">1</span>) ./ fs;</span><br><span class="line">f_2 = (-fft_n / <span class="number">2</span>:fft_n / <span class="number">2</span> - <span class="number">1</span>) * <span class="number">1024</span> ./ fs;</span><br><span class="line">data_qpsk_awgn_fft = fft(data_qpsk_awgn, fft_n);</span><br><span class="line">data_awgn_fft = fft(data_awgn, fft_n);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(f_1, <span class="number">20</span> * <span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(data_qpsk_awgn_fft)) / fft_n), <span class="string">&#x27;r&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(f_2, <span class="number">20</span> * <span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(data_awgn_fft)) / fft_n), <span class="string">&#x27;b&#x27;</span>); grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>); ylabel(<span class="string">&#x27;Power (dB)&#x27;</span>); <span class="built_in">legend</span>(<span class="string">&#x27;QPSK&#x27;</span>, <span class="string">&#x27;QPSK-DSSS&#x27;</span>);</span><br><span class="line"><span class="comment">%===================扩频码生成函数===========================%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m]</span> = <span class="title">m_serial_generator</span><span class="params">(tap_set)</span></span></span><br><span class="line">    L = <span class="number">2</span> ^ (<span class="built_in">length</span>(tap_set) - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    x = [<span class="built_in">zeros</span>(<span class="number">1</span>, (<span class="built_in">length</span>(tap_set) - <span class="number">2</span>)) <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:L</span><br><span class="line">        m(<span class="built_in">i</span>) = x(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(tap_set) - <span class="number">1</span></span><br><span class="line">            sum_vector(<span class="built_in">j</span>) = tap_set(<span class="built_in">j</span> + <span class="number">1</span>) * x(<span class="built_in">j</span>); <span class="comment">%#ok&lt;*AGROW&gt;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        sum_x = <span class="built_in">mod</span>(sum(sum_vector), <span class="number">2</span>);</span><br><span class="line">        x = [sum_x x(<span class="number">1</span>:<span class="keyword">end</span> - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BPSK收发系统</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>BPSK收发系统</h1><h2 id="理论部分">理论部分</h2><h3 id="数字调制信号的表示">数字调制信号的表示</h3><h4 id="调制方式的种类">调制方式的种类</h4><p><strong>有记忆调制</strong></p><blockquote><p>📌<strong>无记忆调制</strong></p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/figure1.png" alt="figure1"></p><p>在无记忆调制方式中，二进制序列分成每段长度为$k$的序列，再将每段序列映射成$s_m(t)$ ，而不考虑先前发送的信号如何。</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_Wg3DHHwqwb.png" alt="figure"></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_MCixJMqzN4.png" alt="figure"></p><h3 id="无记忆调制方式——以BPSK为例">无记忆调制方式——以BPSK为例</h3><h4 id="MPSK表达式">MPSK表达式</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_o0xXPboPKM.png" alt="figure"></p><h4 id="BPSK表达式">BPSK表达式</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_rQ-WCXIHTJ.png" alt="figure"></p><p><strong>图形简述过程如下：</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_MgkwiCZF2e.png" alt="figure"></p><h4 id="PSK和QAM">PSK和QAM</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_E8g0Q6xpuJ.png" alt="figure"></p><ul><li><strong>QAM 和 PSK 的区别</strong></li></ul><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_kHjCVSxY3c.png" alt="figure"></p><p><strong>从左边的星座图可以很显然看出，QAM 的幅度是不恒定的，而 PSK 的幅度是恒定的，即 PSK 只会改变信号的相位，而 QAM 不仅改变信号的相位，还改变信号的幅度。</strong></p><h4 id="根升余弦成型">根升余弦成型</h4><ul><li><p><strong>带限信道</strong></p><p>我们的所有通信信道都一定不是无限带宽的，对于带限信道，我们可以将其表征为等效<strong>低通频率响应</strong> $C(f)$。根据以前通信原理相关知识，我们可以知道信号通过带限滤波器后，其非理想信道频率响应特性 $C(f)$ 会引起幅度和延时失真，在接收端特定时间采样时，不同信号间产生重叠，因此出现符号间干扰。这个时候，我们就要从想办法克服码间串扰 $ISI$。</p></li><li><p><strong>奈奎斯特准则</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_gcm_CPfwZZ.png" alt="figure"></p><ul><li>情况1<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_gKEEAwW1yw.png" alt="figure"></li><li>情况2<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_sVRceAqpP4.png" alt="figure"></li><li>情况3<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_GEynPZR-id.png" alt="figure"></li><li>拓展<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_8JjCSvXjs2.png" alt="figure"></li></ul></li><li><p><strong>升余弦</strong></p></li><li><p><strong>根升余弦滤波器</strong></p></li></ul><h4 id="AWGN-信道的最佳接收机——理论部分">AWGN 信道的最佳接收机——理论部分</h4><ul><li>AWGN信道</li><li>最佳判决的定义</li><li></li></ul><h2 id="MATLAB仿真设计">MATLAB仿真设计</h2><h3 id="系统实现">系统实现</h3><h4 id="收发系统框图">收发系统框图</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image.png" alt="figure"></p><h2 id="MATLAB代码实现">MATLAB代码实现</h2><h3 id="系统分模块实现">系统分模块实现</h3><h4 id="发射序列">发射序列</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_len = <span class="number">10</span>;                            <span class="comment">%数据长度</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);            <span class="comment">%发射随机1，0序列</span></span><br><span class="line"><span class="comment">%data = round(rand(1,data_len));</span></span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line"><span class="comment">%data = zeros(1,data_len);</span></span><br></pre></td></tr></table></figure><h4 id="映射-0-1">映射(0 -&gt; -1)</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stem(data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&quot;发送端数据&quot;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stairs(s);title(<span class="string">&#x27;映射之后序列&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_Iq5ZgKPrM0.png" alt="figure"></p><h4 id="成型滤波">成型滤波</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alfs = <span class="number">0.35</span>;                                   <span class="comment">% 滚降系数</span></span><br><span class="line">osr = <span class="number">8</span>;                                       <span class="comment">% 上采样倍数</span></span><br><span class="line">data_up = upsample(s,osr);                     <span class="comment">%上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);      <span class="comment">%根升余弦滤波器</span></span><br><span class="line">N = <span class="built_in">length</span>(fir_rcos);                          <span class="comment">%滤波器长度</span></span><br><span class="line">data_bx = conv(fir_rcos,data_up);              <span class="comment">%通过滤波器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>上采样：</strong><code>upsample(x,n)</code>函数；在序列x的每个数后插入n-1个0</p><p><em>上采样又称信号插值，即在原序列_x_(n)的两点之间插入L个0，等效于其在频域上做了频谱压缩。数据内插补零后，其贡献为零，因此傅里叶频谱形态只是更加细致。</em></p></li><li><p><strong>根升余弦函数：</strong><code>rcosdesign(alfs,span,sps,shape)</code>；</p><ul><li><strong><code>alfs</code><strong>为滚降系数；</strong><code>span</code><strong>为表示截断的符号范围；</strong><code>sps</code><strong>为单个符号采样的个数(数值上等于</strong><code>osr</code></strong>，即上采样倍数)；<strong><code>shape</code><strong>处可加上’</strong><code>normal'</code></strong>，可加上’**<code>sqrt'，</code><strong>不加默认</strong><code>'sqrt'</code>*</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(fir_rcos);title(<span class="string">&#x27;根升余弦时域波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>(data_bx);title(<span class="string">&#x27;成形之后的波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_IfYgWZKsXC.png" alt="figure"></p><h4 id="上变频（乘以载波）">上变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">16000</span>;                                       <span class="comment">% 采样率 </span></span><br><span class="line">fc = <span class="number">2000</span>;                                        <span class="comment">% 载波频率</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*t);                      <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx .* carrier;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(carrier);title(<span class="string">&#x27;载波时域波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>(s_up);title(<span class="string">&#x27;上变频之后的波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_h-sNv-ENfj.png" alt="figure"></p><h4 id="物理信道（添加噪声）">物理信道（添加噪声）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_n = awgn(s_up,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>awgn</code><em>函数：</em><code>y= awgn(x,snr,'measured')</code><em>将白高斯噪声添加到向量信号x中。标量snr指定了每一个采样点信号与噪声的比率，单位为dB。如果x是复数的，awgn将会添加复数噪声。</em><code>'measured'</code><em>在添加噪声之前测量了x的能量。</em></p><h4 id="下变频（乘以载波）">下变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_down = r_n .* carrier;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(r_n);title(<span class="string">&#x27;添加高斯噪声波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>(r_down);title(<span class="string">&#x27;下变频之后波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_6dAAejPV3r.png" alt="figure"></p><h4 id="匹配滤波器接收">匹配滤波器接收</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r_bx = conv(fir_rcos,r_down);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">plot</span>(r_bx);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_HVHmC85t0p.png" alt="figure"></p><h4 id="采样-判决（最佳接收）">采样/判决（最佳接收）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r_data = (r_bx(N:osr:<span class="keyword">end</span>-N+<span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">%recv_data = (r_bx(osr*6+1:osr:end-osr*6)) &gt; 0;</span></span><br><span class="line"><span class="comment">%recv_data = (r_bx(osr*6+1:osr:osr*6+1+osr*(data_len-1))) &gt; 0;</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">6</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stem(data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&#x27;发送端数据&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stem(r_data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&quot;接受端数据&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_YwUfNj9aIZ.png" alt="figure"></p><p><em>由于发送端数据为10，长度较小，只是为了测试整个程序运行正常，因此最后采样判决输出结果应该基本完全一致，用这个思路可以初步检验代码是否正确。</em></p><h4 id="代码">代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk收发系统</span></span><br><span class="line">clc;clear all;close all;</span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">fs = <span class="number">16000</span>;            <span class="comment">% 采样率 </span></span><br><span class="line">Rb = <span class="number">1000</span>;             <span class="comment">% bit速率</span></span><br><span class="line">fc = <span class="number">2000</span>;             <span class="comment">% 载波频率</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>;    <span class="comment">%符号速率</span></span><br><span class="line">alfs = <span class="number">0.6</span>;            <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10</span>;        <span class="comment">%数据长度</span></span><br><span class="line"><span class="comment">% osr = fs/Rb;           % 过采样倍数 = 采样率 / 符号速率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 基带信号产生（发射序列）</span></span><br><span class="line"><span class="comment">%data = round(rand(1,data_len));</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len); </span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 映射(0变-1）</span></span><br><span class="line">osr = <span class="number">8</span>;</span><br><span class="line">s = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">data_up = upsample(s,osr);                        <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 成型滤波器</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);</span><br><span class="line">N = <span class="built_in">length</span>(fir_rcos);                             <span class="comment">%滤波器长度</span></span><br><span class="line">data_bx = conv(fir_rcos,data_up);                 <span class="comment">%通过滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 上变频（乘以载波）</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*t);                      <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx .* carrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 物理信道（添加噪声）</span></span><br><span class="line">r_n = awgn(s_up,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 下变频（乘以载波）</span></span><br><span class="line">r_down = r_n .* carrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 匹配滤波器</span></span><br><span class="line">r_bx = conv(fir_rcos,r_down);</span><br><span class="line"><span class="comment">%% 采样判决（解调）</span></span><br><span class="line">r_data = (r_bx(N:osr:<span class="keyword">end</span>-N+<span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">% recv_data = (r_bx(osr*6+1:osr:osr*6+1+osr*(data_len-1))) &gt; 0;</span></span><br><span class="line"><span class="comment">%r_data = (r_bx(97:osr:end-97)) &gt; 0;</span></span><br><span class="line"><span class="comment">%r_data = (r_bx(N-1:osr:N-1+osr*(data_len-1))) &gt; 0;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="误码率分析">误码率分析</h2><ul><li><p><strong>整体代码</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%仿真作业——-----——输出误码率图像</span></span><br><span class="line">clc;clear all;close all;</span><br><span class="line">fs = <span class="number">16000</span>;                   <span class="comment">% 采样率 </span></span><br><span class="line"><span class="comment">% Rb = 1000;                    % bit速率</span></span><br><span class="line">fc = <span class="number">2000</span>;                    <span class="comment">% 载波频率</span></span><br><span class="line"><span class="comment">% symbol_rate = 1000;           %符号速率</span></span><br><span class="line">alfs = <span class="number">0.35</span>;                   <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1000000</span>;               <span class="comment">%数据长度</span></span><br><span class="line"><span class="comment">% osr = fs/Rb;                  % 过采样倍数 = 采样率 / 符号速率</span></span><br><span class="line">osr = <span class="number">8</span>;</span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);      <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;             <span class="comment">%映射，0变-1</span></span><br><span class="line">data_up = upsample(data_bio,osr); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(data_up,fir_rcos); <span class="comment">%根升余弦滤波</span></span><br><span class="line"><span class="comment">% figure(1);</span></span><br><span class="line"><span class="comment">% plot(data_bx);title(&#x27;经过成型滤波之后的图像&#x27;);</span></span><br><span class="line"></span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier.*data_bx;                    <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"><span class="comment">% figure(2);</span></span><br><span class="line"><span class="comment">% plot(s_carrier);title(&#x27;调制波形&#x27;);</span></span><br><span class="line"></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span>*<span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span>*<span class="built_in">log10</span>(osr); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%物理信道（加性高斯白噪声）</span></span><br><span class="line">  r_noise = awgn(s_up,snr(<span class="built_in">i</span>),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%下变频（乘以载波）</span></span><br><span class="line">  r__down = r_noise.*carrier;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%匹配滤波器</span></span><br><span class="line">  <span class="comment">%根升余弦滤波</span></span><br><span class="line">  r_bx = conv(r__down,fir_rcos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">%判决</span></span><br><span class="line">  recv_data = (r_bx(osr*<span class="number">6</span>+<span class="number">1</span>:osr:<span class="keyword">end</span>-osr*<span class="number">6</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">  errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(recv_data-data))/data_len;</span><br><span class="line">  <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">ber_theory = <span class="number">0.5</span>*<span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>,ebn0/<span class="number">10</span>)));<span class="comment">%理论误码率</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(ebn0,ber_theory,<span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">semilogy(ebn0,errbit,<span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line">xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>);ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>,<span class="string">&#x27;仿真误码率曲线&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_s1YQE9lLTB.png" alt="figure"></p></li><li><p><strong>仿真过程中的部分要求</strong></p><p><strong>观测根升余弦成型信号的频谱和方波成型信号的频谱形状</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all;</span><br><span class="line">fs = <span class="number">16000</span>;            <span class="comment">% 采样率 </span></span><br><span class="line"><span class="comment">% Rb = 1000;             % bit速率</span></span><br><span class="line">fc = <span class="number">2000</span>;             <span class="comment">% 载波频率</span></span><br><span class="line"><span class="comment">% symbol_rate = 1000;    %符号速率</span></span><br><span class="line">alfs = <span class="number">0.35</span>;            <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">100</span>;        <span class="comment">%数据长度</span></span><br><span class="line"><span class="comment">% osr = fs/Rb;           % 过采样倍数 = 采样率 / 符号速率</span></span><br><span class="line">osr = <span class="number">8</span>;</span><br><span class="line">data = <span class="built_in">round</span>(<span class="built_in">rand</span>(<span class="number">1</span>,data_len));</span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line"></span><br><span class="line">s = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">s_up = upsample(s,osr);                        <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%成型滤波器——---根升余弦</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);</span><br><span class="line">N = <span class="built_in">length</span>(fir_rcos);                             <span class="comment">%滤波器长度</span></span><br><span class="line">data_bx = conv(fir_rcos,s_up);                 <span class="comment">%通过滤波器</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(data_bx);title(<span class="string">&#x27;时域波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">N1 = <span class="number">1024</span>;</span><br><span class="line">y = fft(data_bx,N1);</span><br><span class="line">x = (<span class="number">1</span>/N1).*(<span class="number">0</span>:<span class="built_in">length</span>(y)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">abs</span>(y));title(<span class="string">&#x27;频域波形&#x27;</span>);       <span class="comment">%画坐标轴理解有点不到位</span></span><br><span class="line"><span class="comment">%成型滤波器-----方波</span></span><br><span class="line">data_rect = rectpulse(s,osr);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stairs(data_rect);title(<span class="string">&#x27;时域波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">N2 = <span class="number">1024</span>;</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">y1 = fft(data_rect,N2);</span><br><span class="line">x1 = (<span class="number">1</span>/N2).*(<span class="number">0</span>:<span class="built_in">length</span>(y1)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x1,<span class="built_in">abs</span>(y1));title(<span class="string">&#x27;频域波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_P2o5QU1rJk.png" alt="figure"></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_nE2anoTF2_.png" alt="figure"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDS原理及简单应用</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>DDS原理学习</h1><h2 id="何为DDS">何为DDS</h2><h3 id="DDS定义与优点">DDS定义与优点</h3><blockquote><p><strong>DDS: <em><strong><strong>Direct digital synthesis</strong></strong></em> 直接数字频率合成，可以用来合成周期性的信号序列。</strong></p></blockquote><blockquote><p><strong>优点：频率转换时间短；频率分辨率极高；相位变化连续；输出波形灵活</strong></p></blockquote><h3 id="DDS原理">DDS原理</h3><blockquote><p>在参考时钟的驱动下，相位累加器对频率控制字进行线性累加，得到的相位码对波形存储器寻址，使之输出相应的幅度码，经过模数转换器得到相应的阶梯波。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_IWHYjLWaOk.png" alt></p><blockquote><p>也就是，我们事先将想要的波形所对应的数值按照一定的要求存储于ROM 中，然后在硬件工作的时候，对 ROM 进行寻址，得到相应的波形数据，再通过 D/A 输出，以此获得我们目标波形。</p></blockquote><h4 id="角度与波形">角度与波形</h4><blockquote><p>从 DDS 的原理可以看出，DDS 可以产生任意周期性的波形，比如 sine，cosine，三角波等。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_qPrM5dDBAV.png" alt></p><blockquote><p>以 sine 为例，可以看出来，波形电平最大值等于圆的半径，产生的波形的频率等价于扫过 2π 角度的速度。</p></blockquote><h4 id="频率控制字">频率控制字</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_AM9mHRx6cW.png" alt></p><blockquote><p>从上图可以看出来，输出信号的频率与扫描的角速度是有关系的。</p></blockquote><p>$$<br>频率=\frac{2π}{角速度}<br>$$</p><blockquote><p>但由于波形数据是存储在 ROM 中的，这就意味着其相位的步进是离散的，这时候需要引入频率控制字的概念。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_Hc8tgdOJIG.png" alt></p><ul><li><p><strong>举例</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_TC5wozAp-N.png" alt></p><ul><li><strong>频率控制字与输出信号频率之间的关系</strong><blockquote><p>当前你在 ROM 中存储了 1024 个 sine 波形数据，而你要读取哪个波形数据是完全取决于相位累加器的输出的，比如当前相位累加器输出是 10，则你会读取 ROM 中地址为 10 的数据。相位累加器的步进值又取决于频率控制字 <em>M</em>，如果 <em>M</em> = 1，则系统会按照顺序读取所有 ROM 中的数据，那如果频率控制字 <em>M</em> = 10，则系统会在 ROM 中每 10 个数据读取一次，可想而知，波形没那么好看了（可能会产生锯齿），但是由于扫描一周的时间变短了，所以对应频率更高。</p></blockquote></li></ul></li></ul><h2 id="硬件实现">硬件实现</h2><h4 id="思考">思考</h4><ol><li><p>求 $131.072MHz $系统时钟，要求精度为 $1kHz$ 时的 $N$。输出精度相当于$M = 1$$ $时的输出频率。</p><p>答：$N = 17$，意味着 $ROM$ 核的地址有 $17bit$，因此深度为$2 ^ {17} = 131, 072$。若要求精度为 $1Hz$，深度就会更大。</p></li><li><p>如果我想获得更大的可调频率范围，那频率控制字 $M$ 有可能为小数吗？或者是当前 $ROM $的寻址范围有限，那我有可能产生比取 $M = 1$还低的输出信号频率吗？如果可以，那频率控制字$ M = 0.5, M = 0.25$ 在$ Verilog$ 中该怎么实现呢？</p><p>答：可以通过对相位累加器的输出进行截断来实现。</p></li></ol><h4 id="地址截断">地址截断</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_rw72jKJDEb.png" alt></p><blockquote><p>一般舍去较低为位数，只取 N 的高 A 位（如高 10 位或 14 位）做为存储器地址，使得相位的低位被截断（即相位截尾）。可以参考如下代码。</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">reg</span>    [<span class="number">19</span>:<span class="number">0</span>] addr = <span class="number">20&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">parameter</span> add_M = <span class="number">20&#x27;d1</span>;</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (rst_n == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= addr[<span class="number">19</span>:<span class="number">0</span>] + add_M;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">sine_rom sin_rom_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.addra</span>(addr[<span class="number">19</span>:<span class="number">10</span>]),  <span class="comment">// input wire [9 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(dds_out)  <span class="comment">// output wire [13 : 0] douta</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="具体实现步骤">具体实现步骤</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_9Nanu4Ox4o.png" alt></p><h1>仿真设计实现</h1><h2 id="MATLAB">MATLAB</h2><h3 id="生成coe文件">生成coe文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clear;clc;close all;</span><br><span class="line">t = <span class="number">0</span>:<span class="number">1</span>/<span class="number">2</span>^<span class="number">10</span>:<span class="number">1</span><span class="number">-1</span>/<span class="number">2</span>^<span class="number">10</span>;</span><br><span class="line">sin_1 = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t);</span><br><span class="line">sin_14bit = <span class="built_in">round</span>((<span class="number">2</span>^<span class="number">13</span><span class="number">-1</span>)*sin_1/<span class="built_in">max</span>(sin_1));</span><br><span class="line">fid = fopen(<span class="string">&#x27;sin_14bit.coe&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">%创建COE文件</span></span><br><span class="line">fprintf(fid, <span class="string">&#x27;memory_initialization_radix=10;\n&#x27;</span>);</span><br><span class="line">fprintf(fid, <span class="string">&#x27;memory_initialization_vector=\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(sin_14bit)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">length</span>(sin_14bit))</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d\n&#x27;</span>,sin_14bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,sin_14bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% fprintf(fid,&#x27;%d\n&#x27;,sin_14bit);</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(sin_14bit);</span><br></pre></td></tr></table></figure><blockquote><p>上述代码，$N = 1024$，正弦函数，量化时乘以$2^{13}-1$，其原因在于量化$14Bit$，<strong>有符号数的范围</strong>为$-2^{13}$~$2^{13}-1$;正数少一个，所以只能量化到$2^{13}-1$</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_VJOrqUryEJ.png" alt></p><h2 id="Vivado">Vivado</h2><h3 id="仿真中遇到的问题及注意事项">仿真中遇到的问题及注意事项</h3><h3 id="无地址截断仿真">无地址截断仿真</h3><ul><li><strong>Design文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> dds_work(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">13</span>:<span class="number">0</span>] dds_out</span><br><span class="line">    );</span><br><span class="line">   <span class="keyword">reg</span>    [<span class="number">9</span>:<span class="number">0</span>] addr = <span class="number">10&#x27;d0</span>;</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">    addr &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    addr &lt;= addr + <span class="number">10&#x27;d1</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line">sin_rom sin_rom_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.addra</span>(addr),  <span class="comment">// input wire [9 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(dds_out)  <span class="comment">// output wire [13 : 0] douta</span></span><br><span class="line">);   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><strong>testbench文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb_sinrom(</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">reg</span>        clk;</span><br><span class="line">  <span class="keyword">reg</span>        rst_n;</span><br><span class="line">  <span class="keyword">wire</span>  [<span class="number">13</span>:<span class="number">0</span>]  dds_out;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;    <span class="comment">//50MHz clock</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    #<span class="number">200</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  dds_work dds_work_m (</span><br><span class="line">    <span class="variable">.clk</span>(clk), </span><br><span class="line">    <span class="variable">.rst_n</span>(rst_n), </span><br><span class="line">    <span class="variable">.dds_out</span>(dds_out)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><p>仿真波形</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_phE8r_rdR6.png" alt></p><blockquote><p>$T = 20.66us$（稍有误差，手拖动的）<br>$$<br>f_o={M×f_{clk} \over 2^N}</p></blockquote><p>$$<br>即$fo={1×50×10^6 \over 2^{10}}$; 所以$T = $$1/f_o$$=1024/50us$=$20.48us$</p><p>故而可以认为输出正确</p></li></ul></li></ul><h3 id="有地址截断仿真">有地址截断仿真</h3><ul><li><strong>Design文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dds_top(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">13</span>:<span class="number">0</span>] dds_out</span><br><span class="line">    );</span><br><span class="line">   <span class="keyword">reg</span>    [<span class="number">19</span>:<span class="number">0</span>] addr = <span class="number">20&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">parameter</span> add_M = <span class="number">20&#x27;d1</span>;</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (rst_n == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= addr[<span class="number">19</span>:<span class="number">0</span>] + add_M;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line">sine_rom sin_rom_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.addra</span>(addr[<span class="number">19</span>:<span class="number">10</span>]),  <span class="comment">// input wire [9 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(dds_out)  <span class="comment">// output wire [13 : 0] douta</span></span><br><span class="line">);   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><strong>Testbench文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_sinrom( </span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">reg</span>        clk;</span><br><span class="line">  <span class="keyword">reg</span>        rst_n;</span><br><span class="line">  <span class="keyword">wire</span>  [<span class="number">13</span>:<span class="number">0</span>]  dds_out;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;    <span class="comment">//50MHz clock</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    #<span class="number">200</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  dds_top dds_top_m (</span><br><span class="line">    <span class="variable">.clk</span>(clk), </span><br><span class="line">    <span class="variable">.rst_n</span>(rst_n), </span><br><span class="line">    <span class="variable">.dds_out</span>(dds_out)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><p>仿真输出</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_W7ShSNx0DR.png" alt></p><p>上述图看到，周期大约为21ms</p><p>计算验证：$T = 1/f_o = 2^{20}\times1\times10^3/50\times10^6 ms = 20.97152ms$</p><p>该设计是为了证明可通过截取地址来实现更低频率的信号，解决了N有限导致的问题</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时同步学习及仿真</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1>定时同步理论学习</h1><h2 id="基本介绍">基本介绍</h2><h3 id="什么是定时同步？">什么是定时同步？</h3><blockquote><p>定时同步也叫符号同步、位同步、码元同步，只在<strong>数字通信</strong>中需要。</p></blockquote><h3 id="为什么需要定时同步？">为什么需要定时同步？</h3><blockquote><p>数字通信中使用几个采样点来表示一个码元，在接收端只需检测一个采样点即可恢复该码元。在实际通信系统中，由于<strong>收发系统间存在传输时延、收发晶振间存在固有频差</strong>等问题，导致接收端<strong>无法在每个码元对应的最佳采样点处精确采样</strong>，从而引入定时误差，使得<strong>输出信噪比减小</strong>。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_P_N49jGXcu.png" alt></p><p><strong>星座图比对</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_Ue4wtcS-P4.png" alt></p><blockquote><p>定时同步对数字信号在传输过程中产生的定时偏差进行纠正，使得<strong>信号在最佳采样点处采样</strong>。</p></blockquote><h2 id="定时同步的实现方法">定时同步的实现方法</h2><blockquote><p>3种方法，<strong>同源时钟法、数据辅助法、自同步法</strong>；</p></blockquote><ul><li><strong>同源时钟法</strong><blockquote><p>收发时钟不同源，导致收发之间存在偏差，该方法将收发时钟同步到一个主时钟上，主时钟给出一个确定的信号，接收端通过计算与主时钟之间的时钟延时来确定定时误差，从而实现定时同步。<br>该方法多用于低频通信中，目前的高速无线通信并中不常用。</p></blockquote></li><li><strong>数据辅助法</strong><blockquote><p>发送端在发送信号的同时发送一些<strong>特定的辅助数据</strong>，接收端利用这些辅助数据提取出定时信息从而完成定时同步。该方法虽然简单易行，但是会占用发送机的部分功率和信道的部分带宽，<strong>降低传输效率</strong>。</p></blockquote></li><li><strong>自同步法</strong><blockquote><p>接收端直接从接收到的数据中通过<strong>参数估计</strong>等方法提取定时信号以实现同步。该方法实现的计算复杂度相对较高，但是计算的定时误差相比前两种更加准确，应用更加广泛，成为目前无线通信的<strong>首要选择</strong>。<br>自同步法的实现分为<strong>开环同步</strong>和<strong>闭环同步</strong>两种。<br>闭环定时同步环路闭环同步法将<strong>本地时钟与接收到的信号进行比较</strong>，通过<strong>定时误差估计以及定时误差校正</strong>等环节使本地时钟与接收到的信号同步，从而得到正确的采样信号以完成定时同步。目前应用较广泛.</p></blockquote></li></ul><h2 id="闭环定时同步环路">闭环定时同步环路</h2><h3 id="反馈型全数字定时同步环路">反馈型全数字定时同步环路</h3><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_JqZNidPMmI.png" alt></p><blockquote><p><strong>优点</strong>：             <strong>·</strong> 同步<strong>精度高                    ·</strong> 适用于<strong>长时间连续</strong>数字通信系统<br><strong>缺点</strong>：             **·  <strong>需要一定的收敛时间</strong>      · **结构相对复杂</p></blockquote><p>综合考虑，一般采用反馈型全数字定时同步环路</p><h2 id="Gardner算法">Gardner算法</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_Frqi0QOsT0.png" alt></p><blockquote><p><strong>主要原理</strong>：不改变采样时钟的情况下，通过插值算法调整接收信号，使信号达到最佳采样点，从而实现定时同步。<br>对接收到的信号按照本地时钟周期 Ts 进行采样，将采样后的信号送入插值滤波器中，内插出输出的插值点。定时误差检测器采用 Gardner 算法对输出信号进行定时误差估计，将得到的估计值送入环路滤波器中进行平滑处理，再将得到的定时误差送入数控振荡器（NCO），最后将计算出的整数采样时刻 mk 和分数间隔 µk 反馈回插值滤波器，从而完成定时同步。将该过程一直迭代直至定时误差为 0 或固定值，此时数据已经几乎不存在定时误差。 </p></blockquote><ol><li><p><strong>定时误差检测器</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_l2QopKsCvo.png" alt></p><p>插值滤波器求得内插输出点后，通过$Gardner$误差检测算法计算定时误差，以反馈进行纠正</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_-6SVDx4Bkk.png" alt></p><blockquote><p>🏀<strong>Gardner定时误差检测算法不受频偏影响</strong></p></blockquote><ul><li><p>推导过程</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_6zt7oCBf1e.png" alt></p><blockquote><p><strong>载波频偏并不影响Gardner算法估计出来的定时误差</strong>。因此，Gardner算法可以用在载波同步之前。</p></blockquote></li></ul></li><li><p><strong>环路滤波器</strong></p><blockquote><p><strong>作用</strong>：滤除输出的高频分量和噪声，维持环路稳定性，提高系统的抗干扰能力，使输出更加平滑<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_vU2ACXduF6.png" alt></p></blockquote></li><li><p><strong>定时控制器</strong></p><blockquote><p>定时控制器由<strong>数控振荡器（NCO）<strong>和</strong>分数间隔计算器</strong>组成，通过对定时误差信号进行计算，用来控制插值运算。<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_Xmdq_I1mYL.png" alt><br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_WLlcvhTSCn.png" alt></p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_oGbw7oo8F1.png" alt></p></li><li><p><strong>差值滤波器</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_6zPJXp-87x.png" alt></p><p><strong>滤波器设计</strong></p><p><strong>基于Farrow结构的分段抛物线插值</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_8TSJSdYOBR.png" alt></p><p><strong>基于Farrow结构的立方插值</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_TDm_ydX9sk.png" alt></p></li></ol><h1>MATLAB仿真</h1><h2 id="仿真要求">仿真要求</h2><h2 id="仿真测试">仿真测试</h2><h3 id="BPSK系统代码">BPSK系统代码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%%%%%%%%%在BPSK收发系统的基础上，接收端加上定时误差，%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%%%%%%%%% 用resample加 ，然后用gardner 算法进行同步，判决算误码率%%%%%%%%%%%%%%%%%</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = <span class="number">4</span> * fs; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(fir_rcos, data_up); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx_valid) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx_valid .* carrier; <span class="comment">%上变频</span></span><br><span class="line"></span><br><span class="line">r_n = awgn(s_up, <span class="number">10</span>, <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%加高斯白噪声</span></span><br><span class="line"></span><br><span class="line">r_down = r_n .* carrier; <span class="comment">%下变频</span></span><br><span class="line"></span><br><span class="line">r_bx = conv(fir_rcos, r_down); <span class="comment">%匹配滤波器接收</span></span><br><span class="line">r_bx_valid = r_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">r_data = r_bx_valid(<span class="number">1</span>:sps:<span class="keyword">end</span>) &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(r_data - data);</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%%%%%%%%%在BPSK收发系统的基础上，接收端加上定时误差，%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%%%%%%%%% 用resample加 ，然后用gardner 算法进行同步，判决算误码率%%%%%%%%%%%%%%%%%</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = <span class="number">4</span> * fs; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">1e6</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(fir_rcos, data_up); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx_valid) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx_valid .* carrier; <span class="comment">%上变频</span></span><br><span class="line"></span><br><span class="line">c1 = <span class="number">5.41</span> * <span class="number">10</span>^(<span class="number">-3</span>); c2 = <span class="number">3.82</span> * <span class="number">10</span>^(<span class="number">-6</span>); <span class="comment">%环路滤波器系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%ii = 1; %用来表示Ts的时间序号,指示n,n_temp,nco,</span></span><br><span class="line"></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span> * <span class="built_in">log10</span>(sps); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">    r_n = awgn(s_up, snr(<span class="built_in">i</span>), <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%加高斯白噪声</span></span><br><span class="line"></span><br><span class="line">    r_down = r_n .* carrier; <span class="comment">%下变频</span></span><br><span class="line"></span><br><span class="line">    r_bx = conv(fir_rcos, r_down); <span class="comment">%匹配滤波器接收</span></span><br><span class="line">    r_bx_valid = r_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    len_r_bx_valid = <span class="built_in">length</span>(r_bx_valid);</span><br><span class="line">    </span><br><span class="line">    yI_decision = (r_bx_valid(<span class="number">1</span>:sps:<span class="keyword">end</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">    errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(yI_decision-data))/N;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_plot</span><br><span class="line">    <span class="comment">%     figure;</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 1);</span></span><br><span class="line">    <span class="comment">%     stem(data, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 2);</span></span><br><span class="line">    <span class="comment">%     stem(yI_decision, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">    ber_theory = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>, ebn0 / <span class="number">10</span>))); <span class="comment">%理论误码率</span></span><br><span class="line">    semilogy(ebn0, ber_theory, <span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">    semilogy(ebn0, errbit, <span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>); ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">    title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>, <span class="string">&#x27;仿真误码率曲线&#x27;</span>);</span><br><span class="line">    <span class="comment">%plot(w); title(&#x27;环路滤波器输出&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="定时同步（Gardner算法）">定时同步（Gardner算法）</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%%%%%%%%%在BPSK收发系统的基础上，接收端加上定时误差，%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%%%%%%%%% 用resample加 ，然后用gardner 算法进行同步，判决算误码率%%%%%%%%%%%%%%%%%</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = <span class="number">4</span> * fs; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">50000</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(fir_rcos, data_up); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx_valid) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx_valid .* carrier; <span class="comment">%上变频</span></span><br><span class="line"></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span> * <span class="built_in">log10</span>(sps); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">    r_n = awgn(s_up, snr(<span class="built_in">i</span>), <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%加高斯白噪声</span></span><br><span class="line"></span><br><span class="line">    r_down = r_n .* carrier; <span class="comment">%下变频</span></span><br><span class="line"></span><br><span class="line">    r_bx = conv(fir_rcos, r_down); <span class="comment">%匹配滤波器接收</span></span><br><span class="line">    r_bx_valid = r_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">%接收端加上定时误差</span></span><br><span class="line">    P = <span class="number">40000</span>;</span><br><span class="line">    Q = <span class="number">40002</span>;</span><br><span class="line">    r_data_er = resample(r_bx_valid, P, Q); <span class="comment">%输入序列x在P/Q乘以原始采样速率下进行重新采样</span></span><br><span class="line">    len_r_data_er = <span class="built_in">length</span>(r_data_er);</span><br><span class="line">    <span class="comment">%c1 = 5.41 * 10^(-3); c2 = 3.82 * 10^(-6); %环路滤波器系数</span></span><br><span class="line">    c1 = <span class="number">1</span>/<span class="number">2</span>^<span class="number">11</span>; c2 = <span class="number">1</span>/<span class="number">2</span>^<span class="number">23</span>;</span><br><span class="line">    <span class="comment">%gardner环参数设置</span></span><br><span class="line">    w = [<span class="number">0.5</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)]; <span class="comment">%环路滤波器输出寄存器，初值设为0.5</span></span><br><span class="line">    n = [<span class="number">0.7</span> <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)]; <span class="comment">%NCO寄存器，初值设为0.7</span></span><br><span class="line"></span><br><span class="line">    u = [<span class="number">0.6</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, len_r_data_er - <span class="number">1</span>)]; <span class="comment">%NCO输出的定时分数间隔寄存器，初值设为0.6</span></span><br><span class="line">    time_error = <span class="built_in">zeros</span>(<span class="number">1</span>, N); <span class="comment">%Gardner提取的时钟误差寄存器</span></span><br><span class="line">    yI = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">2</span> * N); <span class="comment">%I路内插之后的输出数据</span></span><br><span class="line">    <span class="comment">%yI数组长度是u和te的两倍，其原因在于yI(n-1/2)，matlab中仿真不方便,所以取一半的数</span></span><br><span class="line">    <span class="comment">%ii = 1; %用来表示Ts的时间序号,指示n,n_temp,nco,</span></span><br><span class="line">    k = <span class="number">1</span>; <span class="comment">%用来表示Ti时间序号,指示u,yI,yQ</span></span><br><span class="line">    ms = <span class="number">1</span>; <span class="comment">%用来指示T的时间序号,用来指示a,b以及w</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii = <span class="number">2</span>:(len_r_data_er - <span class="number">3</span>)</span><br><span class="line">        n(ii + <span class="number">1</span>) = n(ii) - w(ms);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n(ii + <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            u(k) = n(ii) / w(ms);</span><br><span class="line">            n(ii + <span class="number">1</span>) = <span class="built_in">mod</span>(n(ii + <span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">%内插滤波器</span></span><br><span class="line">            F1 = <span class="number">0.5</span> * r_data_er(ii + <span class="number">2</span>) - <span class="number">0.5</span> * r_data_er(ii + <span class="number">1</span>) - <span class="number">0.5</span> * r_data_er(ii) + <span class="number">0.5</span> * r_data_er(ii - <span class="number">1</span>);</span><br><span class="line">            F2 = <span class="number">1.5</span> * r_data_er(ii + <span class="number">1</span>) - <span class="number">0.5</span> * r_data_er(ii + <span class="number">2</span>) - <span class="number">0.5</span> * r_data_er(ii) - <span class="number">0.5</span> * r_data_er(ii - <span class="number">1</span>);</span><br><span class="line">            F3 = r_data_er(ii);</span><br><span class="line">            yI(k) = (F1 * u(k) + F2) * u(k) + F3;</span><br><span class="line"></span><br><span class="line">            <span class="comment">% 时钟误差提取模块</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">mod</span>(k, <span class="number">2</span>) == <span class="number">1</span>)</span><br><span class="line">                <span class="comment">%每一个数据符号计算一次误差</span></span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">2</span>)</span><br><span class="line">                    time_error(ms) = yI(k - <span class="number">1</span>) * (yI(k) - yI(k - <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    time_error(ms) = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> (ms &gt; <span class="number">1</span>)</span><br><span class="line">                    w(ms + <span class="number">1</span>) = w(ms) + c1 * (time_error(ms) - time_error(ms - <span class="number">1</span>)) + c2 * time_error(ms);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    w(ms + <span class="number">1</span>) = w(ms) + c1 * time_error(ms) + c2 * time_error(ms);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                 </span><br><span class="line">                ms = ms +<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">                       k = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">%抽样判决</span></span><br><span class="line">    <span class="comment">%yI_decision = (sign(yI(1:2:end)) + 1) / 2;</span></span><br><span class="line">    yI_decision = (yI(<span class="number">1</span>:<span class="number">2</span>:<span class="keyword">end</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">    errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(yI_decision(<span class="number">301</span>:N) - data(<span class="number">301</span>:N))) / (N<span class="number">-300</span>);</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_plot</span><br><span class="line">    <span class="comment">%     figure;</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 1);</span></span><br><span class="line">    <span class="comment">%     stem(data, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 2);</span></span><br><span class="line">    <span class="comment">%     stem(yI_decision, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">    ber_theory = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>, ebn0 / <span class="number">10</span>))); <span class="comment">%理论误码率</span></span><br><span class="line">    semilogy(ebn0, ber_theory, <span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    semilogy(ebn0, errbit, <span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>); ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">    title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>, <span class="string">&#x27;仿真误码率曲线&#x27;</span>);</span><br><span class="line"><span class="comment">%     figure;</span></span><br><span class="line"><span class="comment">%     plot(w); title(&#x27;环路滤波器输出&#x27;);</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    <span class="built_in">plot</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_DEU5BsbifC.png" alt></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%%%%%%%%%在BPSK收发系统的基础上，接收端加上定时误差，%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="comment">%%%%%%%%% 用resample加 ，然后用gardner 算法进行同步，判决算误码率%%%%%%%%%%%%%%%%%</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%每个符号4个采样点</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = <span class="number">4</span> * fs; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">50000</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射</span></span><br><span class="line">data_up = upsample(s, sps); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, span, sps, <span class="string">&quot;sqrt&quot;</span>); <span class="comment">%根升余弦</span></span><br><span class="line">data_bx = conv(fir_rcos, data_up); <span class="comment">%通过滤波器</span></span><br><span class="line">data_bx_valid = data_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx_valid) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx_valid .* carrier; <span class="comment">%上变频</span></span><br><span class="line"></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span> * <span class="built_in">log10</span>(sps); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">    r_n = awgn(s_up, snr(<span class="built_in">i</span>), <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%加高斯白噪声</span></span><br><span class="line"></span><br><span class="line">    r_down = r_n .* carrier; <span class="comment">%下变频</span></span><br><span class="line"></span><br><span class="line">    r_bx = conv(fir_rcos, r_down); <span class="comment">%匹配滤波器接收</span></span><br><span class="line">    r_bx_valid = r_bx(<span class="number">1</span>, (<span class="number">1</span> + <span class="built_in">length</span>(fir_rcos)) / <span class="number">2</span>:<span class="keyword">end</span> - (<span class="built_in">length</span>(fir_rcos) - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">%r_bx_valid_down = r_bx_valid(1:sps:end);不需要下采样</span></span><br><span class="line">    <span class="comment">%接收端加上定时误差</span></span><br><span class="line">    P = <span class="number">40000</span>;</span><br><span class="line">    Q = <span class="number">40002</span>;</span><br><span class="line">    r_data_er = resample(r_bx_valid, P, Q); <span class="comment">%输入序列x在P/Q乘以原始采样速率下进行重新采样</span></span><br><span class="line">    len_r_data_er = <span class="built_in">length</span>(r_data_er);</span><br><span class="line">    <span class="comment">%c1 = 5.41 * 10^(-3); c2 = 3.82 * 10^(-6); %环路滤波器系数</span></span><br><span class="line">    c1 = <span class="number">1</span>/<span class="number">2</span>^<span class="number">11</span>; c2 = <span class="number">1</span>/<span class="number">2</span>^<span class="number">23</span>;</span><br><span class="line">    <span class="comment">%gardner环参数设置</span></span><br><span class="line">    w = [<span class="number">0.25</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)]; <span class="comment">%环路滤波器输出寄存器，初值设为0.5</span></span><br><span class="line">    n = [<span class="number">0.7</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, N - <span class="number">1</span>)]; <span class="comment">%NCO寄存器，初值设为0.7</span></span><br><span class="line"></span><br><span class="line">    u = [<span class="number">0.6</span>, <span class="built_in">zeros</span>(<span class="number">1</span>, len_r_data_er - <span class="number">1</span>)]; <span class="comment">%NCO输出的定时分数间隔寄存器，初值设为0.6</span></span><br><span class="line">    time_error = <span class="built_in">zeros</span>(<span class="number">1</span>, N); <span class="comment">%Gardner提取的时钟误差寄存器</span></span><br><span class="line">    yI = <span class="built_in">zeros</span>(<span class="number">1</span>, N); <span class="comment">%I路内插之后的输出数据</span></span><br><span class="line">    <span class="comment">%ii = 1; %用来表示Ts的时间序号,指示n,n_temp,nco,(相当于mk)</span></span><br><span class="line">    ms = <span class="number">1</span>; <span class="comment">%用来指示T的时间序号,用来指示a,b以及w</span></span><br><span class="line">    k = <span class="number">1</span>; <span class="comment">%用来表示Ti时间序号,指示u,yI,yQ</span></span><br><span class="line">    m = <span class="built_in">zeros</span>(<span class="number">1</span>, N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii = <span class="number">2</span>:(len_r_data_er - <span class="number">3</span>)</span><br><span class="line">        n(ii + <span class="number">1</span>) = n(ii) - w(ms);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n(ii + <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="comment">%小于零相当于溢出，此时ii为溢出最后采样点的索引mk</span></span><br><span class="line">            n(ii + <span class="number">1</span>) = n(ii + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            u(k) = n(ii) / w(ms);</span><br><span class="line">            m(k) = ii;</span><br><span class="line"></span><br><span class="line">            <span class="comment">%内插滤波器</span></span><br><span class="line">            F1 = <span class="number">0.5</span> * r_data_er(m(k) + <span class="number">2</span>) - <span class="number">0.5</span> * r_data_er(m(k) + <span class="number">1</span>) - <span class="number">0.5</span> * r_data_er(m(k)) + <span class="number">0.5</span> * r_data_er(m(k) - <span class="number">1</span>);</span><br><span class="line">            F2 = <span class="number">1.5</span> * r_data_er(m(k) + <span class="number">1</span>) - <span class="number">0.5</span> * r_data_er(m(k) + <span class="number">2</span>) - <span class="number">0.5</span> * r_data_er(m(k)) - <span class="number">0.5</span> * r_data_er(m(k) - <span class="number">1</span>);</span><br><span class="line">            F3 = r_data_er(m(k));</span><br><span class="line">            yI(k) = (F1 * u(k) + F2) * u(k) + F3;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">1</span>)</span><br><span class="line">                mk_mid = <span class="built_in">floor</span>((m(k) + m(k - <span class="number">1</span>) + u(k) + u(k - <span class="number">1</span>)) / <span class="number">2</span>);</span><br><span class="line">                F1 = <span class="number">0.5</span> * r_data_er(mk_mid + <span class="number">2</span>) - <span class="number">0.5</span> * r_data_er(mk_mid + <span class="number">1</span>) - <span class="number">0.5</span> * r_data_er(mk_mid) + <span class="number">0.5</span> * r_data_er(mk_mid<span class="number">-1</span>);</span><br><span class="line">                F2 = <span class="number">1.5</span> * r_data_er(mk_mid + <span class="number">1</span>) - <span class="number">0.5</span> * r_data_er(mk_mid + <span class="number">2</span>) - <span class="number">0.5</span> * r_data_er(mk_mid) - <span class="number">0.5</span> * r_data_er(mk_mid<span class="number">-1</span>);</span><br><span class="line">                F3 = r_data_er(mk_mid);</span><br><span class="line">                uk_mid = (m(k) + m(k - <span class="number">1</span>) + u(k) + u(k - <span class="number">1</span>)) / <span class="number">2</span> - mk_mid;</span><br><span class="line">                yI_mid = (F1 * uk_mid + F2) * uk_mid + F3;</span><br><span class="line">                time_error(ms) = yI_mid * (yI(k) - yI(k - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                time_error(ms) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">1</span>)</span><br><span class="line">                w(ms + <span class="number">1</span>) = w(ms) + c1 * (time_error(ms) - time_error(ms - <span class="number">1</span>)) + c2 * time_error(ms);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                w(ms + <span class="number">1</span>) = w(ms) + c1 * time_error(ms) + c2 * time_error(ms);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            ms = ms +<span class="number">1</span>;</span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%抽样判决</span></span><br><span class="line">    <span class="comment">%yI_decision = (sign(yI(1:2:end)) + 1) / 2;</span></span><br><span class="line">    yI_decision = (yI(<span class="number">1</span>:<span class="number">1</span>:<span class="keyword">end</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">%errbit(i) = sum(abs(yI_decision(301:N) - data(301:N))) / (N - 300);</span></span><br><span class="line">    errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(yI_decision - data)) / N;</span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> +<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_plot</span><br><span class="line">    <span class="comment">%     figure;</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 1);</span></span><br><span class="line">    <span class="comment">%     stem(data, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="comment">%     subplot(2, 1, 2);</span></span><br><span class="line">    <span class="comment">%     stem(yI_decision, &#x27;filled&#x27;);</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">    ber_theory = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>, ebn0 / <span class="number">10</span>))); <span class="comment">%理论误码率</span></span><br><span class="line">    semilogy(ebn0, ber_theory, <span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    semilogy(ebn0, errbit, <span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">    grid on; <span class="built_in">hold</span> on;</span><br><span class="line">    xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>); ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">    title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line">    <span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>, <span class="string">&#x27;仿真误码率曲线&#x27;</span>);</span><br><span class="line">    <span class="comment">%     figure;</span></span><br><span class="line">    <span class="comment">%     plot(w); title(&#x27;环路滤波器输出&#x27;);</span></span><br><span class="line">    <span class="built_in">figure</span>;</span><br><span class="line">    <span class="built_in">plot</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/05%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%AE%9A%E6%97%B6%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_8BGsN5vyim.png" alt></p><h3 id="借鉴学习">借鉴学习</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">% --------------------------参数定义-------------------------- %</span></span><br><span class="line">dataLength = <span class="number">2</span>^<span class="number">19</span>;<span class="comment">%数据长度</span></span><br><span class="line">M = <span class="number">2</span>;<span class="comment">%调制阶数</span></span><br><span class="line"></span><br><span class="line">rolloffFactor = <span class="number">0.35</span>;<span class="comment">%滚降系数</span></span><br><span class="line">span = <span class="number">6</span>;<span class="comment">%截断符号范围</span></span><br><span class="line">numSPSForming = <span class="number">4</span>;<span class="comment">%成型过采样倍数</span></span><br><span class="line">symbolRate = <span class="number">1e6</span>;<span class="comment">%符号速率</span></span><br><span class="line">freqSampling = numSPSForming*symbolRate;<span class="comment">%采样速率</span></span><br><span class="line"></span><br><span class="line">freqCarrier = <span class="number">2e6</span>;<span class="comment">%载波频率</span></span><br><span class="line"></span><br><span class="line">EbN0 = <span class="number">1</span>:<span class="number">10</span>;<span class="comment">%dB</span></span><br><span class="line">SNR = EbN0+<span class="number">10</span>*<span class="built_in">log10</span>(<span class="number">2</span>)<span class="number">-10</span>*<span class="built_in">log10</span>(numSPSForming);<span class="comment">%信噪比(dB)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% BL = 2e3;%环路噪声带宽</span></span><br><span class="line"><span class="comment">% Ts = 1/symbolRate;%符号持续时间</span></span><br><span class="line"><span class="comment">% wn = 8*0.707*BL/(4*0.707^2+1);</span></span><br><span class="line"><span class="comment">% C = 4+4*0.707*wn*Ts+(wn*Ts)^2;</span></span><br><span class="line"><span class="comment">% k1 = (4*(wn*Ts)^2+8*0.707*wn*Ts)/C;%环路滤波器系数</span></span><br><span class="line"><span class="comment">% k2 = 4*(wn*Ts)^2/C;%环路滤波器系数</span></span><br><span class="line"></span><br><span class="line">BL = <span class="number">2e3</span>;  <span class="comment">% 环路带宽</span></span><br><span class="line">k1 = <span class="number">8</span>*BL*<span class="number">1</span>/symbolRate/<span class="number">3</span>; </span><br><span class="line">k2 = <span class="number">32</span>*(BL*<span class="number">1</span>/symbolRate)^<span class="number">2</span>/<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% --------------------------发射序列-------------------------- %</span></span><br><span class="line">dataOrig = randi([<span class="number">0</span>,M<span class="number">-1</span>],<span class="number">1</span>,dataLength);<span class="comment">%0,1等概率</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">% --------------------------映射-------------------------- %</span></span><br><span class="line">dataPsk = <span class="number">2</span>*dataOrig<span class="number">-1</span>;</span><br><span class="line"><span class="comment">% pskData = real(pskmod(origData,order));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% --------------------------成型-------------------------- %</span></span><br><span class="line">dataUpSample = upsample(dataPsk,numSPSForming);<span class="comment">%上采样</span></span><br><span class="line">filterForm = rcosdesign(rolloffFactor,span,numSPSForming,<span class="string">&quot;sqrt&quot;</span>);<span class="comment">%成型滤波器</span></span><br><span class="line">signalBaseBand = conv(dataUpSample,filterForm,<span class="string">&quot;same&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% --------------------------上变频-------------------------- %</span></span><br><span class="line">t = (<span class="number">0</span>:(<span class="built_in">length</span>(signalBaseBand)<span class="number">-1</span>))/freqSampling;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*freqCarrier*t);</span><br><span class="line">signalModulated = signalBaseBand.*carrier;</span><br><span class="line"></span><br><span class="line">actualBitErrorRate = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);<span class="comment">%实际误码率</span></span><br><span class="line">filterMatched = <span class="built_in">conj</span>(filterForm);<span class="comment">%匹配滤波器</span></span><br><span class="line"><span class="keyword">for</span> cntSNR = <span class="number">1</span>:<span class="built_in">length</span>(SNR)</span><br><span class="line">    <span class="comment">% --------------------------加噪-------------------------- %</span></span><br><span class="line">    signalNoizeAdded = awgn(signalModulated,SNR(cntSNR),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line"><span class="comment">%     signalNoizeAdded = awgn(signalModulated,10,&#x27;measured&#x27;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --------------------------下变频-------------------------- %</span></span><br><span class="line">    signalDownFreq = signalNoizeAdded.*carrier;</span><br><span class="line">    dataResmp = resample(signalDownFreq,<span class="number">1e4</span>,<span class="number">1e4</span>+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --------------------------匹配滤波-------------------------- %</span></span><br><span class="line">    dataMatched = conv(dataResmp,filterMatched,<span class="string">&quot;same&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --------------------------定时同步-------------------------- %</span></span><br><span class="line">    dataRecv = dataMatched;</span><br><span class="line"></span><br><span class="line">    outSyn = <span class="built_in">zeros</span>(<span class="number">1</span>,dataLength);<span class="comment">%定时同步输出</span></span><br><span class="line">    timeError = <span class="built_in">zeros</span>(<span class="number">1</span>,dataLength);<span class="comment">%定时误差</span></span><br><span class="line">    outFilter = [<span class="number">0.25</span> <span class="built_in">zeros</span>(<span class="number">1</span>,dataLength<span class="number">-1</span>)];<span class="comment">%环路滤波器输出，初值0.25</span></span><br><span class="line">    outNCO = [<span class="number">0.35</span> <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="built_in">length</span>(dataRecv)<span class="number">-1</span>)];<span class="comment">%NCO输出，初值0.9</span></span><br><span class="line">    outNCOTemp = outNCO;</span><br><span class="line">    outInterval = <span class="built_in">zeros</span>(<span class="number">1</span>,dataLength);<span class="comment">%分数间隔,初值0.6</span></span><br><span class="line"></span><br><span class="line">    mkArray = <span class="built_in">zeros</span>(<span class="number">1</span>,dataLength);<span class="comment">%保存各mk值，供计算中间点</span></span><br><span class="line">    indexSyn = <span class="number">1</span>;<span class="comment">%同步输出索引，指示插值输出、分数间隔、环路滤波器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> indexSmp = <span class="number">1</span>:<span class="built_in">length</span>(dataRecv)<span class="number">-2</span><span class="comment">%采样点索引，指示输入数据、数控振荡器</span></span><br><span class="line">        <span class="comment">% --------------------------定时控制-------------------------- %</span></span><br><span class="line">        outNCOTemp(indexSmp+<span class="number">1</span>) = outNCO(indexSmp)-outFilter(indexSyn);</span><br><span class="line">        <span class="keyword">if</span> outNCOTemp(indexSmp+<span class="number">1</span>)&gt;<span class="number">0</span></span><br><span class="line">            outNCO(indexSmp+<span class="number">1</span>) = outNCOTemp(indexSmp+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">%NCO溢出，插值</span></span><br><span class="line">            outNCO(indexSmp+<span class="number">1</span>) = <span class="built_in">mod</span>(outNCOTemp(indexSmp+<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">            outInterval(indexSyn) = outNCO(indexSmp)/outFilter(indexSyn);<span class="comment">%分数间隔计算</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">% --------------------------插值-------------------------- %</span></span><br><span class="line">            mkArray(indexSyn) = indexSmp;</span><br><span class="line">            f0 = dataRecv(indexSmp);</span><br><span class="line">            f1 = <span class="number">-1</span>/<span class="number">3</span>*dataRecv(indexSmp<span class="number">-1</span>)<span class="number">-1</span>/<span class="number">2</span>*dataRecv(indexSmp)+dataRecv(indexSmp+<span class="number">1</span>)<span class="number">-1</span>/<span class="number">6</span>*dataRecv(indexSmp+<span class="number">2</span>);</span><br><span class="line">            f2 = <span class="number">1</span>/<span class="number">2</span>*dataRecv(indexSmp<span class="number">-1</span>)-dataRecv(indexSmp)+<span class="number">1</span>/<span class="number">2</span>*dataRecv(indexSmp+<span class="number">1</span>);</span><br><span class="line">            f3 = <span class="number">-1</span>/<span class="number">6</span>*dataRecv(indexSmp<span class="number">-1</span>)+<span class="number">1</span>/<span class="number">2</span>*dataRecv(indexSmp)<span class="number">-1</span>/<span class="number">2</span>*dataRecv(indexSmp+<span class="number">1</span>)+<span class="number">1</span>/<span class="number">6</span>*dataRecv(indexSmp+<span class="number">2</span>);</span><br><span class="line">            outSyn(indexSyn) = f3*outInterval(indexSyn)^<span class="number">3</span>+f2*outInterval(indexSyn)^<span class="number">2</span>+f1*outInterval(indexSyn)+f0;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">% --------------------------定时误差检测-------------------------- %</span></span><br><span class="line">            <span class="keyword">if</span> indexSyn &gt; <span class="number">1</span></span><br><span class="line">                mkMid = <span class="built_in">floor</span>( (mkArray(indexSyn<span class="number">-1</span>)+outInterval(indexSyn<span class="number">-1</span>)+mkArray(indexSyn)+outInterval(indexSyn))/<span class="number">2</span> );<span class="comment">%中间点mk</span></span><br><span class="line">                intervalMid = (mkArray(indexSyn<span class="number">-1</span>)+outInterval(indexSyn<span class="number">-1</span>)+mkArray(indexSyn)+outInterval(indexSyn))/<span class="number">2</span>-mkMid;<span class="comment">%中间点分数间隔</span></span><br><span class="line">                f0Mid = dataRecv(mkMid);</span><br><span class="line">                f1Mid = <span class="number">-1</span>/<span class="number">3</span>*dataRecv(mkMid<span class="number">-1</span>)<span class="number">-1</span>/<span class="number">2</span>*dataRecv(mkMid)+dataRecv(mkMid+<span class="number">1</span>)<span class="number">-1</span>/<span class="number">6</span>*dataRecv(mkMid+<span class="number">2</span>);</span><br><span class="line">                f2Mid = <span class="number">1</span>/<span class="number">2</span>*dataRecv(mkMid<span class="number">-1</span>)-dataRecv(mkMid)+<span class="number">1</span>/<span class="number">2</span>*dataRecv(mkMid+<span class="number">1</span>);</span><br><span class="line">                f3Mid = <span class="number">-1</span>/<span class="number">6</span>*dataRecv(mkMid<span class="number">-1</span>)+<span class="number">1</span>/<span class="number">2</span>*dataRecv(mkMid)<span class="number">-1</span>/<span class="number">2</span>*dataRecv(mkMid+<span class="number">1</span>)+<span class="number">1</span>/<span class="number">6</span>*dataRecv(mkMid+<span class="number">2</span>);</span><br><span class="line">                midOutSyn = f3Mid*intervalMid^<span class="number">3</span>+f2Mid*intervalMid^<span class="number">2</span>+f1Mid*intervalMid+f0Mid;<span class="comment">%中间点插值</span></span><br><span class="line">                timeError(indexSyn+<span class="number">1</span>) = midOutSyn*(outSyn(indexSyn)-outSyn(indexSyn<span class="number">-1</span>));<span class="comment">%定时误差更新</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                timeError(indexSyn+<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">% --------------------------环路滤波-------------------------- %</span></span><br><span class="line">            outFilter(indexSyn+<span class="number">1</span>) = outFilter(indexSyn)+k1*(timeError(indexSyn+<span class="number">1</span>)-timeError(indexSyn))+k2*timeError(indexSyn+<span class="number">1</span>);</span><br><span class="line">            indexSyn = indexSyn+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">%     plot(outNCO);</span></span><br><span class="line"><span class="comment">%     figure(2);</span></span><br><span class="line"><span class="comment">%     plot(outFilter);</span></span><br><span class="line"><span class="comment">%     figure(3);</span></span><br><span class="line"><span class="comment">%     plot(outInterval);</span></span><br><span class="line"><span class="comment">%     figure(4);</span></span><br><span class="line"><span class="comment">%     plot(timeError);</span></span><br><span class="line">    <span class="comment">% --------------------------判决-------------------------- %</span></span><br><span class="line">    dataDecision = outSyn;</span><br><span class="line">    dataDecision(dataDecision&gt;<span class="number">0</span>) = <span class="number">1</span>;</span><br><span class="line">    dataDecision(dataDecision&lt;<span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% --------------------------误码率计算-------------------------- %</span></span><br><span class="line">    cmp = dataDecision-dataOrig;</span><br><span class="line">    error = cmp(cmp~=<span class="number">0</span>);</span><br><span class="line">    actualBitErrorRate(cntSNR) = <span class="built_in">length</span>(error)/dataLength;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% --------------------------误码率比较-------------------------- %</span></span><br><span class="line">theoBitErrorRate = berawgn(EbN0,<span class="string">&#x27;psk&#x27;</span>,M,<span class="string">&#x27;nondiff&#x27;</span>);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">semilogy(EbN0,theoBitErrorRate);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">semilogy(EbN0,actualBitErrorRate);</span><br><span class="line">xlabel(<span class="string">&#x27;Eb/N0 (dB)&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;BER&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;Theoretical&#x27;</span>,<span class="string">&#x27;Actual&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Bit Error Rate&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>码环学习及仿真</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/06%E7%A0%81%E7%8E%AF/%E7%A0%81%E7%8E%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/06%E7%A0%81%E7%8E%AF/%E7%A0%81%E7%8E%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1>MATLAB仿真</h1><h2 id="目录">目录</h2><ul><li><a href="#matlab%E4%BB%BF%E7%9C%9F">MATLAB仿真</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#%E9%81%97%E7%95%99%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98">遗留一个问题</a></li><li><a href="#%E9%A2%84%E4%BF%9D%E5%AD%98">预保存</a></li><li><a href="#%E6%B2%A1%E6%9C%89%E4%B8%8A%E4%B8%8B%E5%8F%98%E9%A2%91">没有上下变频</a></li><li><a href="#%E4%BD%8E%E4%BF%A1%E5%99%AA%E6%AF%94%E8%BF%9B%E8%A1%8C%E7%A7%AF%E7%B4%AF">低信噪比进行积累</a></li><li><a href="#%E7%A7%AF%E7%B4%AF">积累</a></li></ul></li></ul></li></ul><h3 id="遗留一个问题">遗留一个问题</h3><h3 id="预保存">预保存</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 相关仿真-----------码环纠正</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">warning off;</span><br><span class="line"><span class="comment">%-----------------------参数设置--------------------------%</span></span><br><span class="line"></span><br><span class="line">fs = <span class="number">16000</span>; <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">4000</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10</span>; <span class="comment">%数据长度</span></span><br><span class="line">symbol_rate = <span class="number">4000</span>; <span class="comment">%符号速率</span></span><br><span class="line"><span class="comment">%-----------------------发送端--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------发送序列+映射-----------------------%</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------生成m序列------------------------%</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>); <span class="comment">%ms列向量</span></span><br><span class="line"></span><br><span class="line">m_1 = ms .* data_bio;</span><br><span class="line">Y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * data_len]); <span class="comment">%扩频完之后的数据</span></span><br><span class="line"></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(Y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------根升余弦滤波成型---------------------%</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&quot;same&quot;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------上变频--------------------------%</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier .* data_bx; <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------接收端-----------------------------%</span></span><br><span class="line"><span class="comment">%r_n = awgn(s_up, -20, &#x27;measured&#x27;); %添加噪声</span></span><br><span class="line">r_n = s_up;</span><br><span class="line">N = <span class="number">500</span>; <span class="comment">%填0的个数</span></span><br><span class="line">recv_sig_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n]; <span class="comment">%对序列进行延时操作，前面补0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------正交下变频--------------------------%</span></span><br><span class="line"></span><br><span class="line">t1 = <span class="number">0</span>:<span class="built_in">length</span>(recv_sig_add_0) - <span class="number">1</span>;</span><br><span class="line">carrier_cos = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t1);</span><br><span class="line">carrier_sin = <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t1);</span><br><span class="line"></span><br><span class="line">recv_sig_I = recv_sig_add_0 .* carrier_cos;</span><br><span class="line">recv_sig_Q = recv_sig_add_0 .* carrier_sin;</span><br><span class="line"></span><br><span class="line"><span class="comment">% recv_sig_complex = complex(recv_sig_I, recv_sig_Q);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------匹配滤波--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% mg_up_flip = upsample(fliplr(ms&#x27;), sps); %反转序列后上采样</span></span><br><span class="line"><span class="comment">% fir_m = conv(mg_up_flip, fir_rcos); %本地广义成形</span></span><br><span class="line"><span class="comment">% mg_up_xcorr = conv(mg_up_flip, fir_rcos, &#x27;same&#x27;); %对m序列进行相关</span></span><br><span class="line"></span><br><span class="line">r_bx_I = conv(recv_sig_I, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line">r_bx_Q = conv(recv_sig_Q, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line"></span><br><span class="line">r_complex = <span class="built_in">complex</span>(r_bx_I, r_bx_Q);</span><br><span class="line"><span class="comment">%-----------------------E P L码--------------------------%</span></span><br><span class="line"><span class="comment">% mg_up = upsample(ms.&#x27;, sps);</span></span><br><span class="line"><span class="comment">% l = length(mg_up);</span></span><br><span class="line"><span class="comment">% % l = length(mg_up_xcorr);</span></span><br><span class="line"><span class="comment">% mg_up_e = circshift(mg_up, -l / 2 - 1); %左移,超前</span></span><br><span class="line"><span class="comment">% mg_up_p = mg_up;</span></span><br><span class="line"><span class="comment">% mg_up_l = circshift(mg_up, l / 2 + 1); %右移,滞后</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%第二种途径</span></span><br><span class="line">mg_e = <span class="built_in">circshift</span>(ms.&#x27;,-(p+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">mg_l = <span class="built_in">circshift</span>(ms.&#x27;, (p+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">mg_up_e = upsample(mg_e,sps);</span><br><span class="line">mg_up_l = upsample(mg_l,sps);</span><br><span class="line">mg_up_p = upsample(ms.&#x27;,sps);</span><br><span class="line">l = <span class="built_in">length</span>(mg_up_p);</span><br><span class="line"><span class="comment">%-----------------------码环--------------------------%</span></span><br><span class="line">ec = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line"><span class="comment">%环路滤波器参数设置</span></span><br><span class="line">BL = <span class="number">100</span>; <span class="comment">%环路带宽</span></span><br><span class="line">w_nf = BL * <span class="number">0.53</span>;</span><br><span class="line">K_d = <span class="number">1</span>;</span><br><span class="line">K_1 = <span class="number">1</span>;</span><br><span class="line">T = <span class="number">1</span> / symbol_rate;</span><br><span class="line">K_f = <span class="number">1</span>;</span><br><span class="line">w_mid = <span class="built_in">zeros</span>(<span class="number">1</span>, l); <span class="comment">% 环路滤波器中间变量</span></span><br><span class="line">w = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">L = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line">delta_P = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">P = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:l - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%%相关运算</span></span><br><span class="line">    mg_up_p = <span class="built_in">fliplr</span>(<span class="built_in">circshift</span>(mg_up_p, P));</span><br><span class="line">    sig_xcorr_I_P = conv(r_bx_I, mg_up_p,<span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_Q_P = conv(r_bx_Q, mg_up_p,<span class="string">&quot;same&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    mg_up_e = <span class="built_in">circshift</span>(mg_up_p, -l / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    mg_up_l = <span class="built_in">circshift</span>(mg_up_p, l / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sig_xcorr_I_E = conv(r_bx_I, mg_up_e, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_Q_E = conv(r_bx_Q, mg_up_e, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_I_L = conv(r_bx_I, mg_up_l, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_Q_L = conv(r_bx_Q, mg_up_l, <span class="string">&quot;same&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    E(k) = <span class="built_in">sqrt</span>(sig_xcorr_I_E(k)^<span class="number">2</span> + sig_xcorr_Q_E(k)^<span class="number">2</span>);</span><br><span class="line">    L(k) = <span class="built_in">sqrt</span>(sig_xcorr_I_L(k)^<span class="number">2</span> + sig_xcorr_Q_L(k)^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ec(k) = <span class="number">0.5</span>*(E(k)^<span class="number">2</span> - L(k)^<span class="number">2</span>) / (E(k)^<span class="number">2</span> + L(k)^<span class="number">2</span>); <span class="comment">%超前减滞后功率鉴相法</span></span><br><span class="line">    <span class="comment">%ec(k) = (E - L) / (E + L);%超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%delta_cp(k) = 1/2 * (E - L) / (E + L); %超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%点积功率鉴相器</span></span><br><span class="line">    <span class="comment">%ec(k) = (sig_xcorr_I_E(k) - sig_xcorr_I_L(k)) * sig_xcorr_I_L(k) + (sig_xcorr_Q_E(k) - sig_xcorr_Q_L(k)) * sig_xcorr_Q_L(k);</span></span><br><span class="line">    <span class="comment">%ec(k) = ec(k) / (sig_xcorr_I_P(k)^2 + sig_xcorr_Q_P(k)^2);</span></span><br><span class="line">    <span class="comment">%环路滤波器</span></span><br><span class="line">    w_mid(k + <span class="number">1</span>) = w_mid(k) + (w_nf^<span class="number">2</span> * T) * (ec(k) * K_d * K_1);</span><br><span class="line">    w(k + <span class="number">1</span>) = w(k) + T * w_mid(k + <span class="number">1</span>) + (<span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T) * (ec(k) * K_d * K_1);</span><br><span class="line"></span><br><span class="line">    delta_P(k + <span class="number">1</span>) = K_f * (w_mid(k + <span class="number">1</span>) + <span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T * ec(k)) / (<span class="number">2</span> * <span class="built_in">pi</span>);</span><br><span class="line">    P = <span class="built_in">round</span>(delta_P);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(sig_xcorr_I_P);</span><br><span class="line"></span><br><span class="line">y_decision = sig_xcorr_I_P(<span class="number">1008</span>:p*sps:<span class="keyword">end</span>)&gt;<span class="number">0</span>;</span><br><span class="line">error_bit = biterr(y_decision, data);</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 相关仿真-----------码环纠正</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">warning off;</span><br><span class="line"><span class="comment">%-----------------------参数设置--------------------------%</span></span><br><span class="line"></span><br><span class="line">fs = <span class="number">16000</span>; <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">4000</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10</span>; <span class="comment">%数据长度</span></span><br><span class="line">symbol_rate = <span class="number">4000</span>; <span class="comment">%符号速率</span></span><br><span class="line"><span class="comment">%-----------------------发送端--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------发送序列+映射-----------------------%</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------生成m序列------------------------%</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>); <span class="comment">%ms列向量</span></span><br><span class="line"></span><br><span class="line">m_1 = ms .* data_bio;</span><br><span class="line">Y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * data_len]); <span class="comment">%扩频完之后的数据</span></span><br><span class="line"></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(Y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------根升余弦滤波成型---------------------%</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&quot;same&quot;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------上变频--------------------------%</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier .* data_bx; <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------接收端-----------------------------%</span></span><br><span class="line"><span class="comment">%r_n = awgn(s_up, -20, &#x27;measured&#x27;); %添加噪声</span></span><br><span class="line">r_n = s_up;</span><br><span class="line">N = <span class="number">500</span>; <span class="comment">%填0的个数</span></span><br><span class="line">recv_sig_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n]; <span class="comment">%对序列进行延时操作，前面补0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------正交下变频--------------------------%</span></span><br><span class="line"></span><br><span class="line">t1 = <span class="number">0</span>:<span class="built_in">length</span>(recv_sig_add_0) - <span class="number">1</span>;</span><br><span class="line">carrier_cos = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t1);</span><br><span class="line">carrier_sin = <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t1);</span><br><span class="line"></span><br><span class="line">recv_sig_I = recv_sig_add_0 .* carrier_cos;</span><br><span class="line">recv_sig_Q = recv_sig_add_0 .* carrier_sin;</span><br><span class="line"></span><br><span class="line"><span class="comment">% recv_sig_complex = complex(recv_sig_I, recv_sig_Q);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------匹配滤波--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% mg_up_flip = upsample(fliplr(ms&#x27;), sps); %反转序列后上采样</span></span><br><span class="line"><span class="comment">% fir_m = conv(mg_up_flip, fir_rcos); %本地广义成形</span></span><br><span class="line"><span class="comment">% mg_up_xcorr = conv(mg_up_flip, fir_rcos, &#x27;same&#x27;); %对m序列进行相关</span></span><br><span class="line"></span><br><span class="line">r_bx_I = conv(recv_sig_I, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line">r_bx_Q = conv(recv_sig_Q, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line"></span><br><span class="line">r_complex = <span class="built_in">complex</span>(r_bx_I, r_bx_Q);</span><br><span class="line"><span class="comment">%-----------------------E P L码--------------------------%</span></span><br><span class="line"><span class="comment">% mg_up = upsample(ms.&#x27;, sps);</span></span><br><span class="line"><span class="comment">% l = length(mg_up);</span></span><br><span class="line"><span class="comment">% % l = length(mg_up_xcorr);</span></span><br><span class="line"><span class="comment">% mg_up_e = circshift(mg_up, -l / 2 - 1); %左移,超前</span></span><br><span class="line"><span class="comment">% mg_up_p = mg_up;</span></span><br><span class="line"><span class="comment">% mg_up_l = circshift(mg_up, l / 2 + 1); %右移,滞后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第二种途径</span></span><br><span class="line">mg_e = <span class="built_in">circshift</span>(ms.&#x27;, - (p + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">mg_l = <span class="built_in">circshift</span>(ms.&#x27;, (p + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">mg_up_e = upsample(mg_e, sps);</span><br><span class="line">mg_up_l = upsample(mg_l, sps);</span><br><span class="line">mg_up_p = upsample(ms.&#x27;, sps);</span><br><span class="line">l = <span class="built_in">length</span>(mg_up_p);</span><br><span class="line"><span class="comment">%-----------------------码环--------------------------%</span></span><br><span class="line">ec = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line"><span class="comment">%环路滤波器参数设置</span></span><br><span class="line">BL = <span class="number">100</span>; <span class="comment">%环路带宽</span></span><br><span class="line">w_nf = BL * <span class="number">0.53</span>;</span><br><span class="line">K_d = <span class="number">1</span>;</span><br><span class="line">K_1 = <span class="number">1</span>;</span><br><span class="line">T = <span class="number">1</span> / symbol_rate;</span><br><span class="line">K_f = <span class="number">1</span>;</span><br><span class="line">w_mid = <span class="built_in">zeros</span>(<span class="number">1</span>, l); <span class="comment">% 环路滤波器中间变量</span></span><br><span class="line">w = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">L = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line">delta_P = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">P = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:l - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%%相关运算</span></span><br><span class="line">    mg_up_p = <span class="built_in">fliplr</span>(<span class="built_in">circshift</span>(mg_up_p, P));</span><br><span class="line">    sig_xcorr_I_P = conv(r_bx_I, mg_up_p, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_Q_P = conv(r_bx_Q, mg_up_p, <span class="string">&quot;same&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mg_up_e = <span class="built_in">circshift</span>(mg_up_p, -l / <span class="number">2</span>);</span><br><span class="line">    mg_up_l = <span class="built_in">circshift</span>(mg_up_p, l / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    sig_xcorr_I_E = conv(r_bx_I, mg_up_e, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_Q_E = conv(r_bx_Q, mg_up_e, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_I_L = conv(r_bx_I, mg_up_l, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">    sig_xcorr_Q_L = conv(r_bx_Q, mg_up_l, <span class="string">&quot;same&quot;</span>);</span><br><span class="line"></span><br><span class="line">    E(k) = <span class="built_in">sqrt</span>(sig_xcorr_I_E(k)^<span class="number">2</span> + sig_xcorr_Q_E(k)^<span class="number">2</span>);</span><br><span class="line">    L(k) = <span class="built_in">sqrt</span>(sig_xcorr_I_L(k)^<span class="number">2</span> + sig_xcorr_Q_L(k)^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%ec(k) = 0.5*(E(k)^2 - L(k)^2) / (E(k)^2 + L(k)^2); %超前减滞后功率鉴相法</span></span><br><span class="line">    ec(k) = <span class="number">0.5</span> * (E - L) / (E + L); <span class="comment">%超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%delta_cp(k) = 1/2 * (E - L) / (E + L); %超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%点积功率鉴相器</span></span><br><span class="line">    <span class="comment">%ec(k) = (sig_xcorr_I_E(k) - sig_xcorr_I_L(k)) * sig_xcorr_I_L(k) + (sig_xcorr_Q_E(k) - sig_xcorr_Q_L(k)) * sig_xcorr_Q_L(k);</span></span><br><span class="line">    <span class="comment">%ec(k) = ec(k) / (sig_xcorr_I_P(k)^2 + sig_xcorr_Q_P(k)^2);</span></span><br><span class="line">    <span class="comment">%环路滤波器</span></span><br><span class="line">    w_mid(k + <span class="number">1</span>) = w_mid(k) + (w_nf^<span class="number">2</span> * T) * (ec(k) * K_d * K_1);</span><br><span class="line">    w(k + <span class="number">1</span>) = w(k) + T * w_mid(k + <span class="number">1</span>) + (<span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T) * (ec(k) * K_d * K_1);</span><br><span class="line"></span><br><span class="line">    delta_P(k + <span class="number">1</span>) = K_f * (w_mid(k + <span class="number">1</span>) + <span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T * ec(k)) / (<span class="number">2</span> * <span class="built_in">pi</span>);</span><br><span class="line">    P = <span class="built_in">round</span>(delta_P);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>(sig_xcorr_I_P);</span><br><span class="line"></span><br><span class="line"><span class="comment">% y_decision = sig_xcorr_I_P(1008:p * sps:end) &gt; 0;</span></span><br><span class="line">y_decision = sig_xcorr_I_P(p*sps-sps:p * sps:<span class="keyword">end</span>) &gt; <span class="number">0</span>;</span><br><span class="line">error_bit = biterr(y_decision, data);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="没有上下变频">没有上下变频</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 相关仿真-----------码环纠正</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">warning off;</span><br><span class="line"><span class="comment">%-----------------------参数设置--------------------------%</span></span><br><span class="line"></span><br><span class="line">fs = <span class="number">16000</span>; <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">4000</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10000</span>; <span class="comment">%数据长度</span></span><br><span class="line">symbol_rate = <span class="number">4000</span>; <span class="comment">%符号速率</span></span><br><span class="line"><span class="comment">%-----------------------发送端--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------发送序列+映射-----------------------%</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------生成m序列------------------------%</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>); <span class="comment">%ms列向量</span></span><br><span class="line"></span><br><span class="line">m_1 = ms .* data_bio;</span><br><span class="line">Y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * data_len]); <span class="comment">%扩频完之后的数据</span></span><br><span class="line"></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(Y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------根升余弦滤波成型---------------------%</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&quot;same&quot;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------上变频--------------------------%</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">1</span>:<span class="built_in">length</span>(data_bx);</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier .* data_bx; <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------接收端-----------------------------%</span></span><br><span class="line"><span class="comment">%r_n = awgn(s_up, -20, &#x27;measured&#x27;); %添加噪声</span></span><br><span class="line">r_n = data_bx;</span><br><span class="line">N = <span class="number">3</span>; <span class="comment">%填0的个数</span></span><br><span class="line">recv_sig_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n]; <span class="comment">%对序列进行延时操作，前面补0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------正交下变频--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% t1 = 1:length(recv_sig_add_0);</span></span><br><span class="line"><span class="comment">% carrier_cos = cos(2 * pi * fc / fs * t1);</span></span><br><span class="line"><span class="comment">% carrier_sin = sin(2 * pi * fc / fs * t1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% recv_sig_I = recv_sig_add_0 .* carrier_cos;</span></span><br><span class="line"><span class="comment">% recv_sig_Q = recv_sig_add_0 .* carrier_sin;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% recv_sig_complex = complex(recv_sig_I, recv_sig_Q);</span></span><br><span class="line"></span><br><span class="line">recv_sig_I = recv_sig_add_0;</span><br><span class="line">recv_sig_Q = recv_sig_add_0 * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------匹配滤波--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% mg_up_flip = upsample(fliplr(ms&#x27;), sps); %反转序列后上采样</span></span><br><span class="line"><span class="comment">% fir_m = conv(mg_up_flip, fir_rcos); %本地广义成形</span></span><br><span class="line"><span class="comment">% mg_up_xcorr = conv(mg_up_flip, fir_rcos, &#x27;same&#x27;); %对m序列进行相关</span></span><br><span class="line"></span><br><span class="line">r_bx_I = conv(recv_sig_I, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line">r_bx_Q = conv(recv_sig_Q, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------E P L码--------------------------%</span></span><br><span class="line"><span class="comment">%第二种途径</span></span><br><span class="line">mg_up_p = upsample(ms.&#x27;, sps);</span><br><span class="line">l = <span class="built_in">length</span>(mg_up_p);</span><br><span class="line">mg_up_l = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">mg_up_e = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------码环--------------------------%</span></span><br><span class="line">ec = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line"><span class="comment">%环路滤波器参数设置</span></span><br><span class="line">BL = <span class="number">20</span>; <span class="comment">%环路带宽</span></span><br><span class="line"><span class="comment">% w_nf = BL * 0.53;</span></span><br><span class="line">w_nf = BL * <span class="number">2</span>;</span><br><span class="line">K_d = <span class="number">1</span>;</span><br><span class="line">K_1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">% T = 1 / symbol_rate;</span></span><br><span class="line">T = <span class="number">1</span>/<span class="number">1000</span>;</span><br><span class="line">K_f = <span class="number">1</span>;</span><br><span class="line">w_mid = <span class="built_in">zeros</span>(<span class="number">1</span>, l); <span class="comment">% 环路滤波器中间变量</span></span><br><span class="line">w = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">L = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line">delta_P = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">P = <span class="number">0</span>;</span><br><span class="line">sig_xcorr_I_P = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">sig_xcorr_Q_P = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">sig_xcorr_I_E = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">sig_xcorr_Q_E = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">sig_xcorr_I_L = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line">sig_xcorr_Q_L = <span class="built_in">zeros</span>(<span class="number">1</span>, l);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:data_len + <span class="number">1</span></span><br><span class="line">    <span class="comment">%%截位</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> * l &lt; <span class="built_in">length</span>(r_bx_I))</span><br><span class="line">        r_bx_sym_I = r_bx_I((<span class="built_in">i</span> - <span class="number">1</span>) * l + <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span> * l);</span><br><span class="line">        r_bx_sym_Q = r_bx_Q((<span class="built_in">i</span> - <span class="number">1</span>) * l + <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span> * l);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">i</span> * l - <span class="built_in">length</span>(r_bx_I));</span><br><span class="line">        r_bx_sym_I = [r_bx_I((<span class="built_in">i</span> - <span class="number">1</span>) * l + <span class="number">1</span>:<span class="number">1</span>:<span class="keyword">end</span>), b];</span><br><span class="line">        r_bx_sym_Q = [r_bx_Q((<span class="built_in">i</span> - <span class="number">1</span>) * l + <span class="number">1</span>:<span class="number">1</span>:<span class="keyword">end</span>), b];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    mg_up_p = <span class="built_in">circshift</span>(mg_up_p, -P);</span><br><span class="line">    mg_up_e = <span class="built_in">circshift</span>(mg_up_p, -sps / <span class="number">2</span>);</span><br><span class="line">    mg_up_l = <span class="built_in">circshift</span>(mg_up_p, sps / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    sig_xcorr_I_P(<span class="built_in">i</span>) = sum(mg_up_p .* r_bx_sym_I);</span><br><span class="line">    sig_xcorr_Q_P(<span class="built_in">i</span>) = sum(mg_up_p .* r_bx_sym_Q);</span><br><span class="line">    sig_xcorr_I_E(<span class="built_in">i</span>) = sum(mg_up_e .* r_bx_sym_I);</span><br><span class="line">    sig_xcorr_Q_E(<span class="built_in">i</span>) = sum(mg_up_e .* r_bx_sym_Q);</span><br><span class="line">    sig_xcorr_I_L(<span class="built_in">i</span>) = sum(mg_up_l .* r_bx_sym_I);</span><br><span class="line">    sig_xcorr_Q_L(<span class="built_in">i</span>) = sum(mg_up_l .* r_bx_sym_Q);</span><br><span class="line"></span><br><span class="line">    E(<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(sig_xcorr_I_E(<span class="built_in">i</span>)^<span class="number">2</span> + sig_xcorr_Q_E(<span class="built_in">i</span>)^<span class="number">2</span>);</span><br><span class="line">    L(<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(sig_xcorr_I_L(<span class="built_in">i</span>)^<span class="number">2</span> + sig_xcorr_Q_L(<span class="built_in">i</span>)^<span class="number">2</span>);</span><br><span class="line">    <span class="comment">%ec(i) = 0.5*(E(i)^2 - L(i)^2) / (E(i)^2 + L(i)^2); %超前减滞后功率鉴相法</span></span><br><span class="line">    ec(<span class="built_in">i</span>) = <span class="number">0.5</span> * (E(<span class="built_in">i</span>) - L(<span class="built_in">i</span>)) / (E(<span class="built_in">i</span>) + L(<span class="built_in">i</span>)); <span class="comment">%超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%delta_cp(k) = 1/2 * (E - L) / (E + L); %超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%点积功率鉴相器</span></span><br><span class="line">    <span class="comment">%ec(k) = (sig_xcorr_I_E(k) - sig_xcorr_I_L(k)) * sig_xcorr_I_L(k) + (sig_xcorr_Q_E(k) - sig_xcorr_Q_L(k)) * sig_xcorr_Q_L(k);</span></span><br><span class="line">    <span class="comment">%ec(k) = ec(k) / (sig_xcorr_I_P(k)^2 + sig_xcorr_Q_P(k)^2);</span></span><br><span class="line">    <span class="comment">%环路滤波器</span></span><br><span class="line">    w_mid(<span class="built_in">i</span> + <span class="number">1</span>) = w_mid(<span class="built_in">i</span>) + (w_nf^<span class="number">2</span> * T) * (ec(<span class="built_in">i</span>) * K_d * K_1);</span><br><span class="line">    w(<span class="built_in">i</span> + <span class="number">1</span>) = w(<span class="built_in">i</span>) + T * w_mid(<span class="built_in">i</span> + <span class="number">1</span>) + (<span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T) * (ec(<span class="built_in">i</span>) * K_d * K_1);</span><br><span class="line"></span><br><span class="line">    delta_P(<span class="built_in">i</span> + <span class="number">1</span>) = K_f * (w_mid(<span class="built_in">i</span> + <span class="number">1</span>) + <span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T * ec(<span class="built_in">i</span>)) / (<span class="number">2</span> * <span class="built_in">pi</span>);</span><br><span class="line">    P = <span class="built_in">round</span>(delta_P(<span class="built_in">i</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">% PII(i) = round(delta_P(i + 1)*4/pi);</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% plot(PII);</span></span><br><span class="line"><span class="comment">% y_decision = sig_xcorr_I_P(1008:p * sps:end) &gt; 0;</span></span><br><span class="line">y_decision = sig_xcorr_I_P(<span class="number">1</span>:<span class="number">1</span>:data_len) &gt; <span class="number">0</span>;</span><br><span class="line">error_bit = biterr(y_decision, data);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="低信噪比进行积累">低信噪比进行积累</h3><blockquote><p>核心代码：<br>r_n = awgn(data_bx, -20, ‘measured’); %添加噪声</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 相关仿真-----------码环纠正</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">warning off;</span><br><span class="line"><span class="comment">%-----------------------参数设置--------------------------%</span></span><br><span class="line"></span><br><span class="line">fs = <span class="number">16000</span>; <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">4000</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1e5</span>; <span class="comment">%数据长5</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>; <span class="comment">%符号速率</span></span><br><span class="line"><span class="comment">%-----------------------发送端--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------发送序列+映射-----------------------%</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%生成0/1序列</span></span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line">data_bio = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------生成m序列------------------------%</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>); <span class="comment">%ms列向量</span></span><br><span class="line"></span><br><span class="line">m_1 = ms .* data_bio;</span><br><span class="line">Y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * data_len]); <span class="comment">%扩频完之后的数据</span></span><br><span class="line"></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(Y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------根升余弦滤波成型---------------------%</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&quot;same&quot;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------接收端-----------------------------%</span></span><br><span class="line"></span><br><span class="line">r_n = awgn(data_bx, <span class="number">-20</span>, <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%添加噪声</span></span><br><span class="line"><span class="comment">%r_n = s_up;</span></span><br><span class="line">N = <span class="number">2</span>; <span class="comment">%填0的个数</span></span><br><span class="line">recv_sig_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n]; <span class="comment">%对序列进行延时操作，前面补0</span></span><br><span class="line"></span><br><span class="line">recv_sig_I = recv_sig_add_0;</span><br><span class="line">recv_sig_Q = recv_sig_add_0 * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------匹配滤波--------------------------%</span></span><br><span class="line">r_bx_I = conv(recv_sig_I, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line">r_bx_Q = conv(recv_sig_Q, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------E P L码--------------------------%</span></span><br><span class="line"></span><br><span class="line">mg_up_p = upsample(ms.&#x27;, sps);</span><br><span class="line">len = <span class="built_in">length</span>(mg_up_p);</span><br><span class="line">mg_up_l = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(mg_up_p));</span><br><span class="line">mg_up_e = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(mg_up_p));</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------码环--------------------------%</span></span><br><span class="line">ec = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">%环路滤波器参数设置</span></span><br><span class="line">BL = <span class="number">200</span>; <span class="comment">%环路带宽</span></span><br><span class="line">w_nf = BL * <span class="number">0.53</span>;</span><br><span class="line"><span class="comment">% w_nf = BL * 2;</span></span><br><span class="line">K_d = <span class="number">1</span>;</span><br><span class="line">K_1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">% T = 1 / symbol_rate;</span></span><br><span class="line">T = <span class="number">1</span>/<span class="number">1000</span>;</span><br><span class="line">K_f = <span class="number">1</span>;</span><br><span class="line">w_mid = <span class="built_in">zeros</span>(<span class="number">1</span>, len); <span class="comment">% 环路滤波器中间变量</span></span><br><span class="line">w = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">E = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">L = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line">delta_P = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">P = <span class="number">0</span>;</span><br><span class="line">sig_xcorr_I_P = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">sig_xcorr_Q_P = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">sig_xcorr_I_E = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">sig_xcorr_Q_E = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">sig_xcorr_I_L = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">sig_xcorr_Q_L = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line">ec_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:data_len</span><br><span class="line">    <span class="comment">%%截位</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> * len &lt; <span class="built_in">length</span>(r_bx_I))</span><br><span class="line">        r_bx_sym_I = r_bx_I((<span class="built_in">i</span> - <span class="number">1</span>) * len + <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span> * len);</span><br><span class="line">        r_bx_sym_Q = r_bx_Q((<span class="built_in">i</span> - <span class="number">1</span>) * len + <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span> * len);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    mg_up_p = <span class="built_in">circshift</span>(mg_up_p, -P);</span><br><span class="line">    mg_up_e = <span class="built_in">circshift</span>(mg_up_p, -sps / <span class="number">2</span>);</span><br><span class="line">    mg_up_l = <span class="built_in">circshift</span>(mg_up_p, sps / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    sig_xcorr_I_P(<span class="built_in">i</span>) = sum(mg_up_p .* r_bx_sym_I);</span><br><span class="line">    sig_xcorr_Q_P(<span class="built_in">i</span>) = sum(mg_up_p .* r_bx_sym_Q);</span><br><span class="line">    sig_xcorr_I_E(<span class="built_in">i</span>) = sum(mg_up_e .* r_bx_sym_I);</span><br><span class="line">    sig_xcorr_Q_E(<span class="built_in">i</span>) = sum(mg_up_e .* r_bx_sym_Q);</span><br><span class="line">    sig_xcorr_I_L(<span class="built_in">i</span>) = sum(mg_up_l .* r_bx_sym_I);</span><br><span class="line">    sig_xcorr_Q_L(<span class="built_in">i</span>) = sum(mg_up_l .* r_bx_sym_Q);</span><br><span class="line"></span><br><span class="line">    E(<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(sig_xcorr_I_E(<span class="built_in">i</span>)^<span class="number">2</span> + sig_xcorr_Q_E(<span class="built_in">i</span>)^<span class="number">2</span>);</span><br><span class="line">    L(<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(sig_xcorr_I_L(<span class="built_in">i</span>)^<span class="number">2</span> + sig_xcorr_Q_L(<span class="built_in">i</span>)^<span class="number">2</span>);</span><br><span class="line">    <span class="comment">%     E(i) = sig_xcorr_I_E(i) + sig_xcorr_Q_E(i);</span></span><br><span class="line">    <span class="comment">%     L(i) = sig_xcorr_I_L(i) + sig_xcorr_Q_L(i);</span></span><br><span class="line">    <span class="comment">%ec(i) = 0.5*(E(i)^2 - L(i)^2) / (E(i)^2 + L(i)^2); %超前减滞后功率鉴相法</span></span><br><span class="line">    ec(<span class="built_in">i</span>) = <span class="number">0.5</span> * (E(<span class="built_in">i</span>) - L(<span class="built_in">i</span>)) / (E(<span class="built_in">i</span>) + L(<span class="built_in">i</span>)); <span class="comment">%超前减滞后幅值法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">i</span> &gt; <span class="number">1</span>)</span><br><span class="line">        ec_sum(<span class="built_in">i</span>) = ec_sum(<span class="built_in">i</span> - <span class="number">1</span>) + ec(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ec_sum(<span class="built_in">i</span>) = ec_sum(<span class="built_in">i</span>) + ec(<span class="built_in">i</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%delta_cp(k) = 1/2 * (E - L) / (E + L); %超前减滞后幅值法</span></span><br><span class="line">    <span class="comment">%点积功率鉴相器</span></span><br><span class="line">    <span class="comment">%ec(k) = (sig_xcorr_I_E(k) - sig_xcorr_I_L(k)) * sig_xcorr_I_L(k) + (sig_xcorr_Q_E(k) - sig_xcorr_Q_L(k)) * sig_xcorr_Q_L(k);</span></span><br><span class="line">    <span class="comment">%ec(k) = ec(k) / (sig_xcorr_I_P(k)^2 + sig_xcorr_Q_P(k)^2);</span></span><br><span class="line">    <span class="comment">%环路滤波器</span></span><br><span class="line">    <span class="comment">%     w_mid(i + 1) = w_mid(i) + (w_nf^2 * T) * (ec(i) * K_d * K_1);</span></span><br><span class="line">    <span class="comment">%     w(i + 1) = w(i) + T * w_mid(i + 1) + (sqrt(2) * w_nf * T) * (ec(i) * K_d * K_1);</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">%     delta_P(i + 1) = K_f * (w_mid(i + 1) + sqrt(2) * w_nf * T * ec(i)) / (2 * pi);</span></span><br><span class="line">    <span class="comment">%  z(i + 1) = round(delta_P(i + 1));</span></span><br><span class="line">    w(<span class="built_in">i</span> + <span class="number">1</span>) = (<span class="number">1</span> - <span class="number">0.05</span>) * w(<span class="built_in">i</span>) + <span class="number">0.05</span> * ec(<span class="built_in">i</span>);</span><br><span class="line">    delta_P(<span class="built_in">i</span> + <span class="number">1</span>) = w(<span class="built_in">i</span> + <span class="number">1</span>);</span><br><span class="line">    P = <span class="built_in">round</span>(delta_P(<span class="built_in">i</span> + <span class="number">1</span>) * sps);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">y_decision = sig_xcorr_I_P(<span class="number">1</span>:<span class="number">1</span>:data_len) &gt; <span class="number">0</span>;</span><br><span class="line">error_bit = biterr(y_decision, data);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="积累">积累</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 相关仿真-----------码环纠正</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line">warning off;</span><br><span class="line"><span class="comment">%-----------------------参数设置--------------------------%</span></span><br><span class="line"></span><br><span class="line">fs = <span class="number">16000</span>; <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">4000</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10000</span>; <span class="comment">%数据长度</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>; <span class="comment">%符号速率</span></span><br><span class="line"><span class="comment">%-----------------------发送端--------------------------%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%--------------------发送序列+映射-----------------------%</span></span><br><span class="line"></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%生成0/1序列</span></span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line">data_bio = (data <span class="number">-1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------生成m序列------------------------%</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span> ^ n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>); <span class="comment">%ms列向量</span></span><br><span class="line"></span><br><span class="line">m_1 = ms .* data_bio;</span><br><span class="line">Y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * data_len]); <span class="comment">%扩频完之后的数据</span></span><br><span class="line"></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(Y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-------------------根升余弦滤波成型---------------------%</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&quot;same&quot;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------接收端-----------------------------%</span></span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% errbit_average = zeros(1, 10);</span></span><br><span class="line"></span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    snr(k) = ebn0 + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span> * <span class="built_in">log10</span>(sps) <span class="number">-10</span> * <span class="built_in">log10</span>(p);</span><br><span class="line">    r_n = awgn(data_bx, snr(k), <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%添加噪声</span></span><br><span class="line">    <span class="comment">%r_n = s_up;</span></span><br><span class="line">    N = <span class="number">1</span>; <span class="comment">%填0的个数</span></span><br><span class="line">    recv_sig_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n]; <span class="comment">%对序列进行延时操作，前面补0</span></span><br><span class="line"></span><br><span class="line">    recv_sig_I = recv_sig_add_0;</span><br><span class="line">    recv_sig_Q = recv_sig_add_0 * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-----------------------匹配滤波--------------------------%</span></span><br><span class="line">    r_bx_I = conv(recv_sig_I, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line">    r_bx_Q = conv(recv_sig_Q, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%接收匹配滤波器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%-----------------------E P L码--------------------------%</span></span><br><span class="line"></span><br><span class="line">    mg_up_p = upsample(ms.&#x27;, sps);</span><br><span class="line">    len = <span class="built_in">length</span>(mg_up_p);</span><br><span class="line">    mg_up_l = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(mg_up_p));</span><br><span class="line">    mg_up_e = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(mg_up_p));</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-----------------------码环--------------------------%</span></span><br><span class="line">    ec = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%环路滤波器参数设置</span></span><br><span class="line">    <span class="comment">%     BL = 300; %环路带宽</span></span><br><span class="line">    <span class="comment">%     w_nf = BL * 0.53;</span></span><br><span class="line">    BL = <span class="number">1.3</span>;</span><br><span class="line">    w_nf = BL * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">% w_nf = BL * 2;</span></span><br><span class="line">    K_d = <span class="number">1</span>;</span><br><span class="line">    K_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">% T = 1 / symbol_rate;</span></span><br><span class="line">    T = <span class="number">1</span>/<span class="number">1000</span>;</span><br><span class="line">    K_f = <span class="number">1</span>;</span><br><span class="line">    w_mid = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len); <span class="comment">% 环路滤波器中间变量</span></span><br><span class="line">    w = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line">    E = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line">    L = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line"></span><br><span class="line">    delta_P = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    P = <span class="number">0</span>;</span><br><span class="line">    sig_xcorr_I_P = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_Q_P = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_I_E = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_Q_E = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_I_L = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_Q_L = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%-----------------------积累变量</span></span><br><span class="line">    sig_xcorr_I_E_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_Q_E_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_I_L_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line">    sig_xcorr_Q_L_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, len);</span><br><span class="line"></span><br><span class="line">    E_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line">    L_sum = <span class="built_in">zeros</span>(<span class="number">1</span>, data_len);</span><br><span class="line"></span><br><span class="line">    i_sum = <span class="number">4</span>; <span class="comment">%积累的次数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:data_len</span><br><span class="line">        <span class="comment">%%截位</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> * len &lt; <span class="built_in">length</span>(r_bx_I))</span><br><span class="line">            r_bx_sym_I = r_bx_I((<span class="built_in">i</span> - <span class="number">1</span>) * len + <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span> * len);</span><br><span class="line">            r_bx_sym_Q = r_bx_Q((<span class="built_in">i</span> - <span class="number">1</span>) * len + <span class="number">1</span>:<span class="number">1</span>:<span class="built_in">i</span> * len);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        mg_up_p = <span class="built_in">circshift</span>(mg_up_p, -P);</span><br><span class="line">        mg_up_e = <span class="built_in">circshift</span>(mg_up_p, -sps / <span class="number">2</span>);</span><br><span class="line">        mg_up_l = <span class="built_in">circshift</span>(mg_up_p, sps / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        sig_xcorr_I_P(<span class="built_in">i</span>) = sum(mg_up_p .* r_bx_sym_I);</span><br><span class="line">        sig_xcorr_Q_P(<span class="built_in">i</span>) = sum(mg_up_p .* r_bx_sym_Q);</span><br><span class="line">        sig_xcorr_I_E(<span class="built_in">i</span>) = sum(mg_up_e .* r_bx_sym_I);</span><br><span class="line">        sig_xcorr_Q_E(<span class="built_in">i</span>) = sum(mg_up_e .* r_bx_sym_Q);</span><br><span class="line">        sig_xcorr_I_L(<span class="built_in">i</span>) = sum(mg_up_l .* r_bx_sym_I);</span><br><span class="line">        sig_xcorr_Q_L(<span class="built_in">i</span>) = sum(mg_up_l .* r_bx_sym_Q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> == <span class="number">1</span> || <span class="built_in">mod</span>(<span class="built_in">i</span>, i_sum) == <span class="number">0</span>)</span><br><span class="line">            sig_xcorr_I_E_sum(<span class="built_in">i</span>) = sig_xcorr_I_E(<span class="built_in">i</span>);</span><br><span class="line">            sig_xcorr_Q_E_sum(<span class="built_in">i</span>) = sig_xcorr_Q_E(<span class="built_in">i</span>);</span><br><span class="line">            sig_xcorr_I_L_sum(<span class="built_in">i</span>) = sig_xcorr_I_L(<span class="built_in">i</span>);</span><br><span class="line">            sig_xcorr_Q_L_sum(<span class="built_in">i</span>) = sig_xcorr_Q_L(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sig_xcorr_I_E_sum(<span class="built_in">i</span>) = sig_xcorr_I_E(<span class="built_in">i</span>) + sig_xcorr_I_E_sum(<span class="built_in">i</span> - <span class="number">1</span>);</span><br><span class="line">            sig_xcorr_Q_E_sum(<span class="built_in">i</span>) = sig_xcorr_Q_E(<span class="built_in">i</span>) + sig_xcorr_Q_E_sum(<span class="built_in">i</span> - <span class="number">1</span>);</span><br><span class="line">            sig_xcorr_I_L_sum(<span class="built_in">i</span>) = sig_xcorr_I_L(<span class="built_in">i</span>) + sig_xcorr_I_L_sum(<span class="built_in">i</span> - <span class="number">1</span>);</span><br><span class="line">            sig_xcorr_Q_L_sum(<span class="built_in">i</span>) = sig_xcorr_Q_L(<span class="built_in">i</span>) + sig_xcorr_Q_L_sum(<span class="built_in">i</span> - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">mod</span>(<span class="built_in">i</span>, i_sum) == <span class="number">0</span>)</span><br><span class="line">            E(<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(sig_xcorr_I_E(<span class="built_in">i</span>) ^ <span class="number">2</span> + sig_xcorr_Q_E(<span class="built_in">i</span>) ^ <span class="number">2</span>);</span><br><span class="line">            L(<span class="built_in">i</span>) = <span class="built_in">sqrt</span>(sig_xcorr_I_L(<span class="built_in">i</span>) ^ <span class="number">2</span> + sig_xcorr_Q_L(<span class="built_in">i</span>) ^ <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            ec(<span class="built_in">i</span>) = (E(<span class="built_in">i</span>) - L(<span class="built_in">i</span>)) / (E(<span class="built_in">i</span>) + L(<span class="built_in">i</span>)); <span class="comment">%超前减滞后幅值法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">%                 w(i + 1) = (1 - 0.25) * w(i) + 0.25 * ec(i);</span></span><br><span class="line">            <span class="comment">%                 delta_P(i + 1) = w(i + 1);</span></span><br><span class="line">            <span class="comment">%                 P = round(delta_P(i + 1) * sps);</span></span><br><span class="line">            w_mid(<span class="built_in">i</span> + <span class="number">1</span>) = w_mid(<span class="built_in">i</span>) + (w_nf ^ <span class="number">2</span> * T) * (ec(<span class="built_in">i</span>) * K_d * K_1);</span><br><span class="line">            w(<span class="built_in">i</span> + <span class="number">1</span>) = w(<span class="built_in">i</span>) + T * w_mid(<span class="built_in">i</span> + <span class="number">1</span>) + (<span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T) * (ec(<span class="built_in">i</span>) * K_d * K_1);</span><br><span class="line">            delta_P(<span class="built_in">i</span> + <span class="number">1</span>) = K_f * (w_mid(<span class="built_in">i</span> + <span class="number">1</span>) + <span class="built_in">sqrt</span>(<span class="number">2</span>) * w_nf * T * ec(<span class="built_in">i</span>)) / (<span class="number">2</span> * <span class="built_in">pi</span>);</span><br><span class="line">            P = <span class="built_in">round</span>(delta_P(<span class="built_in">i</span> + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    y_decision = sig_xcorr_I_P(<span class="number">1</span>:<span class="number">1</span>:data_len) &gt; <span class="number">0</span>;</span><br><span class="line">    errbit(k) = (biterr(y_decision, data)) / data_len;</span><br><span class="line">    k = k + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">ber_theory = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>, ebn0 / <span class="number">10</span>))); <span class="comment">%理论误码率</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(ebn0, ber_theory, <span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">grid on; <span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">semilogy(ebn0, errbit, <span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">grid on; <span class="built_in">hold</span> on;</span><br><span class="line">xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>); ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;BPSK-DSSS误码率曲线图&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>, <span class="string">&#x27;bpsk-dsss仿真误码率&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/06%E7%A0%81%E7%8E%AF/%E7%A0%81%E7%8E%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_MADY4ueoZd.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FPGA发端设计</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>接收机与FPGA</h1><h2 id="目录">目录</h2><ul><li><a href="#%E6%8E%A5%E6%94%B6%E6%9C%BA%E4%B8%8Efpga">接收机与FPGA</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82">作业要求</a></li><li><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">具体实现</a><ul><li><a href="#%E5%8F%91%E9%80%81%E7%9A%8410101%E6%95%B0%E6%8D%AE%E4%BB%8Etxt%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96">发送的10101数据从txt文件中读取</a></li><li><a href="#%E4%BD%BF%E7%94%A8fir%E6%A0%B8%E8%BF%9B%E8%A1%8C%E6%A0%B9%E5%8D%87%E4%BD%99%E5%BC%A6">使用FIR核进行根升余弦</a></li><li><a href="#%E9%87%87%E7%94%A8dds%E7%94%9F%E6%88%90%E4%B8%AD%E9%A2%91%E8%BD%BD%E6%B3%A2">采用DDS生成中频载波</a></li><li><a href="#%E4%B9%98%E6%B3%95%E5%99%A8%E5%AE%9E%E7%8E%B0%E4%B8%8A%E5%8F%98%E9%A2%91">乘法器实现上变频</a></li><li><a href="#%E7%BB%93%E6%9E%9C%E9%AA%8C%E8%AF%81">结果验证</a></li><li><a href="#%E9%99%84%E5%BD%95">附录</a></li><li><a href="#matlab">MATLAB</a></li><li><a href="#verilog">Verilog</a></li></ul></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%8F%8A%E6%80%9D%E8%80%83">代码优化及思考</a><ul><li><a href="#%E7%9B%AE%E5%BD%95-1">目录</a><ul><li><a href="#hdl">HDL</a></li><li><a href="#ip%E6%A0%B8%E8%AE%BE%E7%BD%AEfir">IP核设置（FIR）</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E9%99%84%E5%BD%95">代码附录</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0">代码学习</a></li></ul></li></ul></li></ul><h2 id="作业要求">作业要求</h2><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_1v64rbhHXb.png" alt></p><h2 id="具体实现">具体实现</h2><h3 id="发送的10101数据从txt文件中读取">发送的10101数据从txt文件中读取</h3><ul><li><strong>MATLAB仿真</strong><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data_len = <span class="number">1024</span>;        <span class="comment">%数据长度</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len); </span><br><span class="line">fid = fopen(<span class="string">&#x27;send_data.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">%创建txt文件</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(data)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">length</span>(data))</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d\n&#x27;</span>,data(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,data(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% fprintf(fid,&#x27;%d\n&#x27;,sin_14bit);</span></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>生成1024个0，1随机数，生成txt文件；<br>生成之后需要对发送序列进行映射，然后上采样，此处设计为4倍上采样</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = importdata(<span class="string">&#x27;send_data.txt&#x27;</span>);</span><br><span class="line">data_1 = (data&#x27;<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">data_up = upsample(data_1,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li><li><strong>Verilog实现</strong><blockquote><p>读取txt文件在仿真文件中实现，映射及上采样代码在设计文件中实现</p></blockquote><ul><li><p>Design文件</p><p><strong>核心代码</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射0变-1 + 4倍上采样</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] data_map = <span class="number">2&#x27;b00</span>;  <span class="comment">//映射加插值后的信号</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt = <span class="number">2&#x27;b00</span>;   <span class="comment">//计数，4为一个周期</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">        data_map &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">        cnt &lt;= <span class="number">2&#x27;b00</span>;       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(cnt)</span><br><span class="line">        <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(data == <span class="number">1&#x27;b1</span>&amp;&amp;data_nd == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                data_map &lt;=<span class="number">2&#x27;b01</span>;</span><br><span class="line">                cnt &lt;= cnt + <span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="keyword">end</span>                            <span class="comment">//data为1时不变</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data_nd == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                data_map &lt;= <span class="number">2&#x27;b11</span>;</span><br><span class="line">                cnt &lt;= cnt +<span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="keyword">end</span>                            <span class="comment">//data为0时变为-1</span></span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt +<span class="number">2&#x27;b01</span>;</span><br><span class="line">            data_map &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">endcase</span>       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure></li><li><p>Testbench文件</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_bpsk_send(</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst;</span><br><span class="line"><span class="keyword">reg</span> data = <span class="number">1&#x27;b0</span>;    </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;    <span class="comment">//50MHz clock</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    #<span class="number">200</span></span><br><span class="line">    rst = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">1</span>-<span class="number">1</span>:<span class="number">0</span>] data_mem [<span class="number">0</span>:<span class="number">1023</span>] ;<span class="comment">//定义一个位宽为2bit，深度为1024的mem</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">     <span class="built_in">$readmemh</span>(<span class="string">&quot;G:/vivado_project/bpsk/bpsk.srcs/sources_1/send_data.txt&quot;</span>,data_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] counter = <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">reg</span> data_nd = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span> (rst|i==<span class="number">1023</span>) <span class="keyword">begin</span></span><br><span class="line">      data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">      i &lt;= <span class="number">0</span>; </span><br><span class="line">      counter &lt;= <span class="number">2&#x27;d0</span>; </span><br><span class="line">      data_nd &lt;= <span class="number">1&#x27;b0</span>;   </span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">case</span>(counter)</span><br><span class="line">         <span class="number">2&#x27;d1</span>:<span class="keyword">begin</span></span><br><span class="line">            data &lt;= data_mem[i];</span><br><span class="line">            i &lt;= i + <span class="number">1</span>;</span><br><span class="line">            counter &lt;= counter + <span class="number">2&#x27;d1</span>;</span><br><span class="line">            data_nd &lt;= <span class="number">1&#x27;b1</span>; <span class="comment">//数据有效使能</span></span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">            counter &lt;= counter + <span class="number">2&#x27;d1</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">23</span>:<span class="number">0</span>] s_up;</span><br><span class="line"></span><br><span class="line">bpsk_send bpsk_send_m(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.data</span>(data),</span><br><span class="line">    <span class="variable">.data_nd</span>(data_nd),</span><br><span class="line"></span><br><span class="line">    <span class="variable">.s_up</span>(s_up)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><p>仿真波形</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_zWhnCiauIL.png" alt></p></li></ul></li></ul><h3 id="使用FIR核进行根升余弦">使用FIR核进行根升余弦</h3><ul><li>Matlab<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">alfs = <span class="number">0.35</span>;            <span class="comment">% 滚降系数</span></span><br><span class="line">osr = <span class="number">4</span>;             </span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);</span><br><span class="line">max_fir_rcos = <span class="built_in">max</span>(<span class="built_in">abs</span>(fir_rcos));</span><br><span class="line">fir_rcos_bit = <span class="built_in">round</span>((<span class="number">2</span>^<span class="number">7</span><span class="number">-1</span>)*fir_rcos/max_fir_rcos); <span class="comment">%8bit量化</span></span><br><span class="line">fid = fopen(<span class="string">&#x27;fir_data.coe&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">%创建COE文件</span></span><br><span class="line">fprintf(fid, <span class="string">&#x27;Radix=10;\n&#x27;</span>);</span><br><span class="line">fprintf(fid, <span class="string">&#x27;CoefData=\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(fir_rcos_bit)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">length</span>(fir_rcos_bit))</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d\n&#x27;</span>,fir_rcos_bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,fir_rcos_bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% fprintf(fid,&#x27;%d\n&#x27;,sin_14bit);</span></span><br><span class="line">fclose(fid);</span><br><span class="line"></span><br><span class="line">data_bx = conv(fir_rcos_bit,data_up);                 <span class="comment">%通过滤波器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>verilog实现<ul><li><p>Design</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根升余弦滤波FIR</span></span><br><span class="line"><span class="keyword">wire</span> s_axis_data_tready;</span><br><span class="line"><span class="keyword">wire</span> m_axis_data_tvalid;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] fir_out;</span><br><span class="line">shape_fir shape_fir_m (</span><br><span class="line">  <span class="variable">.aclk</span>(clk),                              <span class="comment">// input wire aclk</span></span><br><span class="line">  <span class="variable">.s_axis_data_tvalid</span>(<span class="number">1&#x27;b1</span>),  <span class="comment">// input wire s_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.s_axis_data_tready</span>(s_axis_data_tready),  <span class="comment">// output wire s_axis_data_tready</span></span><br><span class="line">  <span class="variable">.s_axis_data_tdata</span>(&#123;<span class="number">6&#x27;b0</span>,data_map&#125;),    <span class="comment">// input wire [7 : 0] s_axis_data_tdata</span></span><br><span class="line">  <span class="variable">.m_axis_data_tvalid</span>(m_axis_data_tvalid),  <span class="comment">// output wire m_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.m_axis_data_tdata</span>(fir_out)    <span class="comment">// output wire [15 : 0] m_axis_data_tdata</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>IP核设置</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image__UmkxlkUmm.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_Ihnmxp3W6G.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_D3-QTZeSCY.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_P-pVu2iPUn.png" alt></p><p>仿真通道文件和之前一样，为了检查错误，加了一个计数器用于检测</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于观察的计数器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">32</span>:<span class="number">0</span>] cnt_1 = <span class="number">33&#x27;d0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">      cnt_1 &lt;= <span class="number">33&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      cnt_1 &lt;= cnt_1 + <span class="number">33&#x27;d1</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>仿真输出</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_WfW7HIqmwN.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_3aMKoHegSM.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_FHSD7U-dn-.png" alt></p></li></ul></li></ul><h3 id="采用DDS生成中频载波">采用DDS生成中频载波</h3><ul><li>MATLAB<blockquote><p>生成载波序列，并对其量化，产生coe文件</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">16000</span>;            <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">2000</span>;             <span class="comment">% 载波频率</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*t);                      <span class="comment">%载波</span></span><br><span class="line">cos_bit = <span class="built_in">round</span>((<span class="number">2</span>^<span class="number">7</span><span class="number">-1</span>)*carrier/<span class="built_in">max</span>(<span class="built_in">abs</span>(carrier)));<span class="comment">%8bit量化</span></span><br><span class="line"></span><br><span class="line">fid = fopen(<span class="string">&#x27;cos_bit.coe&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">%创建COE文件</span></span><br><span class="line">fprintf(fid, <span class="string">&#x27;memory_initialization_radix=10;\n&#x27;</span>);</span><br><span class="line">fprintf(fid, <span class="string">&#x27;memory_initialization_vector=\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(cos_bit)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">length</span>(cos_bit))</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d\n&#x27;</span>,cos_bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,cos_bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% fprintf(fid,&#x27;%d\n&#x27;,cos_bit);</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="built_in">plot</span>(cos_bit);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>verilog<ul><li><p>design</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//DDS生成中频载波</span><br><span class="line">reg [<span class="number">12</span>:<span class="number">0</span>] addra;</span><br><span class="line">wire [<span class="number">7</span>:<span class="number">0</span>] cos_out;</span><br><span class="line">reg [<span class="number">7</span>:<span class="number">0</span>] cook;</span><br><span class="line">parameter add_M = <span class="number">1</span>;</span><br><span class="line">always @(posedge clk) begin</span><br><span class="line">   <span class="keyword">if</span> (rst|addra==<span class="number">13</span>&#x27;d4119) begin</span><br><span class="line">      addra &lt;= <span class="number">13</span>&#x27;d0; </span><br><span class="line">      cook &lt;= <span class="number">8</span>&#x27;d0;   </span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(cook==<span class="number">8</span>&#x27;d22) begin</span><br><span class="line">      addra &lt;= addra + add_M;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> begin</span><br><span class="line">      addra &lt;= addra;</span><br><span class="line">      cook &lt;= cook + <span class="number">8</span>&#x27;d1;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">cos_local cos_local_m (</span><br><span class="line">  .clka(clk),    // input wire clka</span><br><span class="line">  .ena(<span class="number">1</span>&#x27;b1),      // input wire ena</span><br><span class="line">  .addra(addra),  // input wire [<span class="number">12</span> : <span class="number">0</span>] addra</span><br><span class="line">  .douta(cos_out)  // output wire [<span class="number">7</span> : <span class="number">0</span>] douta</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>仿真输出</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_nC6O7gGtkK.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_8jvOY-_1u1.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_DL5Hh3Jguq.png" alt></p></li></ul></li></ul><h3 id="乘法器实现上变频">乘法器实现上变频</h3><ul><li><p>MATLAB</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s_up = data_bx .* cos_bit;</span><br></pre></td></tr></table></figure></li><li><p>Verilog</p><p>Design</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乘法器</span></span><br><span class="line"><span class="comment">//wire [23:0] s_up;</span></span><br><span class="line">mult_s mult_s_m (</span><br><span class="line">  <span class="variable">.CLK</span>(clk),  <span class="comment">// input wire CLK</span></span><br><span class="line">  <span class="variable">.A</span>(fir_out),      <span class="comment">// input wire [15 : 0] A</span></span><br><span class="line">  <span class="variable">.B</span>(cos_out),      <span class="comment">// input wire [7 : 0] B</span></span><br><span class="line">  <span class="variable">.P</span>(s_up)      <span class="comment">// output wire [23 : 0] P</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>IP核设置</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_1PNwW617fX.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_RWVjiclv_j.png" alt></p></li><li><p>仿真输出</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_EliAfxYvQe.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_ySQCVNstiS.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_I2DjBiZKfW.png" alt></p></li></ul><h3 id="结果验证">结果验证</h3><blockquote><p>首先需要在vivado中输出txt文件</p></blockquote><ul><li>MATLAB<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_out = importdata(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">y = s_up - data_out&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(y);</span><br></pre></td></tr></table></figure><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_Ch21N1HNpA.png" alt><blockquote><p>这张图出现的原因是输入数据为1024，4倍上采样之后为4096个点，理论上通过滤波器之后应该是4096个点，但MATLAB中卷积之后为4120个点，滤波器两边的拖尾造成</p></blockquote></li><li>Verilog<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">14</span>:<span class="number">0</span>] counter_1;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">32</span>:<span class="number">0</span>] cnt_1 = <span class="number">33&#x27;d0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">       counter_1 &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt_1 == <span class="number">33&#x27;d4160</span>) <span class="keyword">begin</span></span><br><span class="line">      <span class="built_in">$fclose</span>(save_file);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//       $fdisplay(save_file,&quot;%d&quot;,$signed(s_up));</span></span><br><span class="line">        <span class="built_in">$fwrite</span>(save_file,<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">$signed</span>(s_up)); </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line"><span class="comment">//用于观察的计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">      cnt_1 &lt;= <span class="number">33&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      cnt_1 &lt;= cnt_1 + <span class="number">33&#x27;d1</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="附录">附录</h3><h3 id="MATLAB">MATLAB</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line"><span class="comment">% data_len = 1024;        %数据长度</span></span><br><span class="line"><span class="comment">% data = randi([0 1],1,data_len); </span></span><br><span class="line"><span class="comment">% fid = fopen(&#x27;send_data.txt&#x27;, &#x27;w&#x27;); %创建COE文件</span></span><br><span class="line"><span class="comment">% for i = 1:length(data)</span></span><br><span class="line"><span class="comment">%     if(i &lt; length(data))</span></span><br><span class="line"><span class="comment">%         fprintf(fid,&#x27;%d\n&#x27;,data(i));</span></span><br><span class="line"><span class="comment">%     else</span></span><br><span class="line"><span class="comment">%         fprintf(fid,&#x27;%d&#x27;,data(i));</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end  </span></span><br><span class="line"><span class="comment">% % fprintf(fid,&#x27;%d\n&#x27;,sin_14bit);</span></span><br><span class="line"><span class="comment">% fclose(fid);</span></span><br><span class="line"><span class="comment">% CreatCodeFile(data,&#x27;data.coe&#x27;,10);</span></span><br><span class="line">data = importdata(<span class="string">&#x27;send_data.txt&#x27;</span>);</span><br><span class="line"><span class="comment">%% 根升余弦滤波器</span></span><br><span class="line">alfs = <span class="number">0.35</span>;            <span class="comment">% 滚降系数</span></span><br><span class="line">osr = <span class="number">4</span>;             </span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);</span><br><span class="line">max_fir_rcos = <span class="built_in">max</span>(<span class="built_in">abs</span>(fir_rcos));</span><br><span class="line">fir_rcos_bit = <span class="built_in">round</span>((<span class="number">2</span>^<span class="number">7</span><span class="number">-1</span>)*fir_rcos/max_fir_rcos); <span class="comment">%8bit量化</span></span><br><span class="line"><span class="comment">% fid = fopen(&#x27;fir_data.coe&#x27;, &#x27;w&#x27;); %创建COE文件</span></span><br><span class="line"><span class="comment">% fprintf(fid, &#x27;Radix=10;\n&#x27;);</span></span><br><span class="line"><span class="comment">% fprintf(fid, &#x27;CoefData=\n&#x27;);</span></span><br><span class="line"><span class="comment">% for i = 1:length(fir_rcos_bit)</span></span><br><span class="line"><span class="comment">%     if(i &lt; length(fir_rcos_bit))</span></span><br><span class="line"><span class="comment">%         fprintf(fid,&#x27;%d\n&#x27;,fir_rcos_bit(i));</span></span><br><span class="line"><span class="comment">%     else</span></span><br><span class="line"><span class="comment">%         fprintf(fid,&#x27;%d&#x27;,fir_rcos_bit(i));</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end  </span></span><br><span class="line"><span class="comment">% % fprintf(fid,&#x27;%d\n&#x27;,sin_14bit);</span></span><br><span class="line"><span class="comment">% fclose(fid);</span></span><br><span class="line">data_1 = (data&#x27;<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">data_up = upsample(data_1,<span class="number">4</span>);</span><br><span class="line">data_bx = conv(fir_rcos_bit,data_up);                 <span class="comment">%通过滤波器</span></span><br><span class="line">fs = <span class="number">16000</span>;            <span class="comment">% 采样率</span></span><br><span class="line">fc = <span class="number">2000</span>;             <span class="comment">% 载波频率</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*t);                      <span class="comment">%载波</span></span><br><span class="line">cos_bit = <span class="built_in">round</span>((<span class="number">2</span>^<span class="number">7</span><span class="number">-1</span>)*carrier/<span class="built_in">max</span>(<span class="built_in">abs</span>(carrier)));<span class="comment">%8bit量化</span></span><br><span class="line"><span class="comment">% fid = fopen(&#x27;cos_bit.coe&#x27;, &#x27;w&#x27;); %创建COE文件</span></span><br><span class="line"><span class="comment">% fprintf(fid, &#x27;memory_initialization_radix=10;\n&#x27;);</span></span><br><span class="line"><span class="comment">% fprintf(fid, &#x27;memory_initialization_vector=\n&#x27;);</span></span><br><span class="line"><span class="comment">% for i = 1:length(cos_bit)</span></span><br><span class="line"><span class="comment">%     if(i &lt; length(cos_bit))</span></span><br><span class="line"><span class="comment">%         fprintf(fid,&#x27;%d\n&#x27;,cos_bit(i));</span></span><br><span class="line"><span class="comment">%     else</span></span><br><span class="line"><span class="comment">%         fprintf(fid,&#x27;%d&#x27;,cos_bit(i));</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end  </span></span><br><span class="line"><span class="comment">% % fprintf(fid,&#x27;%d\n&#x27;,cos_bit);</span></span><br><span class="line"><span class="comment">% fclose(fid);</span></span><br><span class="line"><span class="comment">% plot(cos_bit);</span></span><br><span class="line">s_up = data_bx .* cos_bit;</span><br><span class="line">data_out = importdata(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">y = s_up - data_out&#x27;;</span><br><span class="line"><span class="built_in">plot</span>(y);</span><br></pre></td></tr></table></figure><h3 id="Verilog">Verilog</h3><p>Design</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bpsk_send(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,            <span class="comment">//低有效</span></span><br><span class="line">    <span class="keyword">input</span> data,</span><br><span class="line">    <span class="keyword">input</span> data_nd,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">23</span>:<span class="number">0</span>] s_up</span><br><span class="line">    );   </span><br><span class="line"><span class="comment">//映射0变-1 + 4倍上采样</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] data_map = <span class="number">2&#x27;b00</span>;  <span class="comment">//映射加插值后的信号</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] cnt = <span class="number">2&#x27;b00</span>;   <span class="comment">//计数，4为一个周期</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">        data_map &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">        cnt &lt;= <span class="number">2&#x27;b00</span>;       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(cnt)</span><br><span class="line">        <span class="number">2&#x27;b01</span>:<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(data == <span class="number">1&#x27;b1</span>&amp;&amp;data_nd == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                data_map &lt;=<span class="number">2&#x27;b01</span>;</span><br><span class="line">                cnt &lt;= cnt + <span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="keyword">end</span>                            <span class="comment">//data为1时不变</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data_nd == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">                data_map &lt;= <span class="number">2&#x27;b11</span>;</span><br><span class="line">                cnt &lt;= cnt +<span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="keyword">end</span>                            <span class="comment">//data为0时变为-1</span></span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">            cnt &lt;= cnt +<span class="number">2&#x27;b01</span>;</span><br><span class="line">            data_map &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">endcase</span>       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line"><span class="comment">//根升余弦滤波FIR</span></span><br><span class="line"><span class="keyword">wire</span> s_axis_data_tready;</span><br><span class="line"><span class="keyword">wire</span> m_axis_data_tvalid;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] fir_out;</span><br><span class="line">shape_fir shape_fir_m (</span><br><span class="line">  <span class="variable">.aclk</span>(clk),                              <span class="comment">// input wire aclk</span></span><br><span class="line">  <span class="variable">.s_axis_data_tvalid</span>(<span class="number">1&#x27;b1</span>),  <span class="comment">// input wire s_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.s_axis_data_tready</span>(s_axis_data_tready),  <span class="comment">// output wire s_axis_data_tready</span></span><br><span class="line">  <span class="variable">.s_axis_data_tdata</span>(&#123;<span class="number">6&#x27;b0</span>,data_map&#125;),    <span class="comment">// input wire [7 : 0] s_axis_data_tdata</span></span><br><span class="line">  <span class="variable">.m_axis_data_tvalid</span>(m_axis_data_tvalid),  <span class="comment">// output wire m_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.m_axis_data_tdata</span>(fir_out)    <span class="comment">// output wire [15 : 0] m_axis_data_tdata</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//DDS生成中频载波</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">12</span>:<span class="number">0</span>] addra;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cos_out;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] cook;          <span class="comment">//用于截断有效数据的计数标志</span></span><br><span class="line"><span class="keyword">parameter</span> add_M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst||addra==<span class="number">13&#x27;d4119</span>) <span class="keyword">begin</span></span><br><span class="line">           addra &lt;= <span class="number">13&#x27;d0</span>; </span><br><span class="line">           cook &lt;= <span class="number">8&#x27;d0</span>;   </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cook==<span class="number">8&#x27;d22</span>) <span class="keyword">begin</span></span><br><span class="line">           addra &lt;= addra + add_M;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">           addra &lt;= addra;</span><br><span class="line">           cook &lt;= cook + <span class="number">8&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">cos_local cos_local_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.ena</span>(<span class="number">1&#x27;b1</span>),      <span class="comment">// input wire ena</span></span><br><span class="line">  <span class="variable">.addra</span>(addra),  <span class="comment">// input wire [12 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(cos_out)  <span class="comment">// output wire [7 : 0] douta</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法器</span></span><br><span class="line"><span class="comment">//wire [23:0] s_up;</span></span><br><span class="line">mult_s mult_s_m (</span><br><span class="line">  <span class="variable">.CLK</span>(clk),  <span class="comment">// input wire CLK</span></span><br><span class="line">  <span class="variable">.A</span>(fir_out),      <span class="comment">// input wire [15 : 0] A</span></span><br><span class="line">  <span class="variable">.B</span>(cos_out),      <span class="comment">// input wire [7 : 0] B</span></span><br><span class="line">  <span class="variable">.P</span>(s_up)      <span class="comment">// output wire [23 : 0] P</span></span><br><span class="line">);  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p>Testbench</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb_bpsk_send(</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"><span class="keyword">reg</span> rst;</span><br><span class="line"><span class="keyword">reg</span> data = <span class="number">1&#x27;b0</span>;    </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;    <span class="comment">//50MHz clock</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    #<span class="number">200</span></span><br><span class="line">    rst = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">1</span>-<span class="number">1</span>:<span class="number">0</span>] data_mem [<span class="number">0</span>:<span class="number">1023</span>] ;<span class="comment">//定义一个位宽为2bit，深度为1024的mem</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">     <span class="built_in">$readmemh</span>(<span class="string">&quot;G:/vivado_project/bpsk/bpsk.srcs/sources_1/send_data.txt&quot;</span>,data_mem);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">integer</span> i;</span><br><span class="line"><span class="comment">//reg [1:0] counter = 2&#x27;d0;</span></span><br><span class="line"><span class="comment">//always @(posedge clk) begin</span></span><br><span class="line"><span class="comment">//   if (rst|i==1023) begin</span></span><br><span class="line"><span class="comment">//      data &lt;= 1&#x27;b0;</span></span><br><span class="line"><span class="comment">//      i &lt;= 0; </span></span><br><span class="line"><span class="comment">//      counter &lt;= 2&#x27;d0;    </span></span><br><span class="line"><span class="comment">//   end</span></span><br><span class="line"><span class="comment">//   else begin</span></span><br><span class="line"><span class="comment">//      i &lt;= i + 1;</span></span><br><span class="line"><span class="comment">//      data &lt;= data_mem[i];    </span></span><br><span class="line"><span class="comment">//   end</span></span><br><span class="line"><span class="comment">//end</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] counter = <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">reg</span> data_nd = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span> (rst|i==<span class="number">1023</span>) <span class="keyword">begin</span></span><br><span class="line">      data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">      i &lt;= <span class="number">0</span>; </span><br><span class="line">      counter &lt;= <span class="number">2&#x27;d0</span>; </span><br><span class="line">      data_nd &lt;= <span class="number">1&#x27;b0</span>;   </span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">case</span>(counter)</span><br><span class="line">         <span class="number">2&#x27;d1</span>:<span class="keyword">begin</span></span><br><span class="line">            data &lt;= data_mem[i];</span><br><span class="line">            i &lt;= i + <span class="number">1</span>;</span><br><span class="line">            counter &lt;= counter + <span class="number">2&#x27;d1</span>;</span><br><span class="line">            data_nd &lt;= <span class="number">1&#x27;b1</span>; </span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">         <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">            counter &lt;= counter + <span class="number">2&#x27;d1</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">endcase</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">23</span>:<span class="number">0</span>] s_up;</span><br><span class="line"></span><br><span class="line">bpsk_send bpsk_send_m(</span><br><span class="line">    <span class="variable">.clk</span>(clk),</span><br><span class="line">    <span class="variable">.rst</span>(rst),</span><br><span class="line">    <span class="variable">.data</span>(data),</span><br><span class="line">    <span class="variable">.data_nd</span>(data_nd),</span><br><span class="line"></span><br><span class="line">    <span class="variable">.s_up</span>(s_up)</span><br><span class="line">);    </span><br><span class="line"><span class="keyword">integer</span> save_file;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    save_file = <span class="built_in">$fopen</span>(<span class="string">&quot;G:/vivado_project/bpsk/bpsk.srcs/sources_1/test.txt&quot;</span>);    <span class="comment">//打开所创建的文件；若找不到该文件，则会自动创建该文件。</span></span><br><span class="line">    <span class="keyword">if</span>(save_file == <span class="number">0</span>)<span class="keyword">begin</span> </span><br><span class="line">        <span class="built_in">$display</span> (<span class="string">&quot;can not open the file!&quot;</span>);    <span class="comment">//如果创建文件失败，则会显示&quot;can not open the file!&quot;信息。</span></span><br><span class="line">        <span class="built_in">$stop</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">14</span>:<span class="number">0</span>] counter_1;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">32</span>:<span class="number">0</span>] cnt_1 = <span class="number">33&#x27;d0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">       counter_1 &lt;= <span class="number">15&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cnt_1 == <span class="number">33&#x27;d4160</span>) <span class="keyword">begin</span></span><br><span class="line">      <span class="built_in">$fclose</span>(save_file);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line"><span class="comment">//       $fdisplay(save_file,&quot;%d&quot;,$signed(s_up));</span></span><br><span class="line">        <span class="built_in">$fwrite</span>(save_file,<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">$signed</span>(s_up)); </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line"><span class="comment">//用于观察的计数器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">      cnt_1 &lt;= <span class="number">33&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">      cnt_1 &lt;= cnt_1 + <span class="number">33&#x27;d1</span>;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1>代码优化及思考</h1><h2 id="目录-2">目录</h2><ul><li><a href="#HDL">HDL</a></li><li><a href="#IP%E6%A0%B8%E8%AE%BE%E7%BD%AEFIR">IP核设置（FIR）</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E9%99%84%E5%BD%95">代码附录</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0">代码学习</a></li></ul><blockquote><p>MATLAB代码基本不变，主要是verilog代码<br>（直接数据输入，上采样环节在IP核中设置）</p></blockquote><h3 id="HDL">HDL</h3><hr><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] data_map = <span class="number">2&#x27;b00</span>;   <span class="comment">//映射之后的序列</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">        data_map &lt;= <span class="number">2&#x27;b00</span>;     </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(data_nd)</span><br><span class="line">        <span class="number">1&#x27;b1</span>:<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(data == <span class="number">1&#x27;b1</span>)<span class="keyword">begin</span></span><br><span class="line">                data_map &lt;=<span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="keyword">end</span>                            <span class="comment">//data为1时变 1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                data_map &lt;= <span class="number">2&#x27;b11</span>;</span><br><span class="line">            <span class="keyword">end</span>                            <span class="comment">//data为0时变-1</span></span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">begin</span></span><br><span class="line">            data_map &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">end</span>    </span><br><span class="line">        <span class="keyword">endcase</span>       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>映射序列的写法</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] data_map ;</span><br><span class="line"><span class="keyword">assign</span> data_map = data ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b11</span> ;</span><br><span class="line"><span class="comment">//映射0变-1；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>结果输出</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_Kd2oaW4TDu.png" alt></p></li></ul><h3 id="IP核设置（FIR）">IP核设置（FIR）</h3><ul><li><p>内插倍数设置为4</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_2o1qaQgoTl.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_cL-KLAeLgm.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_2ojNqmO2cj.png" alt></p></li><li><p>输出结果 <strong>（错误→正确）</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_AMd2vSSChk.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_DWgoxNCpkz.png" alt></p><blockquote><p>⁉️<strong>输出序列是错的</strong><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_KPMW08p9hJ.png" alt><br>🚗找了好久，序列的前三个数与MATLAB数据就差个负号，以为是映射方式错了，改了半天，原来是使能信号，修改如下；</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fir_compiler_0 fir_compiler (</span><br><span class="line">  <span class="variable">.aclk</span>(clk),                              <span class="comment">// input wire aclk</span></span><br><span class="line">  <span class="variable">.s_axis_data_tvalid</span>(data_nd),  <span class="comment">// input wire s_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.s_axis_data_tready</span>(s_axis_data_tready),  <span class="comment">// output wire s_axis_data_tready</span></span><br><span class="line">  <span class="variable">.s_axis_data_tdata</span>(&#123;<span class="number">6&#x27;d0</span>,data_map&#125;),    <span class="comment">// input wire [7 : 0] s_axis_data_tdata</span></span><br><span class="line">  <span class="variable">.m_axis_data_tvalid</span>(m_axis_data_tvalid),  <span class="comment">// output wire m_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.m_axis_data_tdata</span>(fir_out)    <span class="comment">// output wire [15 : 0] m_axis_data_tdata</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_I8FmsnU2fq.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_2TAe28geDF.png" alt></p></li></ul><hr><h3 id="代码附录">代码附录</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> bpsk_send(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst,</span><br><span class="line">    <span class="keyword">input</span> data,</span><br><span class="line">    <span class="keyword">input</span> data_nd   </span><br><span class="line">    );</span><br><span class="line"><span class="comment">// reg [1:0] data_map = 2&#x27;b00;   //映射之后的序列</span></span><br><span class="line"><span class="comment">// always @(posedge clk) begin</span></span><br><span class="line"><span class="comment">//     if (rst == 1&#x27;b1) begin</span></span><br><span class="line"><span class="comment">//         data_map &lt;= 2&#x27;b00;     </span></span><br><span class="line"><span class="comment">//     end</span></span><br><span class="line"><span class="comment">//     else begin</span></span><br><span class="line"><span class="comment">//         case(data_nd)</span></span><br><span class="line"><span class="comment">//         1&#x27;b1:begin</span></span><br><span class="line"><span class="comment">//             if(data == 1&#x27;b1)begin</span></span><br><span class="line"><span class="comment">//                 data_map &lt;=2&#x27;b01;</span></span><br><span class="line"><span class="comment">//             end                            //data为1时变 1</span></span><br><span class="line"><span class="comment">//             else begin</span></span><br><span class="line"><span class="comment">//                 data_map &lt;= 2&#x27;b11;</span></span><br><span class="line"><span class="comment">//             end                            //data为0时变-1</span></span><br><span class="line"><span class="comment">//         end    </span></span><br><span class="line"><span class="comment">//         default:begin</span></span><br><span class="line"><span class="comment">//             data_map &lt;= 2&#x27;b00;</span></span><br><span class="line"><span class="comment">//             end    </span></span><br><span class="line"><span class="comment">//         endcase       </span></span><br><span class="line"><span class="comment">//     end</span></span><br><span class="line"><span class="comment">// end</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] data_map ;</span><br><span class="line"><span class="keyword">assign</span> data_map = data ? <span class="number">2&#x27;b01</span> : <span class="number">2&#x27;b11</span> ;</span><br><span class="line"><span class="comment">//FIR根生余弦成形</span></span><br><span class="line"><span class="keyword">wire</span>    s_axis_data_tready;</span><br><span class="line"><span class="keyword">wire</span>    m_axis_data_tvalid;  </span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>]    fir_out;</span><br><span class="line">fir_compiler_0 fir_compiler (</span><br><span class="line">  <span class="variable">.aclk</span>(clk),                              <span class="comment">// input wire aclk</span></span><br><span class="line">  <span class="variable">.s_axis_data_tvalid</span>(data_nd),  <span class="comment">// input wire s_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.s_axis_data_tready</span>(s_axis_data_tready),  <span class="comment">// output wire s_axis_data_tready</span></span><br><span class="line">  <span class="variable">.s_axis_data_tdata</span>(&#123;<span class="number">6&#x27;d0</span>,data_map&#125;),    <span class="comment">// input wire [7 : 0] s_axis_data_tdata</span></span><br><span class="line">  <span class="variable">.m_axis_data_tvalid</span>(m_axis_data_tvalid),  <span class="comment">// output wire m_axis_data_tvalid</span></span><br><span class="line">  <span class="variable">.m_axis_data_tdata</span>(fir_out)    <span class="comment">// output wire [15 : 0] m_axis_data_tdata</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//DDS生成中频载波</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">12</span>:<span class="number">0</span>] addra = <span class="number">13&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cos_out;</span><br><span class="line">    <span class="keyword">parameter</span> add_M = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst||addra==<span class="number">13&#x27;d4119</span>) <span class="keyword">begin</span></span><br><span class="line">           addra &lt;= <span class="number">13&#x27;d0</span>;    </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m_axis_data_tvalid) <span class="keyword">begin</span></span><br><span class="line">           addra &lt;= addra + add_M;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">           addra &lt;= addra;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">gen_cos gen_cos_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.ena</span>(m_axis_data_tvalid),      <span class="comment">// input wire ena</span></span><br><span class="line">  <span class="variable">.addra</span>(addra),  <span class="comment">// input wire [12 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(cos_out)  <span class="comment">// output wire [7 : 0] douta</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//延时一个周期</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] cos_delay = <span class="number">8&#x27;d0</span>;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(rst) <span class="keyword">begin</span></span><br><span class="line">        cos_delay &lt;= <span class="number">8&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cos_delay &lt;= cos_out;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_iZjbOl9Jiw.png" alt></p><p><strong>testbench</strong></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_bpsk_send(</span><br><span class="line"> );</span><br><span class="line">   <span class="keyword">reg</span> clk;</span><br><span class="line">   <span class="keyword">reg</span> rst;</span><br><span class="line">   <span class="keyword">reg</span>  data = <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">reg</span>  data_mem [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      clk = <span class="number">0</span>;</span><br><span class="line">      rst = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">$readmemb</span>(<span class="string">&quot;G:/vivado_project/bpsk_send/bpsk_send.srcs/sim_1/new/send_data.txt&quot;</span>,data_mem);</span><br><span class="line">      #<span class="number">200</span></span><br><span class="line">      rst = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line">   <span class="keyword">always</span> #<span class="number">10</span> clk = ~ clk;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] index = <span class="number">10&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">reg</span> data_nd = <span class="number">1&#x27;b0</span>;</span><br><span class="line">   <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">         data &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">         index &lt;= <span class="number">10&#x27;d0</span>; </span><br><span class="line">         data_nd &lt;= <span class="number">1&#x27;b0</span>;   </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">               index &lt;= index + <span class="number">1</span>;</span><br><span class="line">               data &lt;= data_mem[index];</span><br><span class="line">               data_nd &lt;= <span class="number">1&#x27;b1</span>; </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    bpsk_send bpsk_send_m(</span><br><span class="line">       <span class="variable">.clk</span>(clk),</span><br><span class="line">       <span class="variable">.rst</span>(rst),</span><br><span class="line">       <span class="variable">.data</span>(data),</span><br><span class="line">       <span class="variable">.data_nd</span>(data_nd)</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line">   <span class="keyword">reg</span> [<span class="number">30</span>:<span class="number">0</span>] cnt ;</span><br><span class="line">   <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">      <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">         cnt &lt;= <span class="number">31&#x27;d0</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">         cnt &lt;= cnt + <span class="number">31&#x27;d1</span>;</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/08FPGA%E5%8F%8A%E6%8E%A5%E6%94%B6%E6%9C%BA/FPGA%E5%8F%91%E7%AB%AF%E8%AE%BE%E8%AE%A1/image_L_M2_ky_Ue.png" alt></p><h3 id="代码学习">代码学习</h3><p>读写txt文件</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//testbench</span></span><br><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns/1ps</span></span><br><span class="line"><span class="keyword">module</span> Recv_tb ();</span><br><span class="line">    <span class="keyword">reg</span> clk;</span><br><span class="line">    <span class="keyword">reg</span> rst;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">319</span>:<span class="number">0</span>] din_da;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">319</span>:<span class="number">0</span>] din_da_memory [<span class="number">1023</span>:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> START_TIME = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">parameter</span> INTERVAL = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">parameter</span> IS_POINT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">integer</span> handle01;</span><br><span class="line"></span><br><span class="line">    Recv Recv_m(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst</span>(rst),</span><br><span class="line"></span><br><span class="line">        <span class="variable">.din_da</span>(din_da)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        clk = <span class="number">0</span>;</span><br><span class="line">        rst = <span class="number">0</span>;</span><br><span class="line">        din_da = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">$readmemb</span>(<span class="string">&quot;G:/Match_Filter/Matlab/Testbench/din_da.txt&quot;</span>,din_da_memory);</span><br><span class="line">        handle01 = <span class="built_in">$fopen</span>(<span class="string">&quot;G:/Match_Filter/Output_data/dout_I.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="built_in">$fclose</span>(handle01);       </span><br><span class="line"></span><br><span class="line">        #<span class="number">20</span>;</span><br><span class="line">        rst = <span class="number">1</span>;</span><br><span class="line">        #<span class="number">50</span>;</span><br><span class="line">        rst = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> #<span class="number">1</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">9</span>:<span class="number">0</span>] index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst)<span class="keyword">begin</span></span><br><span class="line">            din_da &lt;= <span class="number">320&#x27;d0</span>;</span><br><span class="line">            index &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            index &lt;= index + <span class="number">1&#x27;b1</span>;</span><br><span class="line">            din_da &lt;= din_da_memory[index];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">30</span>:<span class="number">0</span>] cnt_global = <span class="number">31&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        cnt_global &lt;= cnt_global + <span class="number">31&#x27;d1</span>;                         </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(IS_POINT)<span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(cnt_global == <span class="number">31&#x27;d40</span>)<span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$fopen</span>(<span class="string">&quot;G:/Match_Filter/Output_data/dout_I.txt&quot;</span>,<span class="string">&quot;a+&quot;</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt_global &gt;= <span class="number">31&#x27;d40</span> &amp;&amp; cnt_global &lt;= <span class="number">31&#x27;d1040</span>)<span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$fwrite</span>(handle01,<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">$signed</span>(Recv_tb<span class="variable">.Recv_m</span><span class="variable">.Match_filter_top_m</span><span class="variable">.dout_I_01</span>));</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="built_in">$fclose</span>(handle01);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>捕获和积累学习及仿真</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1>MATLAB仿真</h1><h2 id="目录">目录</h2><ul><li><a href="#matlab%E4%BB%BF%E7%9C%9F">MATLAB仿真</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a><ul><li><a href="#%E6%8D%95%E8%8E%B7%E7%AE%97%E6%B3%95">捕获算法</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li><li><a href="#%E4%B8%8D%E8%BF%9B%E8%A1%8C%E7%A7%AF%E7%B4%AF%E8%BF%90%E7%AE%97">不进行积累运算</a></li><li><a href="#%E8%BF%9B%E8%A1%8C%E7%A7%AF%E7%B4%AF">进行积累</a></li></ul></li></ul></li></ul><h3 id="捕获算法">捕获算法</h3><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_i_CjIJfwCO.png" alt></p><h3 id="代码实现">代码实现</h3><ul><li><p>高信噪比</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%-----------------------------------------------------------------%</span></span><br><span class="line"><span class="comment">%Title: bpsk_dsss_capture</span></span><br><span class="line"><span class="comment">%Data: 2022/11/23  21:24:35</span></span><br><span class="line"><span class="comment">%Author: Potter</span></span><br><span class="line"><span class="comment">%Function: 伪码同步----捕获相关</span></span><br><span class="line"><span class="comment">%Version: Matlab 2022b</span></span><br><span class="line"><span class="comment">%Tags: 高信噪比</span></span><br><span class="line"><span class="comment">%----------------------------------------------------------------%</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%----------------------参数设定-----------------------------------%</span></span><br><span class="line">symbol_rate = <span class="number">10000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">%每个符号4个采样点-----samples per symbol</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = fs / <span class="number">4</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">10</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%------------------------发送端-----------------------------------%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------发送序列------------------------------------%</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------映射--------------------------------------%</span></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------生成扩频序列(m序列)--------------------------%</span></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line"><span class="comment">% mg = repmat(ms&#x27;,1,N);  %重复m序列</span></span><br><span class="line"><span class="comment">% s = rectpulse(s,p);</span></span><br><span class="line"><span class="comment">% y = s.*mg;        %信号与扩频码相乘</span></span><br><span class="line">m_1 = ms .* s;</span><br><span class="line">y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * N]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------根升余弦滤波成型----------------------------%</span></span><br><span class="line">y_up = upsample(y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------------上变频---------------------------------%</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier .* data_bx; <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------------接收端-----------------------------------%</span></span><br><span class="line"></span><br><span class="line">r_n = awgn(s_up, <span class="number">10</span>, <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%添加噪声</span></span><br><span class="line">N = <span class="number">100</span>; <span class="comment">%填0的个数</span></span><br><span class="line">r_n_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n];</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------------正交下变频-----------------------------%</span></span><br><span class="line">delta_f = <span class="number">0</span>; <span class="comment">%载波频偏数值</span></span><br><span class="line">t1 = <span class="number">0</span>:<span class="built_in">length</span>(r_n_add_0) - <span class="number">1</span>;</span><br><span class="line">carrier_cos = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc +delta_f) / fs * t1);</span><br><span class="line">carrier_sin = <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc +delta_f) / fs * t1);</span><br><span class="line">sig_I = r_n_add_0 .* carrier_cos;</span><br><span class="line">sig_Q = r_n_add_0 .* carrier_sin;</span><br><span class="line"></span><br><span class="line">sig_complex = <span class="built_in">complex</span>(sig_I, sig_Q);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------------截位-----------------------------------%</span></span><br><span class="line">l = <span class="built_in">length</span>(ms)*sps;</span><br><span class="line">sig_complex_1 = sig_complex(<span class="number">1</span>:<span class="number">1</span>:l);</span><br><span class="line">sig_fft_complex_1 = fft(sig_complex_1, l);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------------捕获-----------------------------------%</span></span><br><span class="line"></span><br><span class="line">mg_up = upsample(ms.&#x27;, sps);</span><br><span class="line">mg_up_fft = fft(mg_up);</span><br><span class="line">mg_up_fft_conj = <span class="built_in">conj</span>(mg_up_fft);</span><br><span class="line">Y = <span class="built_in">zeros</span>(l,l);</span><br><span class="line">y = <span class="built_in">zeros</span>(l,l);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">80</span></span><br><span class="line">    <span class="comment">% y(i,:) = circshift(sig_fft_complex_1,i-1) .* mg_up_fft_conj;</span></span><br><span class="line">    u = <span class="built_in">circshift</span>(mg_up_fft_conj,<span class="built_in">i</span><span class="number">-40</span>);</span><br><span class="line">    Y(<span class="built_in">i</span>,:) = u.*sig_fft_complex_1;</span><br><span class="line">    y(<span class="built_in">i</span>,:) = ifft(Y(<span class="built_in">i</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">mesh(<span class="built_in">abs</span>(y));</span><br><span class="line">set(gca,<span class="string">&#x27;YLim&#x27;</span>,[<span class="number">0</span> <span class="number">80</span>]);</span><br><span class="line">set(gca,<span class="string">&#x27;XLim&#x27;</span>,[<span class="number">0</span> <span class="number">200</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_mlXdmK4Hqs.png" alt></p></li><li><p>低信噪比</p><h3 id="不进行积累运算">不进行积累运算</h3><blockquote><p><strong>代码与上面一致，只修改下面一行</strong><code>r_n = awgn(s_up, -20, 'measured'); %添加噪声</code><strong>此时输出如下图</strong><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_vPYNlKU5jl.png" alt><br>此时发现相关峰值已经很不明显，甚至找不到，信号几乎完全淹没在噪声中<br>故而运用积累算法，修改代码如下</p></blockquote><h3 id="进行积累">进行积累</h3><blockquote><p><strong>核心代码：</strong></p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%截位</span></span><br><span class="line">l = <span class="built_in">length</span>(ms) * sps;</span><br><span class="line">sig_complex_1 = sig_complex(<span class="number">1</span>:<span class="number">1</span>:l);</span><br><span class="line">sig_fft_complex_1 = fft(sig_complex_1, l);</span><br><span class="line"></span><br><span class="line">k_num = <span class="number">40</span>; <span class="comment">%截取数据的段数</span></span><br><span class="line">sig_complex_cut = <span class="built_in">zeros</span>(k_num, l);</span><br><span class="line">sig_complex_cut_fft = <span class="built_in">zeros</span>(k_num, l);</span><br><span class="line">Y = <span class="built_in">zeros</span>(l, l);</span><br><span class="line">y = <span class="built_in">zeros</span>(l, l);</span><br><span class="line">z = <span class="built_in">zeros</span>(l, l); <span class="comment">%积累后的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:k_num</span><br><span class="line">    sig_complex_cut(k, :) = sig_complex(<span class="number">1</span> + (k - <span class="number">1</span>) * l:<span class="number">1</span>:k * l);</span><br><span class="line">    sig_complex_cut_fft(k, :) = fft(sig_complex_cut(k, :));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">80</span></span><br><span class="line">        Y(<span class="built_in">i</span>, :) = <span class="built_in">circshift</span>(sig_complex_cut_fft(k, :), <span class="built_in">i</span> - <span class="number">40</span>) .* mg_up_fft_conj;</span><br><span class="line">        y(<span class="built_in">i</span>, :) = ifft(Y(<span class="built_in">i</span>, :));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    z = <span class="built_in">abs</span>(z) + <span class="built_in">abs</span>(y);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/image_IAVvyMtvKJ.png" alt></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/07%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF/%E6%8D%95%E8%8E%B7%E5%92%8C%E7%A7%AF%E7%B4%AF%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BB%BF%E7%9C%9F/untitled_kf9YnrJzku.png" alt="  " title="  "></p><hr><ul><li>完整代码<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%-----------------------------------------------------------------%</span></span><br><span class="line"><span class="comment">%Title: bpsk_dsss_capture</span></span><br><span class="line"><span class="comment">%Data: 2022/11/23  21:24:35</span></span><br><span class="line"><span class="comment">%Author: Potter</span></span><br><span class="line"><span class="comment">%Function: 伪码同步----捕获相关</span></span><br><span class="line"><span class="comment">%Version: Matlab 2022b</span></span><br><span class="line"><span class="comment">%Tags: 低信噪比</span></span><br><span class="line"><span class="comment">%----------------------------------------------------------------%</span></span><br><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%----------------------参数设定-----------------------------------%</span></span><br><span class="line">symbol_rate = <span class="number">10000</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">8</span>; <span class="comment">%每个符号4个采样点-----samples per symbol</span></span><br><span class="line">fs = sps * symbol_rate; <span class="comment">% 采样率</span></span><br><span class="line">span = <span class="number">6</span>;</span><br><span class="line">fc = fs / <span class="number">4</span>; <span class="comment">% 载波频率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">N = <span class="number">1000</span>; <span class="comment">%数据长度</span></span><br><span class="line">is_plot = <span class="number">1</span>; <span class="comment">%是否打印输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%------------------------发送端-----------------------------------%%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------发送序列------------------------------------%</span></span><br><span class="line"><span class="comment">%data = repmat([0,1], 1,N/2);</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, N); <span class="comment">%生成0，1序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%------------------------映射--------------------------------------%</span></span><br><span class="line">s = (data - <span class="number">1</span>/<span class="number">2</span>) * <span class="number">2</span>; <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------生成扩频序列(m序列)--------------------------%</span></span><br><span class="line">n = <span class="number">7</span>; <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>; <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p, <span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line"><span class="comment">% mg = repmat(ms&#x27;,1,N);  %重复m序列</span></span><br><span class="line"><span class="comment">% s = rectpulse(s,p);</span></span><br><span class="line"><span class="comment">% y = s.*mg;        %信号与扩频码相乘</span></span><br><span class="line">m_1 = ms .* s;</span><br><span class="line">y_send = <span class="built_in">reshape</span>(m_1, [<span class="number">1</span>, p * N]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------根升余弦滤波成型----------------------------%</span></span><br><span class="line">y_up = upsample(y_send, sps); <span class="comment">% 上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs, <span class="number">6</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up, fir_rcos, <span class="string">&#x27;same&#x27;</span>); <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%---------------------------上变频---------------------------------%</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx) - <span class="number">1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * fc / fs * t); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier .* data_bx; <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------------接收端-----------------------------------%</span></span><br><span class="line"></span><br><span class="line">r_n = awgn(s_up, <span class="number">-20</span>, <span class="string">&#x27;measured&#x27;</span>); <span class="comment">%添加噪声</span></span><br><span class="line">N = <span class="number">100</span>; <span class="comment">%填0的个数</span></span><br><span class="line">r_n_add_0 = [<span class="built_in">zeros</span>(<span class="number">1</span>, N), r_n];</span><br><span class="line"></span><br><span class="line"><span class="comment">%-----------------------------正交下变频-----------------------------%</span></span><br><span class="line">delta_f = <span class="number">0</span>; <span class="comment">%载波频偏数值</span></span><br><span class="line">t1 = <span class="number">0</span>:<span class="built_in">length</span>(r_n_add_0) - <span class="number">1</span>;</span><br><span class="line">carrier_cos = <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc +delta_f) / fs * t1);</span><br><span class="line">carrier_sin = <span class="built_in">sin</span>(<span class="number">2</span> * <span class="built_in">pi</span> * (fc +delta_f) / fs * t1);</span><br><span class="line">sig_I = r_n_add_0 .* carrier_cos;</span><br><span class="line">sig_Q = r_n_add_0 .* carrier_sin;</span><br><span class="line"></span><br><span class="line">sig_complex = <span class="built_in">complex</span>(sig_I, sig_Q);</span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------------本地码处理-------------------------------%</span></span><br><span class="line">mg_up = upsample(ms.&#x27;, sps);</span><br><span class="line">mg_up_fft = fft(mg_up);</span><br><span class="line">mg_up_fft_conj = <span class="built_in">conj</span>(mg_up_fft);</span><br><span class="line"></span><br><span class="line"><span class="comment">%----------------------------截位+捕获-------------------------------%</span></span><br><span class="line">l = <span class="built_in">length</span>(ms) * sps;</span><br><span class="line">sig_complex_1 = sig_complex(<span class="number">1</span>:<span class="number">1</span>:l);</span><br><span class="line">sig_fft_complex_1 = fft(sig_complex_1, l);</span><br><span class="line"></span><br><span class="line">k_num = <span class="number">40</span>; <span class="comment">%截取数据的段数</span></span><br><span class="line">sig_complex_cut = <span class="built_in">zeros</span>(k_num, l);</span><br><span class="line">sig_complex_cut_fft = <span class="built_in">zeros</span>(k_num, l);</span><br><span class="line">Y = <span class="built_in">zeros</span>(l, l);</span><br><span class="line">y = <span class="built_in">zeros</span>(l, l);</span><br><span class="line">z = <span class="built_in">zeros</span>(l, l); <span class="comment">%积累后的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:k_num</span><br><span class="line">    sig_complex_cut(k, :) = sig_complex(<span class="number">1</span> + (k - <span class="number">1</span>) * l:<span class="number">1</span>:k * l);</span><br><span class="line">    sig_complex_cut_fft(k, :) = fft(sig_complex_cut(k, :));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">80</span></span><br><span class="line">        Y(<span class="built_in">i</span>, :) = <span class="built_in">circshift</span>(sig_complex_cut_fft(k, :), <span class="built_in">i</span> - <span class="number">40</span>) .* mg_up_fft_conj;</span><br><span class="line">        y(<span class="built_in">i</span>, :) = ifft(Y(<span class="built_in">i</span>, :));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    z = <span class="built_in">abs</span>(z) + <span class="built_in">abs</span>(y);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">mesh(z);</span><br><span class="line">set(gca, <span class="string">&#x27;YLim&#x27;</span>, [<span class="number">0</span> <span class="number">80</span>]);</span><br><span class="line"><span class="comment">% set(gca, &#x27;XLim&#x27;, [0 200]);</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">abs</span>(z(<span class="number">40</span>, :)));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> FPGA </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
