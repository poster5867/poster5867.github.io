<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DFT-S-OFDM 波形设计</title>
      <link href="/2024/10/31/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/DFT-s-OFDM/dft-s-ofdm_waveform/"/>
      <url>/2024/10/31/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/DFT-s-OFDM/dft-s-ofdm_waveform/</url>
      
        <content type="html"><![CDATA[<h1 id="DFT-s-OFDM体制"><a href="#DFT-s-OFDM体制" class="headerlink" title="DFT-s-OFDM体制"></a>DFT-s-OFDM体制</h1><h2 id="DFT相关回顾"><a href="#DFT相关回顾" class="headerlink" title="DFT相关回顾"></a>DFT相关回顾</h2><blockquote><p>首先对离散傅里叶变换（Discrete Fourier Transform，DFT）的公式以及性质进行回顾，该部分是基础，对后边波形设计的优化以及整个系统的理解具有重要的作用。</p></blockquote><ul><li><p><strong>DFT公式</strong></p><script type="math/tex; mode=display">X(k)=\sum_{n=0}^{N-1} x(n)e^\frac{-j2\pi nk}{N}=\sum_{n=0}^{N-1} x(n)W_N^{kn}\qquad 0\le k\le N-1</script></li><li><p><strong>IDFT公式</strong></p><script type="math/tex; mode=display">x(n)=\frac{1}{N}\sum_{k=0}^{N-1}X(k)e^\frac{j2\pi nk}{N}=\frac{1}{N}\sum_{k=0}^{N-1}X(k)W_N^{kn}\qquad 0\le n \le N-1</script></li><li><p><strong>性质</strong></p><ul><li><p>时域补零——<strong>增加频率分辨率</strong></p><p>已知序列 $x(n), 0\le n \le N-1$ ，人为将序列补充至 $rN$，$r$为正整数，得到 $g(n)\quad 0\le n \le rN-1$，即</p><script type="math/tex; mode=display">  g(n) =   \begin{cases}     x(n) & \text{if } 0 \le n \le N-1 \\ 0 & \text{if } N \le n \le rN-1  \end{cases}</script><p>$g(n)$的离散傅里叶变换为：</p><script type="math/tex; mode=display">  \begin{equation*}    \begin{aligned}      G(k) &= DFT[g(n)]=\sum_{n=0}^{rN-1} g(n)e^\frac{-j2\pi nk}{rN} \\ &=\sum_{n=0}^{N-1}x(n)e^\frac{-j2\pi n(\frac {n} {k})}{N}=X(\frac{k} {n})\qquad k=0,1,\dots,rN-1    \end{aligned}  \end{equation*}</script><blockquote><p>上述公式表明，$g(n)$的频谱$G(k)$与$x(n)$的频谱$X(k)$相对应，$G(k)$的频谱间隔相比$X(k)$的频谱间隔降低$k/r$，即序列$x(n)$填充补零再做DFT，可以得到更为精细的频谱。</p><p>另外，若增加长度并未$N$的整数倍，例如 $g(n)$长度为$L&gt;N$，则列长为$L$的序列 $g(n)$的离散傅里叶变换 $G(k)$，可以得到序列 $x(n)$的$L$根谱线，此时比$X(k)$得出得谱线要多。</p></blockquote></li><li><p>时域插零（上采样）——<strong>频谱扩展复制</strong></p><p>已知序列 $x(n), 0\le n \le N-1$ ，人为将序列样本点之间插入$L-1$个零，$L$也叫上采样倍数，得到新的序列$g(n)$，其长度为$M=LN$，即</p><script type="math/tex; mode=display">g[n]=\begin{cases}x(n/L)&\mathrm{if~}n\mod L=0\\0&\mathrm{otherwise}&\end{cases}</script><p>$g(n)$的离散傅里叶变换为记为$G(m)$，与前面的$X(k)$进行区分：</p><!-- $$  \begin{equation*}    \begin{aligned}      X(k)&=\sum_{n=0}^{N-1} x(n)e^\frac{-j2\pi nk}{N}\quad 0\le k\le N-1\\      G(m)&=DFT[g(n)]=\sum_{n=0}^{LN-1}g(n)e^{-\frac{j2\pi nm}{LN}}&\\      &=\sum_{n=0}^{N-1}x(n)e^{-\frac{j2\pi m\cdot nL}{LN}}=\sum_{n=0}^{N-1}x(n)e^{-\frac{j2\pi m\cdot n}{N}}\quad 0\le m\le M-1    \end{aligned}  \end{equation*} $$ --><p>可以看到，对于每个频率$m$，当$m=k+qN$时（$q$为正整数），会出现周期性重复，即：</p><script type="math/tex; mode=display">G(m)=X(k),\qquad m=k+qN,\qquad q=0,1,\dots,N-1</script><p>即上采样之后频谱会在频率轴上以$N$为间隔重复$L$次。</p><blockquote><p>另一种推导过程如下：</p><p>$g(n)$是在序列$x(n)$每个采样点后加$L-1$个$0$，其可以表示为：</p><script type="math/tex; mode=display">g(n)=x(n/L)\cdot \delta(n\mod L)</script><p>$\delta(n\mod L)$是一个周期为$L$得脉冲序列，根据DFT性质可以得到$G(k)$为</p><script type="math/tex; mode=display">G(k)=\sum_{n=0}^{L-1}X(k-m\cdot \frac{M}{N})</script></blockquote></li><li><p>频域补零——<strong>时域内插</strong></p><p>已知序列$X(k),0\le k\le N-1$，人为将序列补充至 $rN$，$r$为正整数，得到$G(k)\quad 0\le k\le rN-1$，即：</p><script type="math/tex; mode=display">G(k)=\left\{\begin{matrix} X(k)\qquad 0\le k\le N-1\\0\qquad N\le k\le rN-1\end{matrix}\right.</script><p>进一步地，得到时域序列$g(n)$</p><script type="math/tex; mode=display">g(n)=\frac{1}{rN}\sum_{k=0}^{rN-1}G(k)e^{\frac{j2\pi kn}{rN}}=\frac{1}{rN}\sum_{k=0}^{N-1}X(k)e^{\frac{j2\pi kn}{rN}}=\frac{1}{r}x(\frac{n}{r})\qquad n=0,1,\cdots,rN-1</script><blockquote><p>上述公式表明，频域补零，时域信号内插出来更多的点，即时域信号更加密集，$1/r$是一个缩放因子，其主要保持信号得能量不变。</p></blockquote></li><li><p>频域内插——<strong>时域扩展</strong></p><p>已知序列$X(k),0\le k\le N-1$，人为将序列样本点之间插入$L-1$个零，得到的新序列即为$G(m)$，其长度为$M=LN$，表达式如下：</p><script type="math/tex; mode=display">G(m)=\begin{cases}X\left(\frac mL\right),&m=0,L,2L,\ldots,(N-1)L \\ 0,&otherwise&\end{cases}</script><p>进一步地，得到时域序列$g(n)$</p><script type="math/tex; mode=display">g(n)=\frac1M\sum_{m=0}^{M-1}G(m)e^{j\frac{2\pi}Mmn}=\frac1M\sum_{m=0}^{N-1}X(k)e^{j\frac{2\pi}M(kL)n} \\ =\frac1 {LN} \sum_{m=0}^{N-1}X(k)e^{j\frac{2\pi}Nkn}=\frac1Lx(n \mod N)\qquad 0\le n\le LN-1</script><blockquote><p>这实际上表示$g(n)$ 是 $x(n)$的周期延长 $L$ 倍。也就是说，插零后时域信号$g(n)$ 是将原始信号 $x(n)$ 在时域上拉伸为 L倍长度，并重复出现.</p></blockquote></li></ul></li></ul><h2 id="DFT-s-OFDM子载波映射方式"><a href="#DFT-s-OFDM子载波映射方式" class="headerlink" title="DFT-s-OFDM子载波映射方式"></a>DFT-s-OFDM子载波映射方式</h2><blockquote><p>DFT-s-OFDM子载波映射方式分为2种，即集中式（Localized）映射和分布式（Distributed）映射，集中式映射方便频域调度，分布式映射传输可以获得额外的频率分集增益。在LTE上行传输方案中，选用集中式映射方案。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推导 </tag>
            
            <tag> DFT-S-OFDM </tag>
            
            <tag> 仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技能总结</title>
      <link href="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="学习过程中的技能"><a href="#学习过程中的技能" class="headerlink" title="学习过程中的技能"></a>学习过程中的技能</h1><blockquote><p>本文主要记录日常学习到的一些技能，包括不限于：信息检索、电脑技巧、编程技巧……</p></blockquote><h2 id="信息检索"><a href="#信息检索" class="headerlink" title="信息检索"></a>信息检索</h2><h3 id="国自然基金结题书下载"><a href="#国自然基金结题书下载" class="headerlink" title="国自然基金结题书下载"></a>国自然基金结题书下载</h3><blockquote><p>国自然基金项目结项书对中文论文的撰写具有很高的参考价值，下面记录怎么下载结项书。</p></blockquote><ol><li>以Google浏览器为例，进入国家自然科学基金委员会官网：<a href="https://www.nsfc.gov.cn/，然后找到">https://www.nsfc.gov.cn/，然后找到</a> 申请资助—&gt;项目检索与查询—&gt;检索。</li></ol><p><img src="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/image-20241029211640489.png" alt="image-20241029211640489" style="zoom:50%;"></p><ol><li>在Google扩展应用商店中下载插件“国自然结题报告下载”，在项目页面右键可以找到下载结题报告即可下载。</li></ol><p><img src="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/image-20241029212121798.png" alt="image-20241029212121798"></p><p>至此，即可下载国自然基金的项目书了！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFDM相关学习</title>
      <link href="/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="OFDM相关学习"><a href="#OFDM相关学习" class="headerlink" title="OFDM相关学习"></a>OFDM相关学习</h1><h2 id="循环前缀相关"><a href="#循环前缀相关" class="headerlink" title="循环前缀相关"></a>循环前缀相关</h2><blockquote><p>循环前缀（Cyclic Prefix，CP）的作用：避免符号间干扰和消除子载波间干扰，如何深入理解这个问题，主要从公式的角度进行推导和分析，再结合MATLAB仿真进行验证。</p></blockquote><h3 id="多径信道传输模型"><a href="#多径信道传输模型" class="headerlink" title="多径信道传输模型"></a>多径信道传输模型</h3><p>考虑线性时不变系统：</p><script type="math/tex; mode=display">y(t)=h(t)*x(t)=\int h(t)x(t-\tau)d\tau\tag1</script><p>其中，$x(t)$表示输入信号，$h(t)$表示信号冲激响应，$y(t)$表示接收信号。离散信号表达式为：</p><script type="math/tex; mode=display">y(n)=\sum_{l=0}^{L-1} h(l)x(n-l)\tag2</script><p>上式为多径信道下的信号传输模型，其中$L$表示多径信道的阶数。</p><h3 id="OFDM循环前缀的作用"><a href="#OFDM循环前缀的作用" class="headerlink" title="OFDM循环前缀的作用"></a>OFDM循环前缀的作用</h3><p>对于OFDM信号而言，发射信号$x(n)$由 IFFT 运算和添加CP得到，其有效信号的表达式为（即IDFT的公式）：</p><script type="math/tex; mode=display">x(n)=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} X(k)e^{j2\pi \frac{nk}{N}},n=1,\dots,N,k=1,\dots,N</script><p>式中，$X(k)$为第$k$个子载波上的发射信号，$N$为IFFT的点数（也是一个OFDM符号时域有效信号 $x(n)$的样点数目。</p><blockquote><p>接下来，需要把式$(2)$中的卷积写成矩阵乘法的形式：</p><p>分析过程：假设$L$是多径的的数目，不失一般地，先考虑$y(0)$的表达式，然后利用数学归纳法，写出接收信号的矩阵表达。</p><script type="math/tex; mode=display">y(0)=\sum_{l=0}^{L-1}h(l)x(-l)=h(0)x(0)+h(1)x(-1)+\dots+h(L-1)x(-L+1)</script></blockquote><p>对于单个OFDM符号，CP长度为$N_{CP}$，则接收信号的矩阵表达式为：</p><script type="math/tex; mode=display">\begin{bmatrix}y(-N_{CP})\\ \vdots\\y(-1)\\y(0)\\y(1)\\y(2)\\ \vdots\\y(N-2)\\y(N-1)\end{bmatrix}=\begin{bmatrix}h(0)&0&0&0&0&0&0&0&0\\ \vdots & \ddots&0&0&0&0&0&0&0\\h(L-1)&\cdots&h(0)&0&0&0&0&0&0\\0&h(L-1)&\cdots&h(0)&0&0&0&0&0\\0&0&\ddots&\vdots&h(0)&0&0&0&0\\0&0&0&h(L-1)&&h(0)&0&0&0\\0&0&0&0&\ddots&&\ddots&0&0\\0&0&0&0&0&\ddots&&h(0)&0\\0&0&0&0&0&0&h(L-1)&\cdots&h(0)\end{bmatrix}\begin{bmatrix}x(-N_{CP})\\\vdots\\x(-1)\\x(0)\\x(1)\\x(2)\\\vdots\\x(N-2)\\x(N-1)\end{bmatrix}\tag4</script><p>==<strong>CP的第一个作用：避免符号间干扰。</strong>==由于多径的作用，前一时刻的信号会对当前时刻的信号造成影响。因此，为了保证上一个OFDM不会对当前OFDM符号造成影响，CP的长度必须满足$N_{CP}\ge L$，上式$(4)$中，$N_{CP}= L$。（从两个方向考虑问题，物理意义直观理解，如果多径时延大于$N_{CP}$，接收信号将不全是一个OFDM符号的信息，会有下一个符号信息的干扰，导致后续处理分不开来；数学公式角度理解：上述矩阵成立的边界，即为$N_{CP}\ge L-1$，因为$x,y$这两个列向量长度有系统决定，是确定的形式，L的范围只能存在边界条件，即可得出结论）。</p><p>==CP 的第二个作用：消除子载波干扰==。下面进行推导。</p><h3 id="循环前缀进一步理解（消除子载波干扰）"><a href="#循环前缀进一步理解（消除子载波干扰）" class="headerlink" title="循环前缀进一步理解（消除子载波干扰）"></a>循环前缀进一步理解（消除子载波干扰）</h3><blockquote><p>由CP的定义可知，$x(-1)=x(N-1),\dots,x(-N_{CP})=x(N-N_{CP})$。</p><p><img src="/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image-20241028171132568.png" alt="image-20241028171132568" style="zoom:30%;"></p></blockquote><p>接收端去掉CP，可以将上式$(4)$进行化简（即考虑$N_{CP}= L$的情况）：</p><script type="math/tex; mode=display">\begin{bmatrix}y(0)\\y(1)\\y(2)\\\vdots\\y(N-2)\\y(N-1)\end{bmatrix}=\begin{bmatrix}0&h(L-1)&\cdots&h(0)&0&0&0&0&0\\0&0&\ddots&\vdots&h(0)&0&0&0&0\\0&0&0&h(L-1)&&h(0)&0&0&0\\0&0&0&0&\ddots&&\ddots&0&0\\0&0&0&0&0&\ddots&&h(0)&0\\0&0&0&0&0&0&h(L-1)&\cdots&h(0)\end{bmatrix}\begin{bmatrix}x(-N_{CP})\\\vdots\\x(-1)\\x(0)\\x(1)\\x(2)\\\vdots\\x(N-2)\\x(N-1)\end{bmatrix}\tag5</script><p>利用CP的性质，可以进一步得到：</p><script type="math/tex; mode=display">\begin{bmatrix}y(0)\\y(1)\\y(2)\\\vdots\\y(N-2)\\y(N-1)\end{bmatrix}=\begin{bmatrix}h(0)&0&0&0&h(L-1)&h(1)\\\vdots&h(0)&0&0&0&h(L-1)\\h(L-1)&&h(0)&0&0&0\\0&\ddots&&\ddots&0&0\\0&0&\ddots&&h(0)&0\\0&0&0&h(L-1)&\cdots&h(0)\end{bmatrix}\begin{bmatrix}x(0)\\x(1)\\x(2)\\\vdots\\x(N-2)\\x(N-1)\end{bmatrix}\tag6</script><p>观察式$(5)$和$(6)$的$h$矩阵，其实质上将式$(5)$中信道矩阵的左上角元素，搬移到式$(6)$中信道矩阵的右上角，这两个等式完全等价，即CP-OFDM将线性<strong>==卷积运算转换为了循环卷积运算==</strong>。</p><blockquote><p>实际上，时域线性卷积≠频域相乘，而是时域循环卷积=频域相乘，引入循环前缀，正好将线性卷积转到循环卷积。</p></blockquote><script type="math/tex; mode=display">\mathbf{y}=\mathbf{Gx}\tag7</script><p>其中，$\mathbf{G}\in \mathbb{C} ^{N\times N}$为时域信道矩阵。根据OFDM接收端的操作，需对接收信号进行FFT运算，可以得到频域信号形式，即</p><script type="math/tex; mode=display">\mathbf{r}=\mathbf{F}\mathbf{y}=\frac{1}{N}\mathbf{F}\mathbf{G}\mathbf{F}^{H}\mathbf{s}\tag8</script><p>式中，$\mathbf{F}\in \mathbb{C} ^{N\times N}$表示傅里叶矩阵，性质：$\mathbf{F}\mathbf{F}^{H}=NI$，$\mathbf{s}=[X(1),\dots,X(N)]^T\in ^{N\times 1}$表示频域发射信号。</p><p><strong>注意</strong>：式中$\mathbf{G}$是一个Toeplitz矩阵，具有循环移位特性。</p><p>定义 $\mathbf{H}=\frac{1}{N}\mathbf{F}\mathbf{G}\mathbf{F}^{H}$，利用 <a href="https://baike.baidu.com/item/托普利兹矩阵/5735426?fr=aladdin">托普利兹矩阵_百度百科</a>的性质，则 $\mathbf{H}$是一个对角阵，式 $(8)$可以表示为：</p><script type="math/tex; mode=display">\begin{bmatrix}r(0)\\r(1)\\r(2)\\\vdots\\r(N-1)\end{bmatrix}=\begin{bmatrix}H(0)\\&\ddots\\&&H(k)\\&&&\ddots\\&&&&H(N-1)\end{bmatrix}\begin{bmatrix}X(0)\\\vdots\\X(k)\\\vdots\\X(N-1)\end{bmatrix}\tag9</script><p>式中，$H(k)$表示 $\mathbf{H}$的第$k$个对角线元素，从式 $(9)$可以看到，每一个子载波的接收信号与发射信号一一对应，且其他子载波的信号对当前子载波完全没有影响。也就是说，子载波之间不会产生任何干扰，即消除了子载波间干扰。OFDM结合循环前缀，可以使信道均衡、信号解调等在频域并行处理，大大降低了系统复杂度。</p><p>有两种说法：CP —&gt; 实现OFDM的循环扩展（为了某种连续性）。</p><p>进一步地，分析OFDM频域与时域信道系数的关系，即$H$和$h$的关系：</p><p>解决这一问题，需要考虑矩阵的特征值和特征向量：</p><p>由$\mathbf{H}$是对角阵可知，$H(k)$是Toeplitz矩阵$\mathbf{G}$的特征值，相应的特征向量为 $\mathbf{F}^{H}$的第 $k$列。理由：$\mathbf{F}^H\mathbf{H}=\mathbf{G}\mathbf{F}^H$.（矩阵分析源头）</p><p>考虑矩阵两边的第$k$个列向量，可得$\mathbf{Gf}_k = H(k)\mathbf{f}_k$，其中$\mathbf{f}_k$是$\mathbf{F}^H$的第$k$列，也就是$\mathbf{F}$的第$k$行。这与特征值和特征向量的表达式相同。基于以上讨论，我们下面来说明如何计算$H(k)$。</p><p>定义：$W_N = e^{-\frac{j2\pi}{N}}$，$\mathbf{Gf}_k = H(k)\mathbf{f}_k$的等价形式，即</p><script type="math/tex; mode=display">\frac{1}{\sqrt{N}}\begin{bmatrix}p_0 & p_1 & p_2 & \cdots & p_{N-1} \\p_{N-1} & p_0 & p_1 & \cdots & p_{N-2} \\p_{N-2} & p_{N-1} & p_0 & \cdots & p_{N-3} \\\vdots & \vdots & \vdots & \ddots & \vdots \\p_1 & p_2 & p_3 & \cdots & p_0\end{bmatrix}\begin{bmatrix}W_N^{0} \\W_N^{-k} \\W_N^{-2k} \\\vdots \\W_N^{-(N-1)k}\end{bmatrix}=\frac{1}{\sqrt{N}}H(k)\begin{bmatrix}W_N^{0} \\W_N^{-k} \\W_N^{-2k} \\\vdots \\W_N^{-(N-1)k}\end{bmatrix}\tag{10}</script><p>为了计算$H(k)$的表达式，我们观察式（6）和（10）中的Toeplitz矩阵$\mathbf{G}$和$\mathbf{P}$，有$\mathbf{P}_{m,n} = p_{(n-m)\mod N}$, $p_l = h_{(N-l)\mod N}$，其中$m, n, l = 0, 1, 2, \ldots, N-1$。</p><p>因此，式（10）等号左边：矩阵$\mathbf{P}$的第$(m+1)$行与IDFT矩阵第$k$列的内积有</p><script type="math/tex; mode=display">\frac{1}{\sqrt{N}} \sum_{n=0}^{N-1} p_{(n-m)_N} W_N^{-nk} = \frac{1}{\sqrt{N}} W_N^{-mk} \sum_{n=0}^{N-1} p_{(n-m)_N} W_N^{-(n-m)_N k} = \frac{1}{\sqrt{N}} W_N^{-mk} \sum_{l=0}^{N-1} p_l W_N^{-lk}\tag{11}</script><p>式中，第1个等号利用了性质$W_N^{-(n-m)k} = W_N^{-(n-m)_N k}$（以$N$为周期的周期性）。为进一步计算式（11）的求和项，我们定义$H_k = \sum_{l=0}^{N-1} p_l W_N^{-lk}$ ，即</p><script type="math/tex; mode=display">H_k = \sum_{l=0}^{N-1} p_l W_N^{-lk} = \sum_{l=0}^{N-1} h_{(N-l)_N} W_N^{-lk} = \sum_{l=0}^{N-1} h_{(N-l)_N} W_N^{(N-l)_N k} = \sum_{l'=0}^{N-1} h_{l'} W_N^{l'k}\tag{12}</script><p>式中，第3个等号利用了性质$W_N^{Nk} = 1$，$W_N^{(N-l)k} = W_N^{(N-l)_N k}$。</p><p>可以看到，频域信道系数$H_k$恰巧是时域信道系数$h_{l’}, l’ = 0, 1, \ldots, N-1$的傅里叶变换！</p><h3 id="线性卷积和循环卷积的转换"><a href="#线性卷积和循环卷积的转换" class="headerlink" title="线性卷积和循环卷积的转换"></a>线性卷积和循环卷积的转换</h3><blockquote><p>参考书籍《<em>Wireless Communication Systems in Matlab, Second Edition</em>》</p></blockquote><p>下面给出一个简单的<em>MATLAB</em>程序：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%========================================================================%</span></span><br><span class="line"><span class="comment">%:此程序用来测试《Wireless Communication Systems in Matlab, Second Edition》</span></span><br><span class="line"><span class="comment">%:第14章OFDM的前向解调算法</span></span><br><span class="line"><span class="comment">%========================================================================%</span></span><br><span class="line"><span class="comment">%% 线性卷积与循环卷积转化</span></span><br><span class="line">N = <span class="number">8</span>; <span class="comment">%period of DFT</span></span><br><span class="line">s = <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">h = <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">lin_s_h = conv(h, s) <span class="comment">%linear convolution of h and s</span></span><br><span class="line">cir_s_h = cconv(h, s, N) <span class="comment">%#ok&lt;*NOPTS&gt; %circular convolution of h and s with period N</span></span><br><span class="line">Ncp = <span class="number">2</span>; <span class="comment">%number of symbols to copy and paste for CP</span></span><br><span class="line">s_cp = [s(<span class="keyword">end</span> - Ncp + <span class="number">1</span>:<span class="keyword">end</span>) s]; <span class="comment">%copy last Ncp syms from s, add as prefix</span></span><br><span class="line">lin_scp_h = conv(h, s_cp) <span class="comment">%linear conv. of CP-OFDM symbol s_cp and CIR h</span></span><br><span class="line">r = lin_scp_h(Ncp + <span class="number">1</span>:N + Ncp) <span class="comment">%cut from index Ncp+1 to N+Ncp</span></span><br><span class="line"><span class="comment">%% 验证循环卷积=IDFT&#123;DFT&#123;h[n]&#125; x DFT&#123;s[n]&#125;&#125;</span></span><br><span class="line">R = fft(r, N); <span class="comment">%frequency response of received signal</span></span><br><span class="line">H = fft(h, N); <span class="comment">%frequency response of CIR</span></span><br><span class="line">S = fft(s, N); <span class="comment">%frequency response of OFDM signal (non CP)</span></span><br><span class="line">r1 = ifft(S .* H); <span class="comment">%IFFT of product of individual DFTs</span></span><br><span class="line">display([<span class="string">&#x27;IFFT(DFT(H)*DFT(S)) : &#x27;</span>, num2str(r1)])</span><br><span class="line">display([<span class="string">&#x27;cconv(s,h): &#x27;</span>, num2str(r)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OFDM信号仿真部分代码"><a href="#OFDM信号仿真部分代码" class="headerlink" title="OFDM信号仿真部分代码"></a>OFDM信号仿真部分代码</h3><blockquote><p>以下为一个OFDM误码率仿真示例：</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">% DATA: 2024-9-12-22:00</span></span><br><span class="line"><span class="comment">% Author: Poster</span></span><br><span class="line"><span class="comment">% Description: This is a simulation of OFDM over AWGN channel.</span></span><br><span class="line"><span class="comment">%:注:Tx-Signal采用列向量的形式;</span></span><br><span class="line"><span class="comment">%:注:MATLAB采用优先采用列向量进行存储,按列运算速度相对较快</span></span><br><span class="line"><span class="comment">%------------Simulation parameters---------%</span></span><br><span class="line">MOD_TYPE = <span class="string">&#x27;PSK&#x27;</span>; <span class="comment">% Modulation type&#x27;</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">% Constellation size</span></span><br><span class="line">phase_init = <span class="built_in">pi</span> / M; <span class="comment">% Initial phase</span></span><br><span class="line">N = <span class="number">64</span>; <span class="comment">% FFT size</span></span><br><span class="line">Ncp = <span class="number">16</span>; <span class="comment">% number of symbols in the cyclic prefix</span></span><br><span class="line">Num = <span class="number">1e5</span>; <span class="comment">% Number of OFDM Symbols to transmit</span></span><br><span class="line">EbN0dB = <span class="number">0</span>:<span class="number">2</span>:<span class="number">20</span>; <span class="comment">% bit to noise ratio</span></span><br><span class="line">k = <span class="built_in">log2</span>(M); <span class="comment">% number of bits per symbol</span></span><br><span class="line">EsN0dB = <span class="number">10</span> * <span class="built_in">log10</span>(k) + EbN0dB; <span class="comment">% convert to symbol energy to noise ratio</span></span><br><span class="line">errors = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(EsN0dB)); <span class="comment">%to store symbol errors</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(EsN0dB)</span><br><span class="line">    <span class="keyword">for</span> Sym = <span class="number">1</span>:Num <span class="comment">% Monte Carlo Simulation</span></span><br><span class="line">        <span class="comment">%--------Constellation Mapping-------%</span></span><br><span class="line">        symbols_data = randi([<span class="number">0</span> M - <span class="number">1</span>], N, <span class="number">1</span>); <span class="comment">% Random symbols</span></span><br><span class="line">        X = pskmod(symbols_data, M, phase_init); <span class="comment">% PSK modulation</span></span><br><span class="line">        <span class="comment">%--------------Transmitter-----------%</span></span><br><span class="line">        x = ifft(X, N); <span class="comment">% IDFT</span></span><br><span class="line">        s = add_cyclic_prefix(x, Ncp); <span class="comment">% Add CP</span></span><br><span class="line">        <span class="comment">%----------------Channel-------------%</span></span><br><span class="line">        r = add_awgn_noise(s, EsN0dB(<span class="built_in">i</span>)); <span class="comment">% Add AWGN noise r = s + n</span></span><br><span class="line">        <span class="comment">%---------------Receiver-------------%</span></span><br><span class="line">        y = remove_cyclic_prefix(r, Ncp, N); <span class="comment">% remove CP</span></span><br><span class="line">        Y = fft(y, N); <span class="comment">% DFT</span></span><br><span class="line">        symbols_data_cap = pskdemod(Y, M, phase_init); <span class="comment">% PSK demodulation</span></span><br><span class="line">        <span class="comment">%------------error count-------------%</span></span><br><span class="line">        numErrors = sum(symbols_data ~= symbols_data_cap); <span class="comment">% Count errors</span></span><br><span class="line">        errors(<span class="built_in">i</span>) = errors(<span class="built_in">i</span>) + numErrors; <span class="comment">% Update error count</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">simulatedSER = errors / (Num * N); <span class="comment">% Symbol Error Rate</span></span><br><span class="line">theoreticalSER = ser_awgn(EbN0dB, MOD_TYPE, M);</span><br><span class="line"><span class="comment">% Plot theoretical curves and simulated BER points</span></span><br><span class="line"><span class="built_in">plot</span>(EbN0dB, <span class="built_in">log10</span>(simulatedSER), <span class="string">&#x27;ro&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(EbN0dB, <span class="built_in">log10</span>(theoreticalSER), <span class="string">&#x27;r-&#x27;</span>); grid on;</span><br><span class="line">title([<span class="string">&#x27;Performance of &#x27;</span>, num2str(M), <span class="string">&#x27;-&#x27;</span>, MOD_TYPE, <span class="string">&#x27; OFDM over AWGN channel&#x27;</span>]);</span><br><span class="line">xlabel(<span class="string">&#x27;Eb/N0 (dB)&#x27;</span>); ylabel(<span class="string">&#x27;Symbol Error Rate&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;simulated&#x27;</span>, <span class="string">&#x27;theoretical&#x27;</span>);</span><br><span class="line"><span class="comment">%=============Function Definition==========%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span> = <span class="title">add_cyclic_prefix</span><span class="params">(x, Ncp)</span></span></span><br><span class="line">    <span class="comment">%function to add cyclic prefix to the generated OFDM symbol x that</span></span><br><span class="line">    <span class="comment">%is generated at the output of the IDFT block</span></span><br><span class="line">    <span class="comment">% x - ofdm symbol without CP (output of IDFT block)</span></span><br><span class="line">    <span class="comment">% Ncp-num. of samples at x&#x27;s end that will copied to its beginning</span></span><br><span class="line">    <span class="comment">% s - returns the cyclic prefixed OFDM symbol</span></span><br><span class="line">    s = [x(<span class="keyword">end</span> - Ncp + <span class="number">1</span>:<span class="keyword">end</span>); x]; <span class="comment">%Cyclic prefixed OFDM symbol</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[r, n, N0]</span> = <span class="title">add_awgn_noise</span><span class="params">(s, SNRdB, L)</span></span></span><br><span class="line">    <span class="comment">%Function to add AWGN to the given signal</span></span><br><span class="line">    <span class="comment">%[r,n,N0]= add_awgn_noise(s,SNRdB) adds AWGN noise vector to signal</span></span><br><span class="line">    <span class="comment">%&#x27;s&#x27; to generate a %resulting signal vector &#x27;r&#x27; of specified SNR</span></span><br><span class="line">    <span class="comment">%in dB. It also returns the noise vector &#x27;n&#x27; that is added to the</span></span><br><span class="line">    <span class="comment">%signal &#x27;s&#x27; and the spectral density N0 of noise added</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">%[r,n,N0]= add_awgn_noise(s,SNRdB,L) adds AWGN noise vector to</span></span><br><span class="line">    <span class="comment">%signal &#x27;s&#x27; to generate a resulting signal vector &#x27;r&#x27; of specified</span></span><br><span class="line">    <span class="comment">%SNR in dB. The parameter &#x27;L&#x27; specifies the oversampling ratio used</span></span><br><span class="line">    <span class="comment">%in the system (for waveform simulation). It also returns the noise</span></span><br><span class="line">    <span class="comment">%vector &#x27;n&#x27; that is added to the signal &#x27;s&#x27; and the spectral</span></span><br><span class="line">    <span class="comment">%density N0 of noise added</span></span><br><span class="line">    s_temp = s;</span><br><span class="line">    <span class="keyword">if</span> iscolumn(s), s = s.&#x27;; <span class="keyword">end</span> <span class="comment">%to return the result in same dim as &#x27;s&#x27;</span></span><br><span class="line">    <span class="built_in">gamma</span> = <span class="number">10</span> ^ (SNRdB / <span class="number">10</span>); <span class="comment">%SNR to linear scale</span></span><br><span class="line">    <span class="keyword">if</span> nargin == <span class="number">2</span>, L = <span class="number">1</span>; <span class="keyword">end</span> <span class="comment">%if third argument is not given, set it to 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isvector</span>(s)</span><br><span class="line">        P = L * sum(<span class="built_in">abs</span>(s) .^ <span class="number">2</span>) / <span class="built_in">length</span>(s); <span class="comment">%Actual power in the vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">%for multi-dimensional signals like MFSK</span></span><br><span class="line">        P = L * sum(sum(<span class="built_in">abs</span>(s) .^ <span class="number">2</span>)) / <span class="built_in">length</span>(s); <span class="comment">%if s is a matrix [MxN]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    N0 = P / <span class="built_in">gamma</span>; <span class="comment">%Find the noise spectral density</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isreal</span>(s))</span><br><span class="line">        n = <span class="built_in">sqrt</span>(N0 / <span class="number">2</span>) * <span class="built_in">randn</span>(<span class="built_in">size</span>(s)); <span class="comment">%computed noise</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="built_in">sqrt</span>(N0 / <span class="number">2</span>) * (<span class="built_in">randn</span>(<span class="built_in">size</span>(s)) + <span class="number">1</span><span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="built_in">size</span>(s))); <span class="comment">%computed noise</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    r = s + n; <span class="comment">%received signal</span></span><br><span class="line">    <span class="keyword">if</span> iscolumn(s_temp), r = r.&#x27;; <span class="keyword">end</span> <span class="comment">%return r in original format as s</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">remove_cyclic_prefix</span><span class="params">(r, Ncp, N)</span></span></span><br><span class="line">    <span class="comment">%function to remove cyclic prefix from the received OFDM symbol r</span></span><br><span class="line">    <span class="comment">% r - received ofdm symbol with CP</span></span><br><span class="line">    <span class="comment">% Ncp - num. of samples at beginning of r that need to be removed</span></span><br><span class="line">    <span class="comment">% N - number of samples in a single OFDM symbol</span></span><br><span class="line">    <span class="comment">% y - returns the OFDM symbol without cyclic prefix</span></span><br><span class="line">    y = r(Ncp + <span class="number">1</span>:N + Ncp); <span class="comment">%cut from index Ncp+1 to N+Ncp</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[SER]</span> = <span class="title">ser_awgn</span><span class="params">(EbN0dB, MOD_TYPE, M, COHERENCE)</span></span></span><br><span class="line">    <span class="comment">%Theoretical Symbol Error Rate for various modulations over AWGN</span></span><br><span class="line">    <span class="comment">%EbN0dB - list of SNR per bit values</span></span><br><span class="line">    <span class="comment">%MOD_TYPE - &#x27;BPSK&#x27;,&#x27;PSK&#x27;,&#x27;QAM&#x27;,&#x27;PAM&#x27;,&#x27;FSK&#x27;</span></span><br><span class="line">    <span class="comment">%M - Modulation level for the chosen modulation</span></span><br><span class="line">    <span class="comment">% - For PSK,PAM,FSK M can be any power of 2</span></span><br><span class="line">    <span class="comment">% - For QAM M must be even power of 2 (square QAM only)</span></span><br><span class="line">    <span class="comment">%Parameter COHERENCE is only applicable for FSK modulation</span></span><br><span class="line">    <span class="comment">%COHERENCE = &#x27;coherent&#x27; for coherent FSK detection</span></span><br><span class="line">    <span class="comment">% = &#x27;noncoherent&#x27; for noncoherent FSK detection</span></span><br><span class="line">    gamma_b = <span class="number">10</span> .^ (EbN0dB / <span class="number">10</span>); <span class="comment">%SNR per bit in linear scale</span></span><br><span class="line">    gamma_s = <span class="built_in">log2</span>(M) * gamma_b; <span class="comment">%SNR per symbol in linear scale</span></span><br><span class="line">    SER = <span class="built_in">zeros</span>(<span class="built_in">size</span>(EbN0dB));</span><br><span class="line">    <span class="keyword">switch</span> lower(MOD_TYPE)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;bpsk&#x27;</span></span><br><span class="line">            SER = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b));</span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;psk&#x27;</span>, <span class="string">&#x27;mpsk&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> M == <span class="number">2</span> <span class="comment">%for BPSK</span></span><br><span class="line">                SER = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> M == <span class="number">4</span> <span class="comment">%for QPSK</span></span><br><span class="line">                    Q = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b)); SER = <span class="number">2</span> * Q - Q .^ <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">%for other higher order M-ary PSK</span></span><br><span class="line">                    SER = <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_s) * <span class="built_in">sin</span>(<span class="built_in">pi</span> / M));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;qam&#x27;</span>, <span class="string">&#x27;mqam&#x27;</span>&#125;</span><br><span class="line">            SER = <span class="number">1</span> - (<span class="number">1</span> - (<span class="number">1</span> - <span class="number">1</span> / <span class="built_in">sqrt</span>(M)) * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>/<span class="number">2</span> * gamma_s / (M - <span class="number">1</span>)))) .^ <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;fsk&#x27;</span>, <span class="string">&#x27;mfsk&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> strcmpi(COHERENCE, <span class="string">&#x27;coherent&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">length</span>(gamma_s)</span><br><span class="line">                    fun = @(q) (<span class="number">0.5</span> * <span class="built_in">erfc</span>((-q - <span class="built_in">sqrt</span>(<span class="number">2</span> .* gamma_s(ii))) / <span class="built_in">sqrt</span>(<span class="number">2</span>))) .^ (M - <span class="number">1</span>) .* <span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>) .* <span class="built_in">exp</span>(-q .^ <span class="number">2</span>/<span class="number">2</span>);</span><br><span class="line">                    SER(ii) = <span class="number">1</span> - integral(fun, -<span class="built_in">inf</span>, <span class="built_in">inf</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">%Default compute for noncoherent</span></span><br><span class="line">                <span class="keyword">for</span> jj = <span class="number">1</span>:<span class="built_in">length</span>(gamma_s)</span><br><span class="line">                    summ = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M - <span class="number">1</span></span><br><span class="line">                        n = M - <span class="number">1</span>; r = <span class="built_in">i</span>; <span class="comment">%for nCr formula</span></span><br><span class="line">                        summ = summ + (<span class="number">-1</span>) .^ (<span class="built_in">i</span> + <span class="number">1</span>) ./ (<span class="built_in">i</span> + <span class="number">1</span>) .* prod((n - r + <span class="number">1</span>:n) ./ (<span class="number">1</span>:r)) .* <span class="built_in">exp</span>(-<span class="built_in">i</span> ./ (<span class="built_in">i</span> + <span class="number">1</span>) .* gamma_s(jj));</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    SER(jj) = summ; <span class="comment">%Theoretical SER for non-coherent detection</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;pam&#x27;</span>, <span class="string">&#x27;mpam&#x27;</span>&#125;</span><br><span class="line">            SER = <span class="number">2</span> * (<span class="number">1</span> - <span class="number">1</span> / M) * <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(<span class="number">3</span> * gamma_s / (M ^ <span class="number">2</span> - <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">otherwise</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;ser_awgn.m: Invalid modulation (MOD_TYPE) selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思考知识记录</title>
      <link href="/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="日常思考及知识点记录"><a href="#日常思考及知识点记录" class="headerlink" title="日常思考及知识点记录"></a>日常思考及知识点记录</h1><blockquote><p>此文档主要记录一些日常经过思考的问题，以及一些容易混淆的知识点，不限于专业知识，可能包括其他学科……</p></blockquote><h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><h3 id="充要条件的充分和必要性"><a href="#充要条件的充分和必要性" class="headerlink" title="充要条件的充分和必要性"></a>充要条件的充分和必要性</h3><blockquote><p>充要条件的充分性和必要性怎么区分？</p><p>记住一点：根据条件椎结论就是证明充分性，根据结论推条件就是证明必要性</p></blockquote><p>充要条件的表述一般有3钟表述方式：</p><ul><li>求证：$A$是$B$的充要条件</li><li>求证：$A$的充要条件是$B$</li><li>求证：$A\Longleftrightarrow B $（等价于第二条，即$A$的充要条件是$B$）</li></ul><blockquote><p>怎么看哪个是条件呢？如上提取主谓宾，谁是条件一目了然。在①中，A是条件，由A推出B就是证明充分性，反之由B推出A就是证明必要性;在②③中，条件是B，所以由B推出A就是证明充分性，反之由A推出B就是证明必要性。</p></blockquote><h3 id="集合类相关"><a href="#集合类相关" class="headerlink" title="集合类相关"></a>集合类相关</h3><ul><li>常用集合的字母含义</li></ul><p>​    $\mathbb{N}$：自然数集；$\mathbb{Z}$：整数集；$\mathbb{Q}$：有理数集；$\mathbb{R}$：实数集；$\mathbb{C} $：复数集；</p><h2 id="专业类"><a href="#专业类" class="headerlink" title="专业类"></a>专业类</h2><h3 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h3><h4 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h4><blockquote><p>事件A和事件B，事件A先发生，事件B后发生，（事件B发生的第一步有$n$条路径）。全概率公式用于求事件B的概率，而贝叶斯公式用于反推事件$A_i$的概率。</p></blockquote><p><img src="/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/figure.png" alt="figure"></p><script type="math/tex; mode=display">\begin{aligned}P(B) &= P(A_1)P(B \mid A_1)+P(A_2)P(B \mid A_2)+\dots+P(A_n)P(B \mid A_n)\\     &= \sum_{i=1}^{n}P(A_i)P(B \mid A_i)\end{aligned}\tag{1}</script><script type="math/tex; mode=display">P(A_i\mid B)=\frac{P(A_i)P(B\mid A_i)}{P(B)}=\frac{P(A_i)P(B\mid A_i)}{\sum_{i=1}^{N}P(A_i)P(B\mid A_i)}\tag{2}</script><blockquote><p>上式（1）即为全概率公式，式（2）为贝叶斯公式</p><p>在通信应用中，接收端收到的信号一般可视为事件B，因此推导接收端的最佳接收性能公式时，通常使用贝叶斯公式。</p></blockquote><h3 id="信号与系统"><a href="#信号与系统" class="headerlink" title="信号与系统"></a>信号与系统</h3><h4 id="傅里叶变换的本质"><a href="#傅里叶变换的本质" class="headerlink" title="傅里叶变换的本质"></a>傅里叶变换的本质</h4><blockquote><p>在此首先感谢B站UP主 《喵星考拉》的【硬核】系列视频讲解，本部分有很多的细节都是从她的视频学习得到。</p><p>数学是万物根本，是解释其核心原理最直观的体现。</p></blockquote><ul><li><p>傅里叶级数</p><ul><li>傅里叶级数的系数<script type="math/tex; mode=display">F(n)=\frac{1}{T}\int_Tf(t)e^{-jn2\pi f_0t}dt\tag1</script></li></ul></li></ul><ul><li>用傅里叶级数的系数复原原函数<script type="math/tex; mode=display">f(t)=\sum_{-\infty}^{+\infty}F(n)e^{jn2\pi f_0t}\tag2</script>傅里叶级数主要用于周期函数的分解，频率间隔 $\Delta f=f_0=1/T$.</li></ul><blockquote><p>个人觉得，这个视频最重要的一个结论：傅里叶级数的系数可以等价于<strong>函数内积</strong>；原函数可以理解为傅里叶系数的一堆<strong>线性组合</strong>；内积也可以理解为函数在另一空间的投影，对于复数而言，函数内积需对某一个复值取共轭，从距离的角度考虑这个问题，主要原因是$i^2=1$，例如：$(1+i)\times (1-i)=2=|(1+i)|^2$。所以在式$(1)$中$e$指数取了共轭。</p></blockquote><ul><li><p>傅里叶变换</p><p>傅里叶变换是从傅里叶级数推导而来，应用场景主要为非周期函数，当频率$\Delta f\to +\infty$，化简上式即可得到傅里叶变换的公式。</p><ul><li></li></ul></li></ul><h4 id="【进阶】拉普拉斯变换"><a href="#【进阶】拉普拉斯变换" class="headerlink" title="【进阶】拉普拉斯变换"></a>【进阶】拉普拉斯变换</h4><h3 id="数字通信"><a href="#数字通信" class="headerlink" title="数字通信"></a>数字通信</h3><h4 id="OFDM-System"><a href="#OFDM-System" class="headerlink" title="OFDM System"></a>OFDM System</h4>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代信号处理Ⅰ学习记录</title>
      <link href="/2024/10/14/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%861/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/14/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%861/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Modern-Digital-Signal-Processing"><a href="#Modern-Digital-Signal-Processing" class="headerlink" title="Modern Digital Signal Processing"></a>Modern Digital Signal Processing</h1><blockquote><p>Statistical     Random</p></blockquote><hr><ol><li>Linear Processing<ul><li>Fundamental<ul><li>Statistical Foundation</li><li>Orthogonal</li><li>Orthogonalization</li></ul></li><li>Typical<ul><li>Wiener,  Kalman</li></ul></li><li>Extension<ul><li>SVM, Kernel, Regularization</li></ul></li></ul></li><li>Adaptive Processing<ul><li>Adaptive Filter, LMS, RLS</li></ul></li><li>Spectral Processing<ul><li>Direct(Non-Parametric), Filter Banks</li></ul></li></ol><hr><blockquote><p>1950’s~1980’s     <strong>Linear, Orthogonal, Stationary, Gaussian</strong></p></blockquote><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><h3 id="Review-of-Probability-Theory"><a href="#Review-of-Probability-Theory" class="headerlink" title="Review of Probability Theory"></a>Review of Probability Theory</h3><p><strong>概率的定义：</strong></p><p>Uncertainty $\rightarrow$ Statistical Experiment $\rightarrow$ Sample Points $\rightarrow$ Sample Space $(\Omega)$ $\rightarrow$ Possibility(<strong>Prior</strong>) </p><p>$\rightarrow$ Probability(概率)     $P: X^\Omega\rightarrow[0,1]$</p><p><strong>概率与统计</strong></p><p>Data $\longrightarrow$ <strong>Model</strong> $\longrightarrow$ Decision    (Big Data: Data $\longrightarrow$ Decision)<br>        &emsp;&emsp;&ensp;$\Downarrow$   &emsp; &emsp;  &emsp;&emsp;  $\Downarrow$<br>&emsp; Statistics &emsp;&ensp;Probability </p><p>Random Variables: $X:\Omega\rightarrow R$ (Quantization)</p><p>$P(X=x)=P(\{w\in\Omega|Z(w)=x\})$</p><p>Discrete: $\Omega = \{w_1,w_2,\dots,w_n\}$. &emsp; 分布列：$P(X=x_k)=P_k$</p><p>Continue:</p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卫星链路计算</title>
      <link href="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/"/>
      <url>/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="卫星链路计算相关学习"><a href="#卫星链路计算相关学习" class="headerlink" title="卫星链路计算相关学习"></a>卫星链路计算相关学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>卫星链路计算是每次申请项目时必做的一个环节，我自己也参与计算了两三次，但总觉得自己理解的不够到位，尽管老师和师兄们说很简单，但我始终不相信自己，想从头到尾理解一遍，这也是写这篇博客的初衷。</p></blockquote><h2 id="卫星通信系统"><a href="#卫星通信系统" class="headerlink" title="卫星通信系统"></a>卫星通信系统</h2><blockquote><p>卫星通信系统从发端地球站到收端地球站的信息传输过程中，要经过</p><p><strong>上行链路（uplink）、卫星转发器（transponder）、下行链路（downlink）</strong></p></blockquote><ul><li><p>上行链路信号质量</p><p>取决于：卫星收到的信号功率电平和卫星接收系统的噪声功率电平大小</p></li><li><p>下行链路信号质量</p><p>取决于：收端地球站接收的信号功率电平和地球站接收系统的噪声功率电平的大小</p></li></ul><p>主要目的：尽量有效地在地球上两个通信点之间提供可靠有高质量的连接手段</p><h2 id="卫星链路计算中的相关参数"><a href="#卫星链路计算中的相关参数" class="headerlink" title="卫星链路计算中的相关参数"></a>卫星链路计算中的相关参数</h2><p>卫星链路计算中主要用到的相关参数有：</p><ul><li><strong>天线的增益与波束宽度</strong><ul><li><strong>有效全向辐射功率</strong></li><li><strong>自由空间传输损耗</strong></li><li><strong>噪声与损耗</strong></li><li><strong>转发器工作点</strong></li><li><strong>转发器的饱和通量密度</strong></li><li><strong>品质因数G/T</strong></li></ul></li></ul><h3 id="天线的增益与波束宽度"><a href="#天线的增益与波束宽度" class="headerlink" title="天线的增益与波束宽度"></a>天线的增益与波束宽度</h3><blockquote><p>卫星通信中，一般使用<strong>定向天线</strong>，即电磁能量聚焦在某一方向辐射</p></blockquote><p>天线的增益定义为：</p><script type="math/tex; mode=display">G=\frac{定向天线辐射时，接收点收到的最大功率}{全向天线辐射时，接收点收到的功率}</script><p>对于喇叭天线：</p><script type="math/tex; mode=display">G=\frac{4\pi A}{\lambda^2}\eta</script><p>式中，$A$为天线的口面面积；$\lambda$为工作波长$(m)$；$\eta$为天线效率（电功率与电磁波形式的功率转换时，会造成损失）。</p><p>由公式可以看出，<strong>采用较高的工作频率可以使较小口径天线获得同样大的天线增益</strong>。</p><p>抛物面天线波束的半功率点宽度近似为：</p><script type="math/tex; mode=display">\theta_\frac{1}{2}\approx70\frac{\lambda}{D}(°)</script><p>半功率角是指<strong>主瓣上场强为主射方向场强的</strong>$1/\sqrt2=0.707$时，即功率下降$1/2$时，两方向的夹角。</p><p><img src="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/image-20241012151251243.png" alt="image-20241012151251243" style="zoom:80%;"></p><h3 id="全向辐射功率"><a href="#全向辐射功率" class="headerlink" title="全向辐射功率"></a>全向辐射功率</h3><blockquote><p>卫星通信中用<strong>有效全向辐射功率$EIRP$</strong>来代表地球站或卫星发射系统的发射能力</p></blockquote><p>EIRP是天线所发射的功率$P_t$与该天线增益的乘积：</p><script type="math/tex; mode=display">EIRP=P_t\times G_t</script><p>上式表明：<strong>在最大辐射方向，定向天线所辐射的功率是全向天线在相同方向辐射功率的 $G_t$ 倍。</strong></p><p>描述了天线在轴线方向上的最大辐射功率</p><script type="math/tex; mode=display">EIRP(dBW)=P_T(dBW)+G_T(dBi)</script><h3 id="自由空间损耗（Free-Space-Path-Loss-FSPL）"><a href="#自由空间损耗（Free-Space-Path-Loss-FSPL）" class="headerlink" title="自由空间损耗（Free Space Path Loss,  FSPL）"></a>自由空间损耗（Free Space Path Loss,  FSPL）</h3><p>考虑理想通信系统，假设系统各部件没有损耗，传输媒质为自由空间，系统框图如下所示：</p><p><img src="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/image-20241012160040773.png" alt="image-20241012160040773" style="zoom:60%;"></p><p>$P_t$ 是发射功率；$Gt，Gr$ 分别为发射，接收天线增益； $d$ 为通信距离； $P_r$ 为接收机接收到的信号功率。</p><p>接收功率：</p><script type="math/tex; mode=display">P_R=P_TG_TG_R(\lambda/(4\pi d))^2=EIRP\cdot G_R(\lambda/(4\pi d))^2</script><p>定义自由空间损耗</p><script type="math/tex; mode=display">L_f=(4\pi d/\lambda)^2=(4\pi df/c)^2</script><p>自由空间传输损耗表征了两个全向天线闸，发射功率和接收功率之间的比值，即是天线间的传输损耗</p><p>实际中，定义距离$d$的单位为$km$，频率$f$的单位$GHz$，则自由空间损耗可表示为：</p><script type="math/tex; mode=display">L_f(dB)=92.44+20lg(d)+20lg(f)</script><p>当然，最常见的公式如下，其只是单位换算导致常数项产生差异：</p><script type="math/tex; mode=display">L_f(dB)=32.45+20lg d(km)+20lg f(MHz)</script><h3 id="雨衰"><a href="#雨衰" class="headerlink" title="雨衰"></a>雨衰</h3><p>雨衰随频率的增加而增加</p><p>雨衰对水平极化的影响远大于垂直极化的影响</p><h3 id="载波功率"><a href="#载波功率" class="headerlink" title="载波功率"></a>载波功率</h3><ul><li>载波接收功率$C$</li></ul><script type="math/tex; mode=display">[C]=[EIRP]+[G_R]-[L_p]</script><p>$[G_R]$：接收天线的增益（dBi）</p><p>$L_p$：自由空间损耗（dB）</p><p>$EIRP$：发射机的有效全向辐射功率（dBW）</p><ul><li>考虑发射馈线损耗$[L_{FT}]$(dB)，则$[EIRP]$为：</li></ul><script type="math/tex; mode=display">[EIRP]=[P_T]-[L_{FT}]+[G_T]</script><ul><li><p>接收机输入端的载波功率</p><!-- 同时考虑接收馈线损耗$[L_{FR}](dB)$、大气损耗$[L_a(dB)]$、其他损耗$[L_r(dB)]$，则接收机输入端的实际载波接收功率$[C(dBW)]$可以表示为 --><p>同时考虑接收馈线损耗$[L_{FR}]$(dB)、大气损耗$[L_a]$(dB)、其他损耗$[L_r]$(dB)，则接收机输入端的实际载波接收功率$[C]$(dBW)可以表示为</p><script type="math/tex; mode=display">[C]=\textcolor{ #BF3EFF}{[P_T]}-[L_{FT}]+\textcolor{ #BF3EFF}{[G_T]}+\textcolor{ #BF3EFF}{[G_R]}-\textcolor{ #BF3EFF}{[L_p]}-[L_{FR}]-[L_a]-[L_r]</script><script type="math/tex; mode=display">EIRP = \textcolor{ #BF3EFF}{[P_T]}-[L_{FT}]+\textcolor{ #BF3EFF}{[G_T]}</script></li></ul><h3 id="接收系统的噪声功率"><a href="#接收系统的噪声功率" class="headerlink" title="接收系统的噪声功率"></a>接收系统的噪声功率</h3><script type="math/tex; mode=display">N=kT_tB</script><p>N为进入接收系统的噪声功率；$T_t$为天线的等效噪声温度；$k=1.38\times 10^{-23}J/K$玻尔兹曼常数；$B$为接收系统的等效噪声带宽</p><h3 id="接收机输入端的载噪比与地球站性能因数"><a href="#接收机输入端的载噪比与地球站性能因数" class="headerlink" title="接收机输入端的载噪比与地球站性能因数"></a>接收机输入端的载噪比与地球站性能因数</h3><script type="math/tex; mode=display">\frac{C}{N}=\frac{P_TG_TG_R}{L_P}\cdot\frac{1}{kT_tB}</script><script type="math/tex; mode=display">\left [ \frac{C}{N}\right]=\left [EIRP\right]-\left [L_p\right]-\left [G_R\right]-10\lg (kT_tB)</script><script type="math/tex; mode=display">\left [EIRP\right]=\left [P_T\cdot G_T\right]=\left [P_T\right]+\left [G_T\right]</script><p>地球站接收机输入端的$[C/N]_E$</p><script type="math/tex; mode=display">\left [ \frac{C}{N} \right]_E=\left [EIRP\right]_S-\left [L_D\right]-\left [G{RE}\right]-10\lg (kT_tB)</script><h3 id="计算程序"><a href="#计算程序" class="headerlink" title="计算程序"></a>计算程序</h3><blockquote><p>下面是下行链路计算的一个MATLAB简单程序</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% @ DATA: 2024-10-12-17:19:49</span></span><br><span class="line"><span class="comment">% @ Author: Poster</span></span><br><span class="line"><span class="comment">% @ Description:</span></span><br><span class="line"><span class="comment">% @ Notes:</span></span><br><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 通信距离计算</span></span><br><span class="line">h = <span class="number">550</span>; <span class="comment">% 轨道高度(km)</span></span><br><span class="line">theta_deg = <span class="number">25</span>; <span class="comment">% 地球站至卫星的仰角(°)</span></span><br><span class="line">theta = deg2rad(theta_deg); <span class="comment">% rad</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;地面通信终端天线仰角: &#x27;</span>, num2str(theta_deg), <span class="string">&#x27;°&#x27;</span>]);</span><br><span class="line">RE = <span class="number">6378.14</span>; <span class="comment">% 地球半径(km)</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="built_in">asin</span>(RE / (RE + h) * <span class="built_in">cos</span>(theta)); <span class="comment">% 卫星到地心与到地球站的夹角(rad)</span></span><br><span class="line">beta_deg = <span class="built_in">beta</span> * <span class="number">180</span> / <span class="built_in">pi</span>; <span class="comment">% °</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;卫星天线对地张角: &#x27;</span>, num2str(beta_deg), <span class="string">&#x27;°&#x27;</span>]);</span><br><span class="line">alpha = <span class="built_in">pi</span> / <span class="number">2</span> - <span class="built_in">beta</span> - theta; <span class="comment">% 地心角(rad)</span></span><br><span class="line">d = RE * <span class="built_in">sin</span>(alpha) / <span class="built_in">sin</span>(<span class="built_in">beta</span>); <span class="comment">% 通信距离(km)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;通信距离: &#x27;</span>, num2str(d), <span class="string">&#x27;km&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 自由空间损耗计算</span></span><br><span class="line">fc = <span class="number">11.7e3</span>; <span class="comment">% carrier frequency(MHz)</span></span><br><span class="line">Lp = <span class="number">32.45</span> + <span class="number">20</span> * <span class="built_in">log10</span>(fc) + <span class="number">20</span> * <span class="built_in">log10</span>(d); <span class="comment">% Free Space Path Loss(dB)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;自由空间损耗: &#x27;</span>, num2str(Lp), <span class="string">&#x27;dB&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line">EIRP = <span class="number">36.7</span>; <span class="comment">% Effective Isotropic Radiated Power(dBm)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;有效全向辐射功率EIRP: &#x27;</span>, num2str(EIRP), <span class="string">&#x27;dBm&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 其他损耗</span></span><br><span class="line">La = <span class="number">2.4</span>; <span class="comment">% Atmospheric Loss(dB)</span></span><br><span class="line">Lr = <span class="number">1</span>; <span class="comment">% Other Loss(dB)</span></span><br><span class="line">Lfr = <span class="number">0</span>; <span class="comment">% 接收馈线损耗(dB)(天线指向损失;极化损失)</span></span><br><span class="line">L = Lp + La + Lr + Lfr; <span class="comment">% Total Loss(dB)</span></span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 地面终端 G/T</span></span><br><span class="line">G = <span class="number">32.8</span>; <span class="comment">% 天线增益(dBi)</span></span><br><span class="line">eta = <span class="number">0.5</span>; <span class="comment">% 天线效率</span></span><br><span class="line">aperture = <span class="number">2</span>; <span class="comment">% 天线孔径(m)</span></span><br><span class="line">lambda = <span class="number">3e8</span> / (fc * <span class="number">1e6</span>); <span class="comment">% 波长(m)</span></span><br><span class="line">G_c = <span class="number">10</span> * <span class="built_in">log10</span>(eta * <span class="number">4</span> * <span class="built_in">pi</span> * aperture / (lambda ^ <span class="number">2</span>)); <span class="comment">% 抛物面天线增益(dBi)</span></span><br><span class="line">T = <span class="number">300</span>; <span class="comment">%系统噪声温度</span></span><br><span class="line">GT = G - <span class="number">10</span> * <span class="built_in">log10</span>(T); <span class="comment">% 系统G/T比率(dB/K)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;系统G/T值: &#x27;</span>, num2str(GT), <span class="string">&#x27; dB/K&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 接收机载噪比</span></span><br><span class="line">B = <span class="number">250e6</span>; <span class="comment">% 接收机带宽(MHz)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;接收机带宽: &#x27;</span>, num2str(B / <span class="number">1e6</span>), <span class="string">&#x27;MHz&#x27;</span>]);</span><br><span class="line">cons = <span class="number">-228.6</span>; <span class="comment">% 玻尔兹曼常数(dBW/K/Hz)</span></span><br><span class="line">CN = EIRP - L + GT - <span class="number">10</span> * <span class="built_in">log10</span>(B) - cons; <span class="comment">% 接收机接收功率(dBm)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;载噪比C/N: &#x27;</span>, num2str(CN), <span class="string">&#x27;dB&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>通过载噪比，后续结合调制方式可以计算$E_b/N_0$，从而推算整个通信系统BER等系统参数。</p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 公式推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青春语句</title>
      <link href="/2024/10/07/%E7%94%9F%E6%B4%BB%E5%A8%B1%E4%B9%90/%E9%9D%92%E6%98%A5/"/>
      <url>/2024/10/07/%E7%94%9F%E6%B4%BB%E5%A8%B1%E4%B9%90/%E9%9D%92%E6%98%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="青春"><a href="#青春" class="headerlink" title="青春"></a>青春</h1><blockquote><p>“碧华映朱实，攀折青春时”。青春是“草长莺飞二月天，拂堤杨柳醉春烟”的年华美好，青春带着“倚门回首，却把青梅嗅”的甜蜜，青春也会走过“雾失楼台，月迷津渡”的困惑，但“少年负壮气，奋烈自有时”，青春总会激荡出“一身能擘两雕弧，虏骑千重只似无”的力量；张扬着“大鹏一日同风起，扶摇直上九万里”的义气；因为青春意味着奋发与成长，愿每个人都能永葆青春的状态，依旧“满身花雨又归来”。​</p><h1 id="君子志向：坚韧"><a href="#君子志向：坚韧" class="headerlink" title="君子志向：坚韧"></a>君子志向：坚韧</h1><p>月缺不改光，剑折不改刚”，有志向的人自信自强；“君子量不极，胸吞百川流”，有志向的人心有远方；“丈夫非无泪，不洒离别间”，有志向的人情深意长；“及时当勉励，岁月不待人”，有志向的人不会虚度时光；“人生感意气，功名谁复论”，有志向的人看淡名利；“感时思报国，拔剑起蒿莱”，有志向的人是最可靠的力量；“愿君学长松，慎勿作桃李”，新时代，新舞台，让我们“共矜然诺心，各负纵横志”。<br>“无情未必真豪杰”，英雄的身上，闪耀着人性的熠熠光辉，他们有“若遇早梅开，一枝应寄来”的高尚友情；有“不思量，自难忘”的真挚爱情；有“从今别去江南路，化作啼鹃带血归”的不舍乡情；有“生民百遗一，念之断人肠”的痛楚悲情；有“一寸丹心图报国，两行清泪为相思”的拳拳亲情；更有“生当作人杰，死亦为鬼雄”的满腔豪情；英雄的真情总会化为人间甘霖，“赤风洒雨露，春日在天涯”。 ​<br>“成败何足论，英雄自有真”。每一位英雄都在书写最真实的人生。“亦余心之所善兮，虽九死其犹未悔”，屈原的炽热情怀；“旄尽风霜节，心悬日月光”，苏武的不灭气节；“出师一表真名世，千载谁堪伯仲间”，诸葛亮的鞠躬尽瘁；“做事循天理，博爱惜生灵”，范仲淹的爽直磊落；“镜里朱颜都变尽，只有丹心难灭”，文天祥的至死不渝。英雄探寻着生命的真谛，“若有人知春去处，唤取归来同住”，让我们在经典中与英雄相伴。<br>英雄的本色是什么，是“雨打灯难灭，风吹色更明”的坚韧；是“一年三百六十日，多是横戈马上行”的不辞艰辛；是“高情已逐晓云空，不与梨花同梦”的超越平庸；是“男儿何不带吴钩，收取关山五十州”的满腔壮志；是“一腔热血勤珍重，洒去犹能化碧涛”的不惧牺牲；是“回看射雕处，千里暮云平”的襟怀坦荡；是“富贵非所愿，与人驻颜光”的无私奉献；“英雄自古常如此，愿逐月华流照君”，让我们在经典中，追随那些铿锵前行的脚步。<br>一首经典就是一个良师益友。“纷吾既有此内美兮，又重之以修能”教会我们成长；“谁知盘中餐，粒粒皆辛苦”教会我们珍惜；“我生本无乡，心安是归处”教会我们旷达；“纵浪大化中，不喜亦不惧”教会我们放下；“埋骨何须桑梓地，人生无处不青山”教会我们志向；与经典同行，诗词为伴。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切从这里开始</title>
      <link href="/2024/10/04/%E5%BC%80%E5%A7%8B/"/>
      <url>/2024/10/04/%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<pre><code>【主题配置】    https://butterfly.js.org/posts/ceeb73f/记录我的学习之旅</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
