<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>通信FPGA相关合集</title>
      <link href="/2024/10/31/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/02-FPGA/FPGA_Study/"/>
      <url>/2024/10/31/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/02-FPGA/FPGA_Study/</url>
      
        <content type="html"><![CDATA[<h1>通信FPGA相关</h1><h2 id="引言">引言</h2><h2 id="载波同步">载波同步</h2><a href="/2024/10/04/%E5%BC%80%E5%A7%8B/" title="一切从这里开始">一切从这里开始</a>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Verilog </tag>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFT-S-OFDM 波形设计</title>
      <link href="/2024/10/31/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/DFT-s-OFDM/dft-s-ofdm_waveform/"/>
      <url>/2024/10/31/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/DFT-s-OFDM/dft-s-ofdm_waveform/</url>
      
        <content type="html"><![CDATA[<h1>DFT-s-OFDM体制</h1><h2 id="DFT相关回顾">DFT相关回顾</h2><blockquote><p>首先对离散傅里叶变换（Discrete Fourier Transform，DFT）的公式以及性质进行回顾，该部分是基础，对后边波形设计的优化以及整个系统的理解具有重要的作用。</p></blockquote><ul><li><p><strong>DFT公式</strong><br>$$<br>X(k)=\sum_{n=0}^{N-1} x(n)e^\frac{-j2\pi nk}{N}=\sum_{n=0}^{N-1} x(n)W_N^{kn}\qquad 0\le k\le N-1<br>$$</p></li><li><p><strong>IDFT公式</strong><br>$$<br>x(n)=\frac{1}{N}\sum_{k=0}^{N-1}X(k)e^\frac{j2\pi nk}{N}=\frac{1}{N}\sum_{k=0}^{N-1}X(k)W_N^{kn}\qquad 0\le n \le N-1<br>$$</p></li><li><p><strong>性质</strong></p><ul><li><p>时域补零——<strong>增加频率分辨率</strong></p><p>已知序列 $x(n), 0\le n \le N-1$ ，人为将序列补充至 $rN$，$r$为正整数，得到 $g(n)\quad 0\le n \le rN-1$，即</p><p>$$<br>g(n) =<br>\begin{cases}<br>x(n) &amp; \text{if } 0 \le n \le N-1 \ 0 &amp; \text{if } N \le n \le rN-1<br>\end{cases}<br>$$</p><p>$g(n)$的离散傅里叶变换为：</p><p>$$<br>\begin{equation*}<br>\begin{aligned}<br>G(k) &amp;= DFT[g(n)]=\sum_{n=0}^{rN-1} g(n)e^\frac{-j2\pi nk}{rN} \ &amp;=\sum_{n=0}^{N-1}x(n)e^\frac{-j2\pi n(\frac {n} {k})}{N}=X(\frac{k} {n})\qquad k=0,1,\dots,rN-1<br>\end{aligned}<br>\end{equation*}<br>$$</p><blockquote><p>上述公式表明，$g(n)$的频谱$G(k)$与$x(n)$的频谱$X(k)$相对应，$G(k)$的频谱间隔相比$X(k)$的频谱间隔降低$k/r$，即序列$x(n)$填充补零再做DFT，可以得到更为精细的频谱。</p><p>另外，若增加长度并未$N$的整数倍，例如 $g(n)$长度为$L&gt;N$，则列长为$L$的序列 $g(n)$的离散傅里叶变换 $G(k)$，可以得到序列 $x(n)$的$L$根谱线，此时比$X(k)$得出得谱线要多。</p></blockquote></li><li><p>时域插零（上采样）——<strong>频谱扩展复制</strong></p><p>已知序列 $x(n), 0\le n \le N-1$ ，人为将序列样本点之间插入$L-1$个零，$L$也叫上采样倍数，得到新的序列$g(n)$，其长度为$M=LN$，即<br>$$<br>g[n]=\begin{cases}x(n/L)&amp;\mathrm{if~}n\mod L=0\0&amp;\mathrm{otherwise}&amp;\end{cases}<br>$$<br>$g(n)$的离散傅里叶变换为记为$G(m)$，与前面的$X(k)$进行区分：</p><!-- $$  \begin{equation*}    \begin{aligned}      X(k)&=\sum_{n=0}^{N-1} x(n)e^\frac{-j2\pi nk}{N}\quad 0\le k\le N-1\\      G(m)&=DFT[g(n)]=\sum_{n=0}^{LN-1}g(n)e^{-\frac{j2\pi nm}{LN}}&\\      &=\sum_{n=0}^{N-1}x(n)e^{-\frac{j2\pi m\cdot nL}{LN}}=\sum_{n=0}^{N-1}x(n)e^{-\frac{j2\pi m\cdot n}{N}}\quad 0\le m\le M-1    \end{aligned}  \end{equation*} $$ --><p>可以看到，对于每个频率$m$，当$m=k+qN$时（$q$为正整数），会出现周期性重复，即：<br>$$<br>G(m)=X(k),\qquad m=k+qN,\qquad q=0,1,\dots,N-1<br>$$<br>即上采样之后频谱会在频率轴上以$N$为间隔重复$L$次。</p><blockquote><p>另一种推导过程如下：</p><p>$g(n)$是在序列$x(n)$每个采样点后加$L-1$个$0$，其可以表示为：<br>$$<br>g(n)=x(n/L)\cdot \delta(n\mod L)<br>$$<br>$\delta(n\mod L)$是一个周期为$L$得脉冲序列，根据DFT性质可以得到$G(k)$为<br>$$<br>G(k)=\sum_{n=0}^{L-1}X(k-m\cdot \frac{M}{N})<br>$$</p></blockquote></li><li><p>频域补零——<strong>时域内插</strong></p><p>已知序列$X(k),0\le k\le N-1$，人为将序列补充至 $rN$，$r$为正整数，得到$G(k)\quad 0\le k\le rN-1$，即：</p><p>$$<br>G(k)=\left{\begin{matrix} X(k)\qquad 0\le k\le N-1\0\qquad N\le k\le rN-1\end{matrix}\right.<br>$$<br>进一步地，得到时域序列$g(n)$<br>$$<br>g(n)=\frac{1}{rN}\sum_{k=0}^{rN-1}G(k)e^{\frac{j2\pi kn}{rN}}=\frac{1}{rN}\sum_{k=0}^{N-1}X(k)e^{\frac{j2\pi kn}{rN}}=\frac{1}{r}x(\frac{n}{r})\qquad n=0,1,\cdots,rN-1<br>$$</p><blockquote><p>上述公式表明，频域补零，时域信号内插出来更多的点，即时域信号更加密集，$1/r$是一个缩放因子，其主要保持信号得能量不变。</p></blockquote></li><li><p>频域内插——<strong>时域扩展</strong></p><p>已知序列$X(k),0\le k\le N-1$，人为将序列样本点之间插入$L-1$个零，得到的新序列即为$G(m)$，其长度为$M=LN$，表达式如下：<br>$$<br>G(m)=\begin{cases}X\left(\frac mL\right),&amp;m=0,L,2L,\ldots,(N-1)L \ 0,&amp;otherwise&amp;\end{cases}<br>$$<br>进一步地，得到时域序列$g(n)$<br>$$<br>g(n)=\frac1M\sum_{m=0}^{M-1}G(m)e^{j\frac{2\pi}Mmn}=\frac1M\sum_{m=0}^{N-1}X(k)e^{j\frac{2\pi}M(kL)n} \ =\frac1 {LN} \sum_{m=0}^{N-1}X(k)e^{j\frac{2\pi}Nkn}=\frac1Lx(n \mod N)\qquad 0\le n\le LN-1<br>$$</p><blockquote><p>这实际上表示$g(n)$ 是 $x(n)$的周期延长 $L$ 倍。也就是说，插零后时域信号$g(n)$ 是将原始信号 $x(n)$ 在时域上拉伸为 L倍长度，并重复出现.</p></blockquote></li></ul></li></ul><h2 id="DFT-s-OFDM子载波映射方式">DFT-s-OFDM子载波映射方式</h2><blockquote><p>DFT-s-OFDM子载波映射方式分为2种，即集中式（Localized）映射和分布式（Distributed）映射，集中式映射方便频域调度，分布式映射传输可以获得额外的频率分集增益。在LTE上行传输方案中，选用集中式映射方案。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推导 </tag>
            
            <tag> DFT-S-OFDM </tag>
            
            <tag> 仿真 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技能总结</title>
      <link href="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>学习过程中的技能</h1><blockquote><p>本文主要记录日常学习到的一些技能，包括不限于：信息检索、电脑技巧、编程技巧……</p></blockquote><h2 id="信息检索">信息检索</h2><h3 id="国自然基金结题书下载">国自然基金结题书下载</h3><blockquote><p>国自然基金项目结项书对中文论文的撰写具有很高的参考价值，下面记录怎么下载结项书。</p></blockquote><ol><li>以Google浏览器为例，进入国家自然科学基金委员会官网：<a href="https://www.nsfc.gov.cn/%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%BE%E5%88%B0">https://www.nsfc.gov.cn/，然后找到</a> 申请资助–&gt;项目检索与查询–&gt;检索。</li></ol><img src="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/image-20241029211640489.png" alt="image-20241029211640489" style="zoom:50%;"><ol><li>在Google扩展应用商店中下载插件“国自然结题报告下载”，在项目页面右键可以找到下载结题报告即可下载。</li></ol><p><img src="/2024/10/29/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0/%E6%8A%80%E8%83%BD%E6%80%BB%E7%BB%93/image-20241029212121798.png" alt="image-20241029212121798"></p><p>至此，即可下载国自然基金的项目书了！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OFDM相关学习</title>
      <link href="/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>OFDM相关学习</h1><h2 id="循环前缀相关">循环前缀相关</h2><blockquote><p>循环前缀（Cyclic Prefix，CP）的作用：避免符号间干扰和消除子载波间干扰，如何深入理解这个问题，主要从公式的角度进行推导和分析，再结合MATLAB仿真进行验证。</p></blockquote><h3 id="多径信道传输模型">多径信道传输模型</h3><p>考虑线性时不变系统：<br>$$<br>y(t)=h(t)*x(t)=\int h(t)x(t-\tau)d\tau\tag1<br>$$<br>其中，$x(t)$表示输入信号，$h(t)$表示信号冲激响应，$y(t)$表示接收信号。离散信号表达式为：<br>$$<br>y(n)=\sum_{l=0}^{L-1} h(l)x(n-l)\tag2<br>$$<br>上式为多径信道下的信号传输模型，其中$L$表示多径信道的阶数。</p><h3 id="OFDM循环前缀的作用">OFDM循环前缀的作用</h3><p>对于OFDM信号而言，发射信号$x(n)$由 IFFT 运算和添加CP得到，其有效信号的表达式为（即IDFT的公式）：<br>$$<br>x(n)=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} X(k)e^{j2\pi \frac{nk}{N}},n=1,\dots,N,k=1,\dots,N<br>$$<br>式中，$X(k)$为第$k$个子载波上的发射信号，$N$为IFFT的点数（也是一个OFDM符号时域有效信号 $x(n)$的样点数目。</p><blockquote><p>接下来，需要把式$(2)$中的卷积写成矩阵乘法的形式：</p><p>分析过程：假设$L$是多径的的数目，不失一般地，先考虑$y(0)$的表达式，然后利用数学归纳法，写出接收信号的矩阵表达。<br>$$<br>y(0)=\sum_{l=0}^{L-1}h(l)x(-l)=h(0)x(0)+h(1)x(-1)+\dots+h(L-1)x(-L+1)<br>$$</p></blockquote><p>对于单个OFDM符号，CP长度为$N_{CP}$，则接收信号的矩阵表达式为：<br>$$<br>\begin{bmatrix}y(-N_{CP})\ \vdots\y(-1)\y(0)\y(1)\y(2)\ \vdots\y(N-2)\y(N-1)\end{bmatrix}=\begin{bmatrix}h(0)&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\ \vdots &amp; \ddots&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\h(L-1)&amp;\cdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\0&amp;h(L-1)&amp;\cdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;\ddots&amp;\vdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;h(L-1)&amp;&amp;h(0)&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;\ddots&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;h(0)&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;h(L-1)&amp;\cdots&amp;h(0)\end{bmatrix}\begin{bmatrix}x(-N_{CP})\\vdots\x(-1)\x(0)\x(1)\x(2)\\vdots\x(N-2)\x(N-1)\end{bmatrix}\tag4<br>$$<br>==<strong>CP的第一个作用：避免符号间干扰。</strong>==由于多径的作用，前一时刻的信号会对当前时刻的信号造成影响。因此，为了保证上一个OFDM不会对当前OFDM符号造成影响，CP的长度必须满足$N_{CP}\ge L$，上式$(4)$中，$N_{CP}= L$。（从两个方向考虑问题，物理意义直观理解，如果多径时延大于$N_{CP}$，接收信号将不全是一个OFDM符号的信息，会有下一个符号信息的干扰，导致后续处理分不开来；数学公式角度理解：上述矩阵成立的边界，即为$N_{CP}\ge L-1$，因为$x,y$这两个列向量长度有系统决定，是确定的形式，L的范围只能存在边界条件，即可得出结论）。</p><p>==CP 的第二个作用：消除子载波干扰==。下面进行推导。</p><h3 id="循环前缀进一步理解（消除子载波干扰）">循环前缀进一步理解（消除子载波干扰）</h3><blockquote><p>由CP的定义可知，$x(-1)=x(N-1),\dots,x(-N_{CP})=x(N-N_{CP})$。</p><img src="/2024/10/28/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/OFDM%E5%AD%A6%E4%B9%A0/ofdm%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/image-20241028171132568.png" alt="image-20241028171132568" style="zoom:30%;"></blockquote><p>接收端去掉CP，可以将上式$(4)$进行化简（即考虑$N_{CP}= L$的情况）：<br>$$<br>\begin{bmatrix}y(0)\y(1)\y(2)\\vdots\y(N-2)\y(N-1)\end{bmatrix}=\begin{bmatrix}0&amp;h(L-1)&amp;\cdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;\ddots&amp;\vdots&amp;h(0)&amp;0&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;h(L-1)&amp;&amp;h(0)&amp;0&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;\ddots&amp;0&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;\ddots&amp;&amp;h(0)&amp;0\0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;h(L-1)&amp;\cdots&amp;h(0)\end{bmatrix}\begin{bmatrix}x(-N_{CP})\\vdots\x(-1)\x(0)\x(1)\x(2)\\vdots\x(N-2)\x(N-1)\end{bmatrix}\tag5<br>$$<br>利用CP的性质，可以进一步得到：<br>$$<br>\begin{bmatrix}y(0)\y(1)\y(2)\\vdots\y(N-2)\y(N-1)\end{bmatrix}=\begin{bmatrix}h(0)&amp;0&amp;0&amp;0&amp;h(L-1)&amp;h(1)\\vdots&amp;h(0)&amp;0&amp;0&amp;0&amp;h(L-1)\h(L-1)&amp;&amp;h(0)&amp;0&amp;0&amp;0\0&amp;\ddots&amp;&amp;\ddots&amp;0&amp;0\0&amp;0&amp;\ddots&amp;&amp;h(0)&amp;0\0&amp;0&amp;0&amp;h(L-1)&amp;\cdots&amp;h(0)\end{bmatrix}\begin{bmatrix}x(0)\x(1)\x(2)\\vdots\x(N-2)\x(N-1)\end{bmatrix}\tag6<br>$$<br>观察式$(5)$和$(6)$的$h$矩阵，其实质上将式$(5)$中信道矩阵的左上角元素，搬移到式$(6)$中信道矩阵的右上角，这两个等式完全等价，即CP-OFDM将线性**==卷积运算转换为了循环卷积运算==**。</p><blockquote><p>实际上，时域线性卷积≠频域相乘，而是时域循环卷积=频域相乘，引入循环前缀，正好将线性卷积转到循环卷积。</p></blockquote><p>$$<br>\mathbf{y}=\mathbf{Gx}\tag7<br>$$</p><p>其中，$\mathbf{G}\in \mathbb{C} ^{N\times N}$为时域信道矩阵。根据OFDM接收端的操作，需对接收信号进行FFT运算，可以得到频域信号形式，即<br>$$<br>\mathbf{r}=\mathbf{F}\mathbf{y}=\frac{1}{N}\mathbf{F}\mathbf{G}\mathbf{F}^{H}\mathbf{s}\tag8<br>$$<br>式中，$\mathbf{F}\in \mathbb{C} ^{N\times N}$表示傅里叶矩阵，性质：$\mathbf{F}\mathbf{F}^{H}=NI$，$\mathbf{s}=[X(1),\dots,X(N)]^T\in ^{N\times 1}$表示频域发射信号。</p><p><strong>注意</strong>：式中$\mathbf{G}$是一个Toeplitz矩阵，具有循环移位特性。</p><p>定义 $\mathbf{H}=\frac{1}{N}\mathbf{F}\mathbf{G}\mathbf{F}^{H}$，利用 <a href="https://baike.baidu.com/item/%E6%89%98%E6%99%AE%E5%88%A9%E5%85%B9%E7%9F%A9%E9%98%B5/5735426?fr=aladdin">托普利兹矩阵_百度百科</a>的性质，则 $\mathbf{H}$是一个对角阵，式 $(8)$可以表示为：<br>$$<br>\begin{bmatrix}r(0)\r(1)\r(2)\\vdots\r(N-1)\end{bmatrix}=\begin{bmatrix}H(0)\&amp;\ddots\&amp;&amp;H(k)\&amp;&amp;&amp;\ddots\&amp;&amp;&amp;&amp;H(N-1)\end{bmatrix}\begin{bmatrix}X(0)\\vdots\X(k)\\vdots\X(N-1)\end{bmatrix}\tag9<br>$$<br>式中，$H(k)$表示 $\mathbf{H}$的第$k$个对角线元素，从式 $(9)$可以看到，每一个子载波的接收信号与发射信号一一对应，且其他子载波的信号对当前子载波完全没有影响。也就是说，子载波之间不会产生任何干扰，即消除了子载波间干扰。OFDM结合循环前缀，可以使信道均衡、信号解调等在频域并行处理，大大降低了系统复杂度。</p><p>有两种说法：CP --&gt; 实现OFDM的循环扩展（为了某种连续性）。</p><p>进一步地，分析OFDM频域与时域信道系数的关系，即$H$和$h$的关系：</p><p>解决这一问题，需要考虑矩阵的特征值和特征向量：</p><p>由$\mathbf{H}$是对角阵可知，$H(k)$是Toeplitz矩阵$\mathbf{G}$的特征值，相应的特征向量为 $\mathbf{F}^{H}$的第 $k$列。理由：$\mathbf{F}^H\mathbf{H}=\mathbf{G}\mathbf{F}^H$.（矩阵分析源头）</p><p>考虑矩阵两边的第$k$个列向量，可得$\mathbf{Gf}_k = H(k)\mathbf{f}_k$，其中$\mathbf{f}_k$是$\mathbf{F}^H$的第$k$列，也就是$\mathbf{F}$的第$k$行。这与特征值和特征向量的表达式相同。基于以上讨论，我们下面来说明如何计算$H(k)$。</p><p>定义：$W_N = e^{-\frac{j2\pi}{N}}$，$\mathbf{Gf}<em>k = H(k)\mathbf{f}<em>k$的等价形式，即<br>$$<br>\frac{1}{\sqrt{N}}\begin{bmatrix}p_0 &amp; p_1 &amp; p_2 &amp; \cdots &amp; p</em>{N-1} \p</em>{N-1} &amp; p_0 &amp; p_1 &amp; \cdots &amp; p_{N-2} \p_{N-2} &amp; p_{N-1} &amp; p_0 &amp; \cdots &amp; p_{N-3} \\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \p_1 &amp; p_2 &amp; p_3 &amp; \cdots &amp; p_0\end{bmatrix}\begin{bmatrix}W_N^{0} \W_N^{-k} \W_N^{-2k} \\vdots \W_N^{-(N-1)k}\end{bmatrix}=\frac{1}{\sqrt{N}}H(k)\begin{bmatrix}W_N^{0} \W_N^{-k} \W_N^{-2k} \\vdots \W_N^{-(N-1)k}\end{bmatrix}\tag{10}<br>$$<br>为了计算$H(k)$的表达式，我们观察式（6）和（10）中的Toeplitz矩阵$\mathbf{G}$和$\mathbf{P}$，有$\mathbf{P}<em>{m,n} = p</em>{(n-m)\mod N}$, $p_l = h_{(N-l)\mod N}$，其中$m, n, l = 0, 1, 2, \ldots, N-1$。</p><p>因此，式（10）等号左边：矩阵$\mathbf{P}$的第$(m+1)$行与IDFT矩阵第$k$列的内积有<br>$$<br>\frac{1}{\sqrt{N}} \sum_{n=0}^{N-1} p_{(n-m)<em>N} W_N^{-nk} = \frac{1}{\sqrt{N}} W_N^{-mk} \sum</em>{n=0}^{N-1} p_{(n-m)<em>N} W_N^{-(n-m)<em>N k} = \frac{1}{\sqrt{N}} W_N^{-mk} \sum</em>{l=0}^{N-1} p_l W_N^{-lk}\tag{11}<br>$$<br>式中，第1个等号利用了性质$W_N^{-(n-m)k} = W_N^{-(n-m)<em>N k}$（以$N$为周期的周期性）。为进一步计算式（11）的求和项，我们定义$H_k = \sum</em>{l=0}^{N-1} p_l W_N^{-lk}$ ，即<br>$$<br>H_k = \sum</em>{l=0}^{N-1} p_l W_N^{-lk} = \sum_{l=0}^{N-1} h_{(N-l)<em>N} W_N^{-lk} = \sum</em>{l=0}^{N-1} h_{(N-l)<em>N} W_N^{(N-l)<em>N k} = \sum</em>{l’=0}^{N-1} h</em>{l’} W_N^{l’k}\tag{12}<br>$$<br>式中，第3个等号利用了性质$W_N^{Nk} = 1$，$W_N^{(N-l)k} = W_N^{(N-l)_N k}$。</p><p>可以看到，频域信道系数$H_k$恰巧是时域信道系数$h_{l’}, l’ = 0, 1, \ldots, N-1$的傅里叶变换！</p><h3 id="线性卷积和循环卷积的转换">线性卷积和循环卷积的转换</h3><blockquote><p>参考书籍《<em>Wireless Communication Systems in Matlab, Second Edition</em>》</p></blockquote><p>下面给出一个简单的<em>MATLAB</em>程序：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all;</span><br><span class="line"><span class="comment">%========================================================================%</span></span><br><span class="line"><span class="comment">%:此程序用来测试《Wireless Communication Systems in Matlab, Second Edition》</span></span><br><span class="line"><span class="comment">%:第14章OFDM的前向解调算法</span></span><br><span class="line"><span class="comment">%========================================================================%</span></span><br><span class="line"><span class="comment">%% 线性卷积与循环卷积转化</span></span><br><span class="line">N = <span class="number">8</span>; <span class="comment">%period of DFT</span></span><br><span class="line">s = <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">h = <span class="built_in">randn</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">lin_s_h = conv(h, s) <span class="comment">%linear convolution of h and s</span></span><br><span class="line">cir_s_h = cconv(h, s, N) <span class="comment">%#ok&lt;*NOPTS&gt; %circular convolution of h and s with period N</span></span><br><span class="line">Ncp = <span class="number">2</span>; <span class="comment">%number of symbols to copy and paste for CP</span></span><br><span class="line">s_cp = [s(<span class="keyword">end</span> - Ncp + <span class="number">1</span>:<span class="keyword">end</span>) s]; <span class="comment">%copy last Ncp syms from s, add as prefix</span></span><br><span class="line">lin_scp_h = conv(h, s_cp) <span class="comment">%linear conv. of CP-OFDM symbol s_cp and CIR h</span></span><br><span class="line">r = lin_scp_h(Ncp + <span class="number">1</span>:N + Ncp) <span class="comment">%cut from index Ncp+1 to N+Ncp</span></span><br><span class="line"><span class="comment">%% 验证循环卷积=IDFT&#123;DFT&#123;h[n]&#125; x DFT&#123;s[n]&#125;&#125;</span></span><br><span class="line">R = fft(r, N); <span class="comment">%frequency response of received signal</span></span><br><span class="line">H = fft(h, N); <span class="comment">%frequency response of CIR</span></span><br><span class="line">S = fft(s, N); <span class="comment">%frequency response of OFDM signal (non CP)</span></span><br><span class="line">r1 = ifft(S .* H); <span class="comment">%IFFT of product of individual DFTs</span></span><br><span class="line">display([<span class="string">&#x27;IFFT(DFT(H)*DFT(S)) : &#x27;</span>, num2str(r1)])</span><br><span class="line">display([<span class="string">&#x27;cconv(s,h): &#x27;</span>, num2str(r)])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="OFDM信号仿真部分代码">OFDM信号仿真部分代码</h3><blockquote><p>以下为一个OFDM误码率仿真示例：</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">% DATA: 2024-9-12-22:00</span></span><br><span class="line"><span class="comment">% Author: Poster</span></span><br><span class="line"><span class="comment">% Description: This is a simulation of OFDM over AWGN channel.</span></span><br><span class="line"><span class="comment">%:注:Tx-Signal采用列向量的形式;</span></span><br><span class="line"><span class="comment">%:注:MATLAB采用优先采用列向量进行存储,按列运算速度相对较快</span></span><br><span class="line"><span class="comment">%------------Simulation parameters---------%</span></span><br><span class="line">MOD_TYPE = <span class="string">&#x27;PSK&#x27;</span>; <span class="comment">% Modulation type&#x27;</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">% Constellation size</span></span><br><span class="line">phase_init = <span class="built_in">pi</span> / M; <span class="comment">% Initial phase</span></span><br><span class="line">N = <span class="number">64</span>; <span class="comment">% FFT size</span></span><br><span class="line">Ncp = <span class="number">16</span>; <span class="comment">% number of symbols in the cyclic prefix</span></span><br><span class="line">Num = <span class="number">1e5</span>; <span class="comment">% Number of OFDM Symbols to transmit</span></span><br><span class="line">EbN0dB = <span class="number">0</span>:<span class="number">2</span>:<span class="number">20</span>; <span class="comment">% bit to noise ratio</span></span><br><span class="line">k = <span class="built_in">log2</span>(M); <span class="comment">% number of bits per symbol</span></span><br><span class="line">EsN0dB = <span class="number">10</span> * <span class="built_in">log10</span>(k) + EbN0dB; <span class="comment">% convert to symbol energy to noise ratio</span></span><br><span class="line">errors = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(EsN0dB)); <span class="comment">%to store symbol errors</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(EsN0dB)</span><br><span class="line">    <span class="keyword">for</span> Sym = <span class="number">1</span>:Num <span class="comment">% Monte Carlo Simulation</span></span><br><span class="line">        <span class="comment">%--------Constellation Mapping-------%</span></span><br><span class="line">        symbols_data = randi([<span class="number">0</span> M - <span class="number">1</span>], N, <span class="number">1</span>); <span class="comment">% Random symbols</span></span><br><span class="line">        X = pskmod(symbols_data, M, phase_init); <span class="comment">% PSK modulation</span></span><br><span class="line">        <span class="comment">%--------------Transmitter-----------%</span></span><br><span class="line">        x = ifft(X, N); <span class="comment">% IDFT</span></span><br><span class="line">        s = add_cyclic_prefix(x, Ncp); <span class="comment">% Add CP</span></span><br><span class="line">        <span class="comment">%----------------Channel-------------%</span></span><br><span class="line">        r = add_awgn_noise(s, EsN0dB(<span class="built_in">i</span>)); <span class="comment">% Add AWGN noise r = s + n</span></span><br><span class="line">        <span class="comment">%---------------Receiver-------------%</span></span><br><span class="line">        y = remove_cyclic_prefix(r, Ncp, N); <span class="comment">% remove CP</span></span><br><span class="line">        Y = fft(y, N); <span class="comment">% DFT</span></span><br><span class="line">        symbols_data_cap = pskdemod(Y, M, phase_init); <span class="comment">% PSK demodulation</span></span><br><span class="line">        <span class="comment">%------------error count-------------%</span></span><br><span class="line">        numErrors = sum(symbols_data ~= symbols_data_cap); <span class="comment">% Count errors</span></span><br><span class="line">        errors(<span class="built_in">i</span>) = errors(<span class="built_in">i</span>) + numErrors; <span class="comment">% Update error count</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">simulatedSER = errors / (Num * N); <span class="comment">% Symbol Error Rate</span></span><br><span class="line">theoreticalSER = ser_awgn(EbN0dB, MOD_TYPE, M);</span><br><span class="line"><span class="comment">% Plot theoretical curves and simulated BER points</span></span><br><span class="line"><span class="built_in">plot</span>(EbN0dB, <span class="built_in">log10</span>(simulatedSER), <span class="string">&#x27;ro&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(EbN0dB, <span class="built_in">log10</span>(theoreticalSER), <span class="string">&#x27;r-&#x27;</span>); grid on;</span><br><span class="line">title([<span class="string">&#x27;Performance of &#x27;</span>, num2str(M), <span class="string">&#x27;-&#x27;</span>, MOD_TYPE, <span class="string">&#x27; OFDM over AWGN channel&#x27;</span>]);</span><br><span class="line">xlabel(<span class="string">&#x27;Eb/N0 (dB)&#x27;</span>); ylabel(<span class="string">&#x27;Symbol Error Rate&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;simulated&#x27;</span>, <span class="string">&#x27;theoretical&#x27;</span>);</span><br><span class="line"><span class="comment">%=============Function Definition==========%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span> = <span class="title">add_cyclic_prefix</span><span class="params">(x, Ncp)</span></span></span><br><span class="line">    <span class="comment">%function to add cyclic prefix to the generated OFDM symbol x that</span></span><br><span class="line">    <span class="comment">%is generated at the output of the IDFT block</span></span><br><span class="line">    <span class="comment">% x - ofdm symbol without CP (output of IDFT block)</span></span><br><span class="line">    <span class="comment">% Ncp-num. of samples at x&#x27;s end that will copied to its beginning</span></span><br><span class="line">    <span class="comment">% s - returns the cyclic prefixed OFDM symbol</span></span><br><span class="line">    s = [x(<span class="keyword">end</span> - Ncp + <span class="number">1</span>:<span class="keyword">end</span>); x]; <span class="comment">%Cyclic prefixed OFDM symbol</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[r, n, N0]</span> = <span class="title">add_awgn_noise</span><span class="params">(s, SNRdB, L)</span></span></span><br><span class="line">    <span class="comment">%Function to add AWGN to the given signal</span></span><br><span class="line">    <span class="comment">%[r,n,N0]= add_awgn_noise(s,SNRdB) adds AWGN noise vector to signal</span></span><br><span class="line">    <span class="comment">%&#x27;s&#x27; to generate a %resulting signal vector &#x27;r&#x27; of specified SNR</span></span><br><span class="line">    <span class="comment">%in dB. It also returns the noise vector &#x27;n&#x27; that is added to the</span></span><br><span class="line">    <span class="comment">%signal &#x27;s&#x27; and the spectral density N0 of noise added</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="comment">%[r,n,N0]= add_awgn_noise(s,SNRdB,L) adds AWGN noise vector to</span></span><br><span class="line">    <span class="comment">%signal &#x27;s&#x27; to generate a resulting signal vector &#x27;r&#x27; of specified</span></span><br><span class="line">    <span class="comment">%SNR in dB. The parameter &#x27;L&#x27; specifies the oversampling ratio used</span></span><br><span class="line">    <span class="comment">%in the system (for waveform simulation). It also returns the noise</span></span><br><span class="line">    <span class="comment">%vector &#x27;n&#x27; that is added to the signal &#x27;s&#x27; and the spectral</span></span><br><span class="line">    <span class="comment">%density N0 of noise added</span></span><br><span class="line">    s_temp = s;</span><br><span class="line">    <span class="keyword">if</span> iscolumn(s), s = s.&#x27;; <span class="keyword">end</span> <span class="comment">%to return the result in same dim as &#x27;s&#x27;</span></span><br><span class="line">    <span class="built_in">gamma</span> = <span class="number">10</span> ^ (SNRdB / <span class="number">10</span>); <span class="comment">%SNR to linear scale</span></span><br><span class="line">    <span class="keyword">if</span> nargin == <span class="number">2</span>, L = <span class="number">1</span>; <span class="keyword">end</span> <span class="comment">%if third argument is not given, set it to 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isvector</span>(s)</span><br><span class="line">        P = L * sum(<span class="built_in">abs</span>(s) .^ <span class="number">2</span>) / <span class="built_in">length</span>(s); <span class="comment">%Actual power in the vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">%for multi-dimensional signals like MFSK</span></span><br><span class="line">        P = L * sum(sum(<span class="built_in">abs</span>(s) .^ <span class="number">2</span>)) / <span class="built_in">length</span>(s); <span class="comment">%if s is a matrix [MxN]</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    N0 = P / <span class="built_in">gamma</span>; <span class="comment">%Find the noise spectral density</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isreal</span>(s))</span><br><span class="line">        n = <span class="built_in">sqrt</span>(N0 / <span class="number">2</span>) * <span class="built_in">randn</span>(<span class="built_in">size</span>(s)); <span class="comment">%computed noise</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n = <span class="built_in">sqrt</span>(N0 / <span class="number">2</span>) * (<span class="built_in">randn</span>(<span class="built_in">size</span>(s)) + <span class="number">1</span><span class="built_in">i</span> * <span class="built_in">randn</span>(<span class="built_in">size</span>(s))); <span class="comment">%computed noise</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    r = s + n; <span class="comment">%received signal</span></span><br><span class="line">    <span class="keyword">if</span> iscolumn(s_temp), r = r.&#x27;; <span class="keyword">end</span> <span class="comment">%return r in original format as s</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">remove_cyclic_prefix</span><span class="params">(r, Ncp, N)</span></span></span><br><span class="line">    <span class="comment">%function to remove cyclic prefix from the received OFDM symbol r</span></span><br><span class="line">    <span class="comment">% r - received ofdm symbol with CP</span></span><br><span class="line">    <span class="comment">% Ncp - num. of samples at beginning of r that need to be removed</span></span><br><span class="line">    <span class="comment">% N - number of samples in a single OFDM symbol</span></span><br><span class="line">    <span class="comment">% y - returns the OFDM symbol without cyclic prefix</span></span><br><span class="line">    y = r(Ncp + <span class="number">1</span>:N + Ncp); <span class="comment">%cut from index Ncp+1 to N+Ncp</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[SER]</span> = <span class="title">ser_awgn</span><span class="params">(EbN0dB, MOD_TYPE, M, COHERENCE)</span></span></span><br><span class="line">    <span class="comment">%Theoretical Symbol Error Rate for various modulations over AWGN</span></span><br><span class="line">    <span class="comment">%EbN0dB - list of SNR per bit values</span></span><br><span class="line">    <span class="comment">%MOD_TYPE - &#x27;BPSK&#x27;,&#x27;PSK&#x27;,&#x27;QAM&#x27;,&#x27;PAM&#x27;,&#x27;FSK&#x27;</span></span><br><span class="line">    <span class="comment">%M - Modulation level for the chosen modulation</span></span><br><span class="line">    <span class="comment">% - For PSK,PAM,FSK M can be any power of 2</span></span><br><span class="line">    <span class="comment">% - For QAM M must be even power of 2 (square QAM only)</span></span><br><span class="line">    <span class="comment">%Parameter COHERENCE is only applicable for FSK modulation</span></span><br><span class="line">    <span class="comment">%COHERENCE = &#x27;coherent&#x27; for coherent FSK detection</span></span><br><span class="line">    <span class="comment">% = &#x27;noncoherent&#x27; for noncoherent FSK detection</span></span><br><span class="line">    gamma_b = <span class="number">10</span> .^ (EbN0dB / <span class="number">10</span>); <span class="comment">%SNR per bit in linear scale</span></span><br><span class="line">    gamma_s = <span class="built_in">log2</span>(M) * gamma_b; <span class="comment">%SNR per symbol in linear scale</span></span><br><span class="line">    SER = <span class="built_in">zeros</span>(<span class="built_in">size</span>(EbN0dB));</span><br><span class="line">    <span class="keyword">switch</span> lower(MOD_TYPE)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;bpsk&#x27;</span></span><br><span class="line">            SER = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b));</span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;psk&#x27;</span>, <span class="string">&#x27;mpsk&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> M == <span class="number">2</span> <span class="comment">%for BPSK</span></span><br><span class="line">                SER = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">if</span> M == <span class="number">4</span> <span class="comment">%for QPSK</span></span><br><span class="line">                    Q = <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_b)); SER = <span class="number">2</span> * Q - Q .^ <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">%for other higher order M-ary PSK</span></span><br><span class="line">                    SER = <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(gamma_s) * <span class="built_in">sin</span>(<span class="built_in">pi</span> / M));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;qam&#x27;</span>, <span class="string">&#x27;mqam&#x27;</span>&#125;</span><br><span class="line">            SER = <span class="number">1</span> - (<span class="number">1</span> - (<span class="number">1</span> - <span class="number">1</span> / <span class="built_in">sqrt</span>(M)) * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(<span class="number">3</span>/<span class="number">2</span> * gamma_s / (M - <span class="number">1</span>)))) .^ <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;fsk&#x27;</span>, <span class="string">&#x27;mfsk&#x27;</span>&#125;</span><br><span class="line">            <span class="keyword">if</span> strcmpi(COHERENCE, <span class="string">&#x27;coherent&#x27;</span>)</span><br><span class="line">                <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">length</span>(gamma_s)</span><br><span class="line">                    fun = @(q) (<span class="number">0.5</span> * <span class="built_in">erfc</span>((-q - <span class="built_in">sqrt</span>(<span class="number">2</span> .* gamma_s(ii))) / <span class="built_in">sqrt</span>(<span class="number">2</span>))) .^ (M - <span class="number">1</span>) .* <span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span> * <span class="built_in">pi</span>) .* <span class="built_in">exp</span>(-q .^ <span class="number">2</span>/<span class="number">2</span>);</span><br><span class="line">                    SER(ii) = <span class="number">1</span> - integral(fun, -<span class="built_in">inf</span>, <span class="built_in">inf</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="comment">%Default compute for noncoherent</span></span><br><span class="line">                <span class="keyword">for</span> jj = <span class="number">1</span>:<span class="built_in">length</span>(gamma_s)</span><br><span class="line">                    summ = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:M - <span class="number">1</span></span><br><span class="line">                        n = M - <span class="number">1</span>; r = <span class="built_in">i</span>; <span class="comment">%for nCr formula</span></span><br><span class="line">                        summ = summ + (<span class="number">-1</span>) .^ (<span class="built_in">i</span> + <span class="number">1</span>) ./ (<span class="built_in">i</span> + <span class="number">1</span>) .* prod((n - r + <span class="number">1</span>:n) ./ (<span class="number">1</span>:r)) .* <span class="built_in">exp</span>(-<span class="built_in">i</span> ./ (<span class="built_in">i</span> + <span class="number">1</span>) .* gamma_s(jj));</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                    SER(jj) = summ; <span class="comment">%Theoretical SER for non-coherent detection</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">case</span> &#123;<span class="string">&#x27;pam&#x27;</span>, <span class="string">&#x27;mpam&#x27;</span>&#125;</span><br><span class="line">            SER = <span class="number">2</span> * (<span class="number">1</span> - <span class="number">1</span> / M) * <span class="number">0.5</span> * <span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(<span class="number">3</span> * gamma_s / (M ^ <span class="number">2</span> - <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">otherwise</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;ser_awgn.m: Invalid modulation (MOD_TYPE) selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思考知识记录</title>
      <link href="/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>日常思考及知识点记录</h1><blockquote><p>此文档主要记录一些日常经过思考的问题，以及一些容易混淆的知识点，不限于专业知识，可能包括其他学科……</p></blockquote><h2 id="数学类">数学类</h2><h3 id="充要条件的充分和必要性">充要条件的充分和必要性</h3><blockquote><p>充要条件的充分性和必要性怎么区分？</p><p>记住一点：根据条件椎结论就是证明充分性，根据结论推条件就是证明必要性</p></blockquote><p>充要条件的表述一般有3钟表述方式：</p><ul><li>求证：$A$是$B$的充要条件</li><li>求证：$A$的充要条件是$B$</li><li>求证：$A\Longleftrightarrow B $（等价于第二条，即$A$的充要条件是$B$）</li></ul><blockquote><p>怎么看哪个是条件呢？如上提取主谓宾，谁是条件一目了然。在①中，A是条件，由A推出B就是证明充分性，反之由B推出A就是证明必要性;在②③中，条件是B，所以由B推出A就是证明充分性，反之由A推出B就是证明必要性。</p></blockquote><h3 id="集合类相关">集合类相关</h3><ul><li>常用集合的字母含义</li></ul><p>​$\mathbb{N}$：自然数集；$\mathbb{Z}$：整数集；$\mathbb{Q}$：有理数集；$\mathbb{R}$：实数集；$\mathbb{C} $：复数集；</p><h2 id="专业类">专业类</h2><h3 id="概率论">概率论</h3><h4 id="全概率公式和贝叶斯公式">全概率公式和贝叶斯公式</h4><blockquote><p>事件A和事件B，事件A先发生，事件B后发生，（事件B发生的第一步有$n$条路径）。全概率公式用于求事件B的概率，而贝叶斯公式用于反推事件$A_i$的概率。</p></blockquote><p><img src="/2024/10/16/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E6%80%9D%E8%80%83%E8%AE%B0%E5%BD%95/%E7%90%90%E7%A2%8E%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/figure.png" alt="figure"></p><p>$$<br>\begin{aligned}<br>P(B) &amp;= P(A_1)P(B \mid A_1)+P(A_2)P(B \mid A_2)+\dots+P(A_n)P(B \mid A_n)\<br>&amp;= \sum_{i=1}^{n}P(A_i)P(B \mid A_i)<br>\end{aligned}\tag{1}<br>$$</p><p>$$<br>P(A_i\mid B)=\frac{P(A_i)P(B\mid A_i)}{P(B)}=\frac{P(A_i)P(B\mid A_i)}{\sum_{i=1}^{N}P(A_i)P(B\mid A_i)}\tag{2}<br>$$</p><blockquote><p>上式（1）即为全概率公式，式（2）为贝叶斯公式</p><p>在通信应用中，接收端收到的信号一般可视为事件B，因此推导接收端的最佳接收性能公式时，通常使用贝叶斯公式。</p></blockquote><h3 id="信号与系统">信号与系统</h3><h4 id="傅里叶变换的本质">傅里叶变换的本质</h4><blockquote><p>在此首先感谢B站UP主 《喵星考拉》的【硬核】系列视频讲解，本部分有很多的细节都是从她的视频学习得到。</p><p>数学是万物根本，是解释其核心原理最直观的体现。</p></blockquote><ul><li><p>傅里叶级数</p><ul><li><p>傅里叶级数的系数<br>$$<br>F(n)=\frac{1}{T}\int_Tf(t)e^{-jn2\pi f_0t}dt\tag1<br>$$</p></li><li><p>用傅里叶级数的系数复原原函数<br>$$<br>f(t)=\sum_{-\infty}^{+\infty}F(n)e^{jn2\pi f_0t}\tag2<br>$$<br>傅里叶级数主要用于周期函数的分解，频率间隔 $\Delta f=f_0=1/T$.</p></li></ul></li></ul><blockquote><p>个人觉得，这个视频最重要的一个结论：傅里叶级数的系数可以等价于<strong>函数内积</strong>；原函数可以理解为傅里叶系数的一堆<strong>线性组合</strong>；内积也可以理解为函数在另一空间的投影，对于复数而言，函数内积需对某一个复值取共轭，从距离的角度考虑这个问题，主要原因是$i^2=1$，例如：$(1+i)\times (1-i)=2=|(1+i)|^2$。所以在式$(1)$中$e$指数取了共轭。</p></blockquote><ul><li><p>傅里叶变换</p><p>傅里叶变换是从傅里叶级数推导而来，应用场景主要为非周期函数，当频率$\Delta f\to +\infty$，化简上式即可得到傅里叶变换的公式。</p><ul><li></li></ul></li></ul><h4 id="【进阶】拉普拉斯变换">【进阶】拉普拉斯变换</h4><h3 id="数字通信">数字通信</h3><h4 id="OFDM-System">OFDM System</h4>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 常识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代信号处理Ⅰ学习记录</title>
      <link href="/2024/10/14/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%861/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/14/%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/%E7%8E%B0%E4%BB%A3%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%861/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>Modern Digital Signal Processing</h1><blockquote><p>Statistical Random</p></blockquote><hr><ol><li>Linear Processing</li></ol><ul><li>Fundamental<ul><li>Statistical Foundation</li><li>Orthogonal</li><li>Orthogonalization</li></ul></li><li>Typical<ul><li>Wiener,  Kalman</li></ul></li><li>Extension<ul><li>SVM, Kernel, Regularization</li></ul></li></ul><ol start="2"><li>Adaptive Processing</li></ol><ul><li>Adaptive Filter, LMS, RLS</li></ul><ol start="3"><li>Spectral Processing</li></ol><ul><li>Direct(Non-Parametric), Filter Banks</li></ul><hr><blockquote><p>1950’s~1980’s <strong>Linear, Orthogonal, Stationary, Gaussian</strong></p></blockquote><h2 id="Chapter-1">Chapter 1</h2><h3 id="Review-of-Probability-Theory">Review of Probability Theory</h3><p><strong>概率的定义：</strong></p><p>Uncertainty $\rightarrow$ Statistical Experiment $\rightarrow$ Sample Points $\rightarrow$ Sample Space $(\Omega)$ $\rightarrow$ Possibility(<strong>Prior</strong>)</p><p>$\rightarrow$ Probability(概率) $P: X^\Omega\rightarrow[0,1]$</p><p><strong>概率与统计</strong></p><p>Data $\longrightarrow$ <strong>Model</strong> $\longrightarrow$ Decision(Big Data: Data $\longrightarrow$ Decision)<br>   $\Downarrow$            $\Downarrow$<br>  Statistics   Probability</p><p>Random Variables: $X:\Omega\rightarrow R$ (Quantization)</p><p>$P(X=x)=P({w\in\Omega|Z(w)=x})$</p><p>Discrete: $\Omega = {w_1,w_2,\dots,w_n}$.   分布列：$P(X=x_k)=P_k$</p><p>Continue:</p>]]></content>
      
      
      <categories>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卫星链路计算</title>
      <link href="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/"/>
      <url>/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1>卫星链路计算相关学习</h1><h2 id="前言">前言</h2><blockquote><p>卫星链路计算是每次申请项目时必做的一个环节，我自己也参与计算了两三次，但总觉得自己理解的不够到位，尽管老师和师兄们说很简单，但我始终不相信自己，想从头到尾理解一遍，这也是写这篇博客的初衷。</p></blockquote><h2 id="卫星通信系统">卫星通信系统</h2><blockquote><p>卫星通信系统从发端地球站到收端地球站的信息传输过程中，要经过</p><p><strong>上行链路（uplink）、卫星转发器（transponder）、下行链路（downlink）</strong></p></blockquote><ul><li><p>上行链路信号质量</p><p>取决于：卫星收到的信号功率电平和卫星接收系统的噪声功率电平大小</p></li><li><p>下行链路信号质量</p><p>取决于：收端地球站接收的信号功率电平和地球站接收系统的噪声功率电平的大小</p></li></ul><p>主要目的：尽量有效地在地球上两个通信点之间提供可靠有高质量的连接手段</p><h2 id="卫星链路计算中的相关参数">卫星链路计算中的相关参数</h2><p>卫星链路计算中主要用到的相关参数有：</p><ul><li><strong>天线的增益与波束宽度</strong><ul><li><strong>有效全向辐射功率</strong></li><li><strong>自由空间传输损耗</strong></li><li><strong>噪声与损耗</strong></li><li><strong>转发器工作点</strong></li><li><strong>转发器的饱和通量密度</strong></li><li><strong>品质因数G/T</strong></li></ul></li></ul><h3 id="天线的增益与波束宽度">天线的增益与波束宽度</h3><blockquote><p>卫星通信中，一般使用<strong>定向天线</strong>，即电磁能量聚焦在某一方向辐射</p></blockquote><p>天线的增益定义为：<br>$$<br>G=\frac{定向天线辐射时，接收点收到的最大功率}{全向天线辐射时，接收点收到的功率}<br>$$<br>对于喇叭天线：<br>$$<br>G=\frac{4\pi A}{\lambda^2}\eta<br>$$<br>式中，$A$为天线的口面面积；$\lambda$为工作波长$(m)$；$\eta$为天线效率（电功率与电磁波形式的功率转换时，会造成损失）。</p><p>由公式可以看出，<strong>采用较高的工作频率可以使较小口径天线获得同样大的天线增益</strong>。</p><p>抛物面天线波束的半功率点宽度近似为：<br>$$<br>\theta_\frac{1}{2}\approx70\frac{\lambda}{D}(°)<br>$$<br>半功率角是指<strong>主瓣上场强为主射方向场强的</strong>$1/\sqrt2=0.707$时，即功率下降$1/2$时，两方向的夹角。</p><img src="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/image-20241012151251243.png" alt="image-20241012151251243" style="zoom:80%;"><h3 id="全向辐射功率">全向辐射功率</h3><blockquote><p>卫星通信中用**有效全向辐射功率$EIRP$**来代表地球站或卫星发射系统的发射能力</p></blockquote><p>EIRP是天线所发射的功率$P_t$与该天线增益的乘积：<br>$$<br>EIRP=P_t\times G_t<br>$$<br>上式表明：<strong>在最大辐射方向，定向天线所辐射的功率是全向天线在相同方向辐射功率的 $G_t$ 倍。</strong></p><p>描述了天线在轴线方向上的最大辐射功率<br>$$<br>EIRP(dBW)=P_T(dBW)+G_T(dBi)<br>$$</p><h3 id="自由空间损耗（Free-Space-Path-Loss-FSPL）">自由空间损耗（Free Space Path Loss,  FSPL）</h3><p>考虑理想通信系统，假设系统各部件没有损耗，传输媒质为自由空间，系统框图如下所示：</p><img src="/2024/10/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/01-%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/%E5%8D%AB%E6%98%9F%E9%93%BE%E8%B7%AF%E9%A2%84%E7%AE%97/image-20241012160040773.png" alt="image-20241012160040773" style="zoom:60%;"><p>$P_t$ 是发射功率；$Gt，Gr$ 分别为发射，接收天线增益； $d$ 为通信距离； $P_r$ 为接收机接收到的信号功率。</p><p>接收功率：<br>$$<br>P_R=P_TG_TG_R(\lambda/(4\pi d))^2=EIRP\cdot G_R(\lambda/(4\pi d))^2<br>$$<br>定义自由空间损耗<br>$$<br>L_f=(4\pi d/\lambda)^2=(4\pi df/c)^2<br>$$<br>自由空间传输损耗表征了两个全向天线闸，发射功率和接收功率之间的比值，即是天线间的传输损耗</p><p>实际中，定义距离$d$的单位为$km$，频率$f$的单位$GHz$，则自由空间损耗可表示为：<br>$$<br>L_f(dB)=92.44+20lg(d)+20lg(f)<br>$$<br>当然，最常见的公式如下，其只是单位换算导致常数项产生差异：<br>$$<br>L_f(dB)=32.45+20lg d(km)+20lg f(MHz)<br>$$</p><h3 id="雨衰">雨衰</h3><p>雨衰随频率的增加而增加</p><p>雨衰对水平极化的影响远大于垂直极化的影响</p><h3 id="载波功率">载波功率</h3><ul><li>载波接收功率$C$</li></ul><p>$$<br>[C]=[EIRP]+[G_R]-[L_p]<br>$$</p><p>$[G_R]$：接收天线的增益（dBi）</p><p>$L_p$：自由空间损耗（dB）</p><p>$EIRP$：发射机的有效全向辐射功率（dBW）</p><ul><li>考虑发射馈线损耗$[L_{FT}]$(dB)，则$[EIRP]$为：</li></ul><p>$$<br>[EIRP]=[P_T]-[L_{FT}]+[G_T]<br>$$</p><ul><li><p>接收机输入端的载波功率</p><!-- 同时考虑接收馈线损耗$[L_{FR}](dB)$、大气损耗$[L_a(dB)]$、其他损耗$[L_r(dB)]$，则接收机输入端的实际载波接收功率$[C(dBW)]$可以表示为 --><p>同时考虑接收馈线损耗$[L_{FR}]$(dB)、大气损耗$[L_a]$(dB)、其他损耗$[L_r]$(dB)，则接收机输入端的实际载波接收功率$[C]$(dBW)可以表示为<br>$$<br>[C]=\textcolor{ #BF3EFF}{[P_T]}-[L_{FT}]+\textcolor{ #BF3EFF}{[G_T]}+\textcolor{ #BF3EFF}{[G_R]}-\textcolor{ #BF3EFF}{[L_p]}-[L_{FR}]-[L_a]-[L_r]<br>$$</p><p>$$<br>EIRP = \textcolor{ #BF3EFF}{[P_T]}-[L_{FT}]+\textcolor{ #BF3EFF}{[G_T]}<br>$$</p></li></ul><h3 id="接收系统的噪声功率">接收系统的噪声功率</h3><p>$$<br>N=kT_tB<br>$$</p><p>N为进入接收系统的噪声功率；$T_t$为天线的等效噪声温度；$k=1.38\times 10^{-23}J/K$玻尔兹曼常数；$B$为接收系统的等效噪声带宽</p><h3 id="接收机输入端的载噪比与地球站性能因数">接收机输入端的载噪比与地球站性能因数</h3><p>$$<br>\frac{C}{N}=\frac{P_TG_TG_R}{L_P}\cdot\frac{1}{kT_tB}<br>$$</p><p>$$<br>\left [ \frac{C}{N}\right]=\left [EIRP\right]-\left [L_p\right]-\left [G_R\right]-10\lg (kT_tB)<br>$$</p><p>$$<br>\left [EIRP\right]=\left [P_T\cdot G_T\right]=\left [P_T\right]+\left [G_T\right]<br>$$</p><p>地球站接收机输入端的$[C/N]_E$</p><p>$$<br>\left [ \frac{C}{N} \right]_E=\left [EIRP\right]_S-\left [L_D\right]-\left [G{RE}\right]-10\lg (kT_tB)<br>$$</p><h3 id="计算程序">计算程序</h3><blockquote><p>下面是下行链路计算的一个MATLAB简单程序</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% @ DATA: 2024-10-12-17:19:49</span></span><br><span class="line"><span class="comment">% @ Author: Poster</span></span><br><span class="line"><span class="comment">% @ Description:</span></span><br><span class="line"><span class="comment">% @ Notes:</span></span><br><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 通信距离计算</span></span><br><span class="line">h = <span class="number">550</span>; <span class="comment">% 轨道高度(km)</span></span><br><span class="line">theta_deg = <span class="number">25</span>; <span class="comment">% 地球站至卫星的仰角(°)</span></span><br><span class="line">theta = deg2rad(theta_deg); <span class="comment">% rad</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;地面通信终端天线仰角: &#x27;</span>, num2str(theta_deg), <span class="string">&#x27;°&#x27;</span>]);</span><br><span class="line">RE = <span class="number">6378.14</span>; <span class="comment">% 地球半径(km)</span></span><br><span class="line"><span class="built_in">beta</span> = <span class="built_in">asin</span>(RE / (RE + h) * <span class="built_in">cos</span>(theta)); <span class="comment">% 卫星到地心与到地球站的夹角(rad)</span></span><br><span class="line">beta_deg = <span class="built_in">beta</span> * <span class="number">180</span> / <span class="built_in">pi</span>; <span class="comment">% °</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;卫星天线对地张角: &#x27;</span>, num2str(beta_deg), <span class="string">&#x27;°&#x27;</span>]);</span><br><span class="line">alpha = <span class="built_in">pi</span> / <span class="number">2</span> - <span class="built_in">beta</span> - theta; <span class="comment">% 地心角(rad)</span></span><br><span class="line">d = RE * <span class="built_in">sin</span>(alpha) / <span class="built_in">sin</span>(<span class="built_in">beta</span>); <span class="comment">% 通信距离(km)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;通信距离: &#x27;</span>, num2str(d), <span class="string">&#x27;km&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 自由空间损耗计算</span></span><br><span class="line">fc = <span class="number">11.7e3</span>; <span class="comment">% carrier frequency(MHz)</span></span><br><span class="line">Lp = <span class="number">32.45</span> + <span class="number">20</span> * <span class="built_in">log10</span>(fc) + <span class="number">20</span> * <span class="built_in">log10</span>(d); <span class="comment">% Free Space Path Loss(dB)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;自由空间损耗: &#x27;</span>, num2str(Lp), <span class="string">&#x27;dB&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line">EIRP = <span class="number">36.7</span>; <span class="comment">% Effective Isotropic Radiated Power(dBm)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;有效全向辐射功率EIRP: &#x27;</span>, num2str(EIRP), <span class="string">&#x27;dBm&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 其他损耗</span></span><br><span class="line">La = <span class="number">2.4</span>; <span class="comment">% Atmospheric Loss(dB)</span></span><br><span class="line">Lr = <span class="number">1</span>; <span class="comment">% Other Loss(dB)</span></span><br><span class="line">Lfr = <span class="number">0</span>; <span class="comment">% 接收馈线损耗(dB)(天线指向损失;极化损失)</span></span><br><span class="line">L = Lp + La + Lr + Lfr; <span class="comment">% Total Loss(dB)</span></span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 地面终端 G/T</span></span><br><span class="line">G = <span class="number">32.8</span>; <span class="comment">% 天线增益(dBi)</span></span><br><span class="line">eta = <span class="number">0.5</span>; <span class="comment">% 天线效率</span></span><br><span class="line">aperture = <span class="number">2</span>; <span class="comment">% 天线孔径(m)</span></span><br><span class="line">lambda = <span class="number">3e8</span> / (fc * <span class="number">1e6</span>); <span class="comment">% 波长(m)</span></span><br><span class="line">G_c = <span class="number">10</span> * <span class="built_in">log10</span>(eta * <span class="number">4</span> * <span class="built_in">pi</span> * aperture / (lambda ^ <span class="number">2</span>)); <span class="comment">% 抛物面天线增益(dBi)</span></span><br><span class="line">T = <span class="number">300</span>; <span class="comment">%系统噪声温度</span></span><br><span class="line">GT = G - <span class="number">10</span> * <span class="built_in">log10</span>(T); <span class="comment">% 系统G/T比率(dB/K)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;系统G/T值: &#x27;</span>, num2str(GT), <span class="string">&#x27; dB/K&#x27;</span>]);</span><br><span class="line"><span class="comment">%------------------------------------------%</span></span><br><span class="line"><span class="comment">%: 接收机载噪比</span></span><br><span class="line">B = <span class="number">250e6</span>; <span class="comment">% 接收机带宽(MHz)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;接收机带宽: &#x27;</span>, num2str(B / <span class="number">1e6</span>), <span class="string">&#x27;MHz&#x27;</span>]);</span><br><span class="line">cons = <span class="number">-228.6</span>; <span class="comment">% 玻尔兹曼常数(dBW/K/Hz)</span></span><br><span class="line">CN = EIRP - L + GT - <span class="number">10</span> * <span class="built_in">log10</span>(B) - cons; <span class="comment">% 接收机接收功率(dBm)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;载噪比C/N: &#x27;</span>, num2str(CN), <span class="string">&#x27;dB&#x27;</span>]);</span><br></pre></td></tr></table></figure><p>通过载噪比，后续结合调制方式可以计算$E_b/N_0$，从而推算整个通信系统BER等系统参数。</p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 公式推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青春语句</title>
      <link href="/2024/10/07/%E7%94%9F%E6%B4%BB%E5%A8%B1%E4%B9%90/%E9%9D%92%E6%98%A5/"/>
      <url>/2024/10/07/%E7%94%9F%E6%B4%BB%E5%A8%B1%E4%B9%90/%E9%9D%92%E6%98%A5/</url>
      
        <content type="html"><![CDATA[<h1>青春</h1><blockquote><p>“碧华映朱实，攀折青春时”。青春是“草长莺飞二月天，拂堤杨柳醉春烟”的年华美好，青春带着“倚门回首，却把青梅嗅”的甜蜜，青春也会走过“雾失楼台，月迷津渡”的困惑，但“少年负壮气，奋烈自有时”，青春总会激荡出“一身能擘两雕弧，虏骑千重只似无”的力量；张扬着“大鹏一日同风起，扶摇直上九万里”的义气；因为青春意味着奋发与成长，愿每个人都能永葆青春的状态，依旧“满身花雨又归来”。​</p></blockquote><h1>君子志向：坚韧</h1><blockquote><p>月缺不改光，剑折不改刚”，有志向的人自信自强；“君子量不极，胸吞百川流”，有志向的人心有远方；“丈夫非无泪，不洒离别间”，有志向的人情深意长；“及时当勉励，岁月不待人”，有志向的人不会虚度时光；“人生感意气，功名谁复论”，有志向的人看淡名利；“感时思报国，拔剑起蒿莱”，有志向的人是最可靠的力量；“愿君学长松，慎勿作桃李”，新时代，新舞台，让我们“共矜然诺心，各负纵横志”。<br>“无情未必真豪杰”，英雄的身上，闪耀着人性的熠熠光辉，他们有“若遇早梅开，一枝应寄来”的高尚友情；有“不思量，自难忘”的真挚爱情；有“从今别去江南路，化作啼鹃带血归”的不舍乡情；有“生民百遗一，念之断人肠”的痛楚悲情；有“一寸丹心图报国，两行清泪为相思”的拳拳亲情；更有“生当作人杰，死亦为鬼雄”的满腔豪情；英雄的真情总会化为人间甘霖，“赤风洒雨露，春日在天涯”。 ​<br>“成败何足论，英雄自有真”。每一位英雄都在书写最真实的人生。“亦余心之所善兮，虽九死其犹未悔”，屈原的炽热情怀；“旄尽风霜节，心悬日月光”，苏武的不灭气节；“出师一表真名世，千载谁堪伯仲间”，诸葛亮的鞠躬尽瘁；“做事循天理，博爱惜生灵”，范仲淹的爽直磊落；“镜里朱颜都变尽，只有丹心难灭”，文天祥的至死不渝。英雄探寻着生命的真谛，“若有人知春去处，唤取归来同住”，让我们在经典中与英雄相伴。<br>英雄的本色是什么，是“雨打灯难灭，风吹色更明”的坚韧；是“一年三百六十日，多是横戈马上行”的不辞艰辛；是“高情已逐晓云空，不与梨花同梦”的超越平庸；是“男儿何不带吴钩，收取关山五十州”的满腔壮志；是“一腔热血勤珍重，洒去犹能化碧涛”的不惧牺牲；是“回看射雕处，千里暮云平”的襟怀坦荡；是“富贵非所愿，与人驻颜光”的无私奉献；“英雄自古常如此，愿逐月华流照君”，让我们在经典中，追随那些铿锵前行的脚步。<br>一首经典就是一个良师益友。“纷吾既有此内美兮，又重之以修能”教会我们成长；“谁知盘中餐，粒粒皆辛苦”教会我们珍惜；“我生本无乡，心安是归处”教会我们旷达；“纵浪大化中，不喜亦不惧”教会我们放下；“埋骨何须桑梓地，人生无处不青山”教会我们志向；与经典同行，诗词为伴。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 生活感想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切从这里开始</title>
      <link href="/2024/10/04/%E5%BC%80%E5%A7%8B/"/>
      <url>/2024/10/04/%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<pre><code>【主题配置】    https://butterfly.js.org/posts/ceeb73f/    记录我的学习之旅</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>硬件培训2022</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<h1>硬件培训2022</h1><blockquote><p>主要记录硬件培训的学习笔记和仿真记录。</p></blockquote><h2 id="BPSK收发系统">BPSK收发系统</h2><blockquote><p>BPSK学习及仿真记录</p></blockquote><h3 id="文章-swig￼0">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/" title="BPSK收发系统">BPSK学习及仿真</a></h3><h3 id="文章-swig￼1">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/" title="BPSK-DSSS收发系统">BPSK-DSSS学习及仿真</a></h3><h3 id="文章-swig￼2">[文章] <a href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/" title="DDS原理及简单应用">DDS原理及简单应用</a></h3><h3 id="参考-师兄的笔记">[参考] 师兄的笔记</h3><p><a href="https://www.wolai.com/benko/v4ir4nzYagWPGRSPcu8j4X" title="Benko's Notes 这是Benko的笔记本，精选笔者认为比较重要的一些笔记供大家参考，欢迎一起交流。 https://www.wolai.com/benko/v4ir4nzYagWPGRSPcu8j4X">Benko’s Notes 这是Benko的笔记本，精选笔者认为比较重要的一些笔记供大家参考，欢迎一起交流。 https://www.wolai.com/benko/v4ir4nzYagWPGRSPcu8j4X</a></p>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BPSK-DSSS收发系统</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>MATLAB仿真</h1><h2 id="目录">目录</h2><ul><li><a href="#matlab%E4%BB%BF%E7%9C%9F">MATLAB仿真</a><ul><li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li><li><a href="#%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">系统实现</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE">系统框图</a></li></ul></li><li><a href="#%E4%BB%BF%E7%9C%9F%E4%BB%A3%E7%A0%81">仿真代码</a><ul><li><a href="#%E7%94%9F%E6%88%90m%E5%BA%8F%E5%88%97">生成m序列</a></li><li><a href="#%E6%89%A9%E9%A2%91%E7%A0%81%E4%B8%8E%E6%98%A0%E5%B0%84%E5%BA%8F%E5%88%97%E7%9B%B8%E4%B9%98">扩频码与映射序列相乘</a></li><li><a href="#%E6%A0%B9%E5%8D%87%E4%BD%99%E5%BC%A6%E6%BB%A4%E6%B3%A2">根升余弦滤波</a></li><li><a href="#%E4%B8%8A%E5%8F%98%E9%A2%91%E4%B9%98%E4%BB%A5%E8%BD%BD%E6%B3%A2">上变频（乘以载波）</a></li><li><a href="#%E7%89%A9%E7%90%86%E4%BF%A1%E9%81%93%E6%B7%BB%E5%8A%A0%E5%99%AA%E5%A3%B0">物理信道（添加噪声）</a></li><li><a href="#%E4%B8%8B%E5%8F%98%E9%A2%91%E4%B9%98%E4%BB%A5%E8%BD%BD%E6%B3%A2">下变频（乘以载波）</a></li><li><a href="#%E8%A7%A3%E6%89%A9%E5%8C%B9%E9%85%8D%E6%BB%A4%E6%B3%A2">解扩+匹配滤波</a></li><li><a href="#%E9%87%87%E6%A0%B7%E5%88%A4%E5%86%B3">采样+判决</a></li><li><a href="#%E7%94%BB%E5%87%BA%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%BA%8F%E5%88%97%E5%AF%B9%E6%AF%94">画出系统输入输出序列对比</a></li></ul></li><li><a href="#%E8%AF%AF%E7%A0%81%E7%8E%87%E6%9B%B2%E7%BA%BF%E4%BB%BF%E7%9C%9F">误码率曲线仿真</a><ul><li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li><li><a href="#%E8%BE%93%E5%87%BA%E5%9B%BE%E5%83%8F">输出图像</a></li></ul></li><li><a href="#%E9%99%84%E5%BD%95%E4%BB%A3%E7%A0%81">附录代码</a><ul><li><a href="#%E4%BB%A3%E7%A0%811">代码1</a></li><li><a href="#%E4%BB%A3%E7%A0%812">代码2</a></li></ul></li></ul></li></ul><h2 id="系统实现">系统实现</h2><h3 id="系统框图">系统框图</h3><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_n8FxyoHoBx.png" alt></p><p><em><strong>唯一与BPSK不同的是，对极信号与扩频码进行相乘。</strong></em></p><h2 id="仿真代码">仿真代码</h2><h4 id="生成m序列">生成m序列</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成m序列</span></span><br><span class="line">data_len = <span class="number">10</span>;               <span class="comment">%数据长度 </span></span><br><span class="line">n = <span class="number">3</span>;                       <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>;                 <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p,<span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line">mg = <span class="built_in">repmat</span>(ms&#x27;,<span class="number">1</span>,data_len); <span class="comment">%重复m序列</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">121</span>);</span><br><span class="line">stairs(ms);title(<span class="string">&#x27;m序列时域波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">c = xcorr(ms,<span class="string">&#x27;normalized&#x27;</span>);</span><br><span class="line">subplot(<span class="number">122</span>);</span><br><span class="line"><span class="built_in">plot</span>(c);title(<span class="string">&#x27;m序列自相关函数&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_bWuqWQobM0.png" alt></p><h4 id="扩频码与映射序列相乘">扩频码与映射序列相乘</h4><ul><li><p>方法一：（方便理解）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data_len = <span class="number">10</span>;                       <span class="comment">%数据长度 </span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);      <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;             <span class="comment">%映射，0变-1</span></span><br><span class="line">s = rectpulse(data_bio,p);           <span class="comment">%序列重复p倍</span></span><br><span class="line">y = s.*mg;                           <span class="comment">%信号与扩频码相乘</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stairs(s);title(<span class="string">&#x27;扩频之前的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stairs(y);title(<span class="string">&#x27;扩频之后的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_QDPDA1532B.png" alt></p></li><li><p>方法二：（矩阵重组）</p><p>思路，生成的m序列为列向量<code>ms</code>，乘以之前的映射序列<code>data_bio</code>；生成一个数组，然后利用reshape函数重组数组，得到y（相乘之后的序列）；</p><blockquote><p><code>reshape</code>函数按<strong>列</strong>取元素</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">3</span>;          <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>;     <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p,<span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line">m_1 = ms.*data_bio;</span><br><span class="line">y1 = <span class="built_in">reshape</span>(m_1,[<span class="number">1</span>,p*data_len]);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stairs(s);title(<span class="string">&#x27;扩频之前的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stairs(y1);title(<span class="string">&#x27;扩频之后的序列波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_lKMEXrNUiW.png" alt></p></li></ul><h4 id="根升余弦滤波">根升余弦滤波</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">osr = <span class="number">8</span>;                      <span class="comment">% 8倍上采样</span></span><br><span class="line">y_up = upsample(y,osr); <span class="comment">% 上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(y_up,fir_rcos);            <span class="comment">%根升余弦滤波</span></span><br></pre></td></tr></table></figure><h4 id="上变频（乘以载波）">上变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">16000</span>;                   <span class="comment">% 采样率 </span></span><br><span class="line">fc = <span class="number">2000</span>;                    <span class="comment">% 载波频率</span></span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier.*data_bx;                    <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="物理信道（添加噪声）">物理信道（添加噪声）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_n = awgn(s_up,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);               <span class="comment">%添加噪声</span></span><br></pre></td></tr></table></figure><h4 id="下变频（乘以载波）">下变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_down = r_n .* carrier;                    <span class="comment">%下变频</span></span><br></pre></td></tr></table></figure><h4 id="解扩-匹配滤波">解扩+匹配滤波</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mg_up = upsample(<span class="built_in">fliplr</span>(ms&#x27;),osr);        <span class="comment">%先把序列进行反序</span></span><br><span class="line">fir_m = conv(mg_up,fir_rcos);             <span class="comment">%本地广义成形</span></span><br><span class="line"></span><br><span class="line">r_bx = conv(r_down,fir_m);                <span class="comment">%接收匹配滤波器</span></span><br></pre></td></tr></table></figure><h4 id="采样-判决">采样+判决</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">recv_data = (r_bx(<span class="number">97</span>:<span class="number">56</span>:<span class="keyword">end</span><span class="number">-104</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">%recv_data = (r_bx(osr*6+p*osr-osr+1:p*osr:end-osr*6-p*osr)) &gt; 0;</span></span><br></pre></td></tr></table></figure><p><em>本代码中滤波器的长度</em>*<code>fir_rcos</code>**为49，7位m序列，8倍上采样，即56个点；所以总延时为49-1+56=104，由于最后面是7个0，所以卷积处理时不会体现，即最开始为104-7=97，当然也可以取序列长度为1，寻找第一个最佳相关峰；一般地，如下：<em><code>recv_data = (r_bx(osr*</code></em><code>6+p</code><em><code>*osr-osr+1 : p*</code></em><code>osr : end-osr</code>*<code>*6-p*osr)) &gt; 0;</code></p><h4 id="画出系统输入输出序列对比">画出系统输入输出序列对比</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stem(data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&#x27;原始数据&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stem(recv_data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&#x27;输出序列&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_uao4jJQz08.png" alt></p><p><em>由于序列长度较少，所以理论上出错的可能性较小，即输出序列应该和输入序列完全一致，即可认为系统设计初步验证无误。</em></p><h2 id="误码率曲线仿真">误码率曲线仿真</h2><h4 id="代码">代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk-dsss 误码率仿真（输出bpsk及bpsk-dsss）</span></span><br><span class="line">clc;clear all;close all;</span><br><span class="line">fs = <span class="number">16000</span>;                   <span class="comment">% 采样率 </span></span><br><span class="line">fc = <span class="number">2000</span>;                    <span class="comment">% 载波频率</span></span><br><span class="line"><span class="comment">%symbol_rate = 1000;           %符号速率</span></span><br><span class="line"><span class="comment">% Rb = 1000;                    % bit速率</span></span><br><span class="line">alfs = <span class="number">0.35</span>;                   <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">100000</span>;               <span class="comment">%数据长度</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);      <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;             <span class="comment">%映射，0变-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% bpsk-dsss相关操作</span></span><br><span class="line"><span class="comment">% 生成m序列</span></span><br><span class="line">n = <span class="number">3</span>;          <span class="comment">%阶次</span></span><br><span class="line">p = <span class="number">2</span>^n - <span class="number">1</span>;     <span class="comment">%循环周期</span></span><br><span class="line">ms = idinput(p,<span class="string">&#x27;prbs&#x27;</span>);</span><br><span class="line">mg = <span class="built_in">repmat</span>(ms&#x27;,<span class="number">1</span>,data_len);  <span class="comment">%重复m序列</span></span><br><span class="line"></span><br><span class="line">s = rectpulse(data_bio,p);</span><br><span class="line">y = s.*mg;        <span class="comment">%信号与扩频码相乘</span></span><br><span class="line"></span><br><span class="line">osr = <span class="number">8</span>;                      <span class="comment">% 8倍上采样</span></span><br><span class="line">s_up_d = upsample(y,osr); <span class="comment">% 上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx_d = conv(s_up_d,fir_rcos);            <span class="comment">%根升余弦滤波</span></span><br><span class="line"></span><br><span class="line">carrier_d = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx_d)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_carrier_d = carrier_d.*data_bx_d;                    <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% bpsk(无扩频操作)</span></span><br><span class="line">s_up = upsample(data_bio,osr);   <span class="comment">%直接上采样</span></span><br><span class="line">data_bx = conv(s_up,fir_rcos);</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_carrier = carrier.*data_bx;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 求误码率</span></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">errbit_d =<span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">snr_d = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span>*<span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span>*<span class="built_in">log10</span>(osr); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">  <span class="comment">%snr_d(i) = ebn0 + 10*log10(2) - 10*log10(osr) - 10*log10(p);</span></span><br><span class="line">    snr_d(<span class="built_in">i</span>) = snr(<span class="built_in">i</span>) - <span class="number">10</span>*<span class="built_in">log10</span>(p);</span><br><span class="line">  <span class="comment">%物理信道（加性高斯白噪声）</span></span><br><span class="line">  r_noise = awgn(s_carrier,snr(<span class="built_in">i</span>),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">  r_noise_d = awgn(s_carrier_d,snr_d(<span class="built_in">i</span>),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%下变频（乘以载波）</span></span><br><span class="line">  r_signal_down = r_noise.*carrier;</span><br><span class="line">  r_signal_down_d = r_noise_d.*carrier_d;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%匹配滤波器 根升余弦滤波</span></span><br><span class="line">  r_bx = conv(r_signal_down,fir_rcos);</span><br><span class="line">  <span class="comment">%解扩加匹配滤波</span></span><br><span class="line">  mg_upsample = upsample(<span class="built_in">fliplr</span>(ms&#x27;),osr) ;</span><br><span class="line">  fir_m = conv(mg_upsample,fir_rcos);              <span class="comment">%本地广义成形</span></span><br><span class="line">  r_bx_d = conv(r_signal_down_d,fir_m);                <span class="comment">%接收匹配滤波器</span></span><br><span class="line">  <span class="comment">%判决</span></span><br><span class="line">  recv_data = (r_bx(osr*<span class="number">6</span>+<span class="number">1</span>:osr:<span class="keyword">end</span>-osr*<span class="number">6</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">  errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(recv_data-data))/data_len;</span><br><span class="line">  recv_data_d = (r_bx_d(<span class="number">97</span>:<span class="number">56</span>:<span class="keyword">end</span><span class="number">-96</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">  errbit_d(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(recv_data_d-data))/data_len;</span><br><span class="line">  <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">ber_theory = <span class="number">0.5</span>*<span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>,ebn0/<span class="number">10</span>)));<span class="comment">%理论误码率</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(ebn0,ber_theory,<span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">semilogy(ebn0,errbit,<span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line"></span><br><span class="line">semilogy(ebn0,errbit_d,<span class="string">&#x27;-xg&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line">xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>);ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;BPSK-DSSS误码率曲线图&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>,<span class="string">&#x27;bpsk仿真误码率曲线&#x27;</span>,<span class="string">&#x27;bpsk-dsss仿真误码率&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="输出图像">输出图像</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/02BPSK-DSSS/BPSK-DSSS%E7%B3%BB%E7%BB%9F/image_yRtvMRDa5a.png" alt></p><h2 id="附录代码">附录代码</h2><h3 id="代码1">代码1</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%:本程序用于实现QPSK直接扩频系统</span></span><br><span class="line"><span class="comment">%========================基本参数===========================%</span></span><br><span class="line">Rs = <span class="number">100e6</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%上采样倍数</span></span><br><span class="line">fs = sps * Rs; <span class="comment">%采样率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1e3</span>; <span class="comment">%数据长度</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">%调制阶数</span></span><br><span class="line">offset = <span class="built_in">pi</span> / <span class="number">4</span>; <span class="comment">%偏移量</span></span><br><span class="line">rng(<span class="number">9</span>);</span><br><span class="line">EbN0 = <span class="number">0</span>:<span class="number">2</span>:<span class="number">10</span>;</span><br><span class="line">snr = EbN0 - <span class="number">10</span> * <span class="built_in">log10</span>(sps) - <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span> ^ n) + <span class="number">10</span> * <span class="built_in">log10</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">% snr = 100;</span></span><br><span class="line">ber = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(snr));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(snr)</span><br><span class="line">    bit_error = <span class="number">0</span>;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (bit_error &gt; <span class="number">100</span> &amp;&amp; k * data_len &gt; <span class="number">1e4</span>)</span><br><span class="line">        <span class="comment">%========================调制==============================%</span></span><br><span class="line">        bit_send = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%bit数据</span></span><br><span class="line">        data = bit2int(bit_send.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">        <span class="comment">% data = randi([0 M - 1], 1, data_len); %随机数据</span></span><br><span class="line">        data_mod = pskmod(data, M, offset); <span class="comment">%PSK调制</span></span><br><span class="line">        <span class="comment">% scatterplot(data_mod); title(&#x27;QPSK-Constellation Diagram&#x27;);</span></span><br><span class="line">        <span class="comment">%========================扩频==============================%</span></span><br><span class="line">        n = <span class="number">10</span>; <span class="comment">%m序列级数</span></span><br><span class="line">        C = <span class="number">435</span>; <span class="comment">%八进制反馈系数</span></span><br><span class="line">        tap_set = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">%二进制</span></span><br><span class="line">        m_sequence = <span class="number">1</span> - <span class="number">2</span> * [m_serial_generator(tap_set) <span class="number">1</span>]; <span class="comment">%生成扩频序列</span></span><br><span class="line">        data_matrix = (m_sequence.&#x27;) .* data_mod; <span class="comment">%扩频矩阵</span></span><br><span class="line">        data_dsss = <span class="built_in">reshape</span>(data_matrix, <span class="number">1</span>, []);</span><br><span class="line">        <span class="comment">%=======================成形滤波器==========================%</span></span><br><span class="line">        Fir_rcos = rcosdesign(alfs, <span class="number">8</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">        data_dsss_up = upsample(data_dsss, sps);</span><br><span class="line">        data_dsss_shape = conv(data_dsss_up, Fir_rcos);</span><br><span class="line">        <span class="comment">%=========================噪声=============================%</span></span><br><span class="line">        data_awgn = awgn(data_dsss_shape, snr(<span class="built_in">i</span>), <span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">        <span class="comment">%=======================解扩+匹配===========================%</span></span><br><span class="line">        m_sequence_up = upsample(<span class="built_in">fliplr</span>(m_sequence), sps);</span><br><span class="line">        Fir_match = conv(m_sequence_up, Fir_rcos); <span class="comment">%本地广义匹配滤波器</span></span><br><span class="line">        data_matched = conv(data_awgn, Fir_match); <span class="comment">%解扩+匹配</span></span><br><span class="line">        <span class="comment">%========================解调===============================%</span></span><br><span class="line">        data_matched_down = data_matched(<span class="number">4125</span>:sps * <span class="number">1024</span>:<span class="keyword">end</span> - <span class="number">4124</span>);</span><br><span class="line">        data_demod = pskdemod(data_matched_down, M, offset);</span><br><span class="line">        bit_recv = int2bit(data_demod.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">        bit_error = bit_error + biterr(bit_send, bit_recv);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;Bit Error = &#x27;</span>, num2str(bit_error)]);</span><br><span class="line">        k = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ber(<span class="built_in">i</span>) = bit_error / (k * data_len);</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;BER = &#x27;</span>, num2str(ber(<span class="built_in">i</span>))]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%==========================画图=============================%</span></span><br><span class="line">ber_theory = berawgn(EbN0.&#x27;, <span class="string">&quot;psk&quot;</span>, M, <span class="string">&quot;nondiff&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(EbN0, ber, <span class="string">&#x27;-*g&#x27;</span>); grid on; <span class="built_in">hold</span> on;</span><br><span class="line">semilogy(EbN0, ber_theory, <span class="string">&#x27;-r&#x27;</span>); grid on; <span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="comment">%===================扩频码生成函数===========================%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m]</span> = <span class="title">m_serial_generator</span><span class="params">(tap_set)</span></span></span><br><span class="line">    L = <span class="number">2</span> ^ (<span class="built_in">length</span>(tap_set) - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    x = [<span class="built_in">zeros</span>(<span class="number">1</span>, (<span class="built_in">length</span>(tap_set) - <span class="number">2</span>)) <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:L</span><br><span class="line">        m(<span class="built_in">i</span>) = x(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(tap_set) - <span class="number">1</span></span><br><span class="line">            sum_vector(<span class="built_in">j</span>) = tap_set(<span class="built_in">j</span> + <span class="number">1</span>) * x(<span class="built_in">j</span>); <span class="comment">%#ok&lt;*AGROW&gt;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        sum_x = <span class="built_in">mod</span>(sum(sum_vector), <span class="number">2</span>);</span><br><span class="line">        x = [sum_x x(<span class="number">1</span>:<span class="keyword">end</span> - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="代码2">代码2</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">clc; clear; close all</span><br><span class="line"><span class="comment">%:本程序用于实现QPSK直接扩频系统</span></span><br><span class="line"><span class="comment">%========================基本参数===========================%</span></span><br><span class="line">Rs = <span class="number">100e6</span>; <span class="comment">%符号速率</span></span><br><span class="line">sps = <span class="number">4</span>; <span class="comment">%上采样倍数</span></span><br><span class="line">fs = sps * Rs; <span class="comment">%采样率</span></span><br><span class="line">alfs = <span class="number">0.35</span>; <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1e4</span>; <span class="comment">%数据长度</span></span><br><span class="line">M = <span class="number">4</span>; <span class="comment">%调制阶数</span></span><br><span class="line">offset = <span class="built_in">pi</span> / <span class="number">4</span>; <span class="comment">%偏移量</span></span><br><span class="line">rng(<span class="number">9</span>);</span><br><span class="line"><span class="comment">%========================调制==============================%</span></span><br><span class="line">bit_send = randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">1</span>, data_len); <span class="comment">%bit数据</span></span><br><span class="line"><span class="comment">% bit_send = repmat([0 1],[1 data_len/2]);</span></span><br><span class="line">data = bit2int(bit_send.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line"><span class="comment">% data = randi([0 M - 1], 1, data_len); %随机数据</span></span><br><span class="line">data_mod = pskmod(data, M, offset); <span class="comment">%PSK调制</span></span><br><span class="line">scatterplot(data_mod); title(<span class="string">&#x27;QPSK-Constellation Diagram&#x27;</span>);</span><br><span class="line"><span class="comment">%========================扩频==============================%</span></span><br><span class="line">n = <span class="number">10</span>; <span class="comment">%m序列级数</span></span><br><span class="line">C = <span class="number">435</span>; <span class="comment">%八进制反馈系数</span></span><br><span class="line">tap_set = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">%二进制</span></span><br><span class="line"><span class="comment">% m_sequence = [idinput(2^n-1,&#x27;prbs&#x27;).&#x27; 1];</span></span><br><span class="line">m_sequence = <span class="number">1</span> - <span class="number">2</span> * [m_serial_generator(tap_set) <span class="number">0</span>]; <span class="comment">%生成扩频序列</span></span><br><span class="line">data_matrix = (m_sequence.&#x27;) .* data_mod; <span class="comment">%扩频矩阵</span></span><br><span class="line">data_dsss = <span class="built_in">reshape</span>(data_matrix, <span class="number">1</span>, []);</span><br><span class="line"><span class="comment">% data_mod_repmat = rectpulse(data_mod,1024);</span></span><br><span class="line"><span class="comment">% mg = repmat(m_sequence,[1,length(data_mod)]);</span></span><br><span class="line"><span class="comment">% data_dsss = data_mod_repmat.*mg;</span></span><br><span class="line"><span class="comment">%=======================成形滤波器==========================%</span></span><br><span class="line">Fir_rcos = rcosdesign(alfs, <span class="number">8</span>, sps, <span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_qpsk = conv(upsample(data_mod, sps), Fir_rcos);</span><br><span class="line">data_dsss_up = upsample(data_dsss, sps);</span><br><span class="line">data_dsss_shape = conv(data_dsss_up, Fir_rcos);</span><br><span class="line"><span class="comment">%=========================噪声=============================%</span></span><br><span class="line">snr = <span class="number">10</span>;</span><br><span class="line">data_qpsk_awgn = awgn(data_qpsk, snr, <span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">data_awgn = awgn(data_dsss_shape, snr, <span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line"><span class="comment">%=======================解扩+匹配===========================%</span></span><br><span class="line">data_qpsk_matched = conv(data_qpsk_awgn, Fir_rcos); <span class="comment">%匹配滤波</span></span><br><span class="line">m_sequence_up = upsample(<span class="built_in">fliplr</span>(m_sequence), sps);</span><br><span class="line">Fir_match = conv(m_sequence_up, Fir_rcos); <span class="comment">%本地广义匹配滤波器</span></span><br><span class="line">data_matched = conv(data_awgn, Fir_match); <span class="comment">%解扩+匹配</span></span><br><span class="line"><span class="comment">%========================解调===============================%</span></span><br><span class="line">data_qpsk_matched_down = data_qpsk_matched(<span class="number">33</span>:sps:<span class="keyword">end</span> - <span class="number">32</span>);</span><br><span class="line">scatterplot(data_qpsk_matched_down); title(<span class="string">&#x27;SNR=10dB QPSK无扩频&#x27;</span>);</span><br><span class="line">data_matched_down = data_matched(<span class="number">4125</span>:sps * <span class="number">1024</span>:<span class="keyword">end</span> - <span class="number">4124</span>);</span><br><span class="line">scatterplot(data_matched_down); title(<span class="string">&#x27;SNR=10dB QPSK有扩频&#x27;</span>);</span><br><span class="line">data_qpsk_demod = pskdemod(data_qpsk_matched_down, M, offset);</span><br><span class="line">bit_qpsk = int2bit(data_qpsk_demod.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">bit_error = biterr(bit_send, bit_qpsk);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK Bit Error = &#x27;</span>, num2str(bit_error)]);</span><br><span class="line">ber = bit_error / data_len;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK BER = &#x27;</span>, num2str(ber)]);</span><br><span class="line">data_demod = pskdemod(data_matched_down, M, offset);</span><br><span class="line">bit_recv = int2bit(data_demod.&#x27;, <span class="built_in">log2</span>(M)).&#x27;;</span><br><span class="line">bit_error = biterr(bit_send, bit_recv);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK-DSSS Bit Error = &#x27;</span>, num2str(bit_error)]);</span><br><span class="line">ber = bit_error / data_len;</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;QPSK-DSSS BER = &#x27;</span>, num2str(ber)]);</span><br><span class="line"><span class="comment">%========================频谱分析===========================%</span></span><br><span class="line">fft_n = <span class="number">16384</span>; <span class="comment">%FFT点数</span></span><br><span class="line">f_1 = (-fft_n / <span class="number">2</span>:fft_n / <span class="number">2</span> - <span class="number">1</span>) ./ fs;</span><br><span class="line">f_2 = (-fft_n / <span class="number">2</span>:fft_n / <span class="number">2</span> - <span class="number">1</span>) * <span class="number">1024</span> ./ fs;</span><br><span class="line">data_qpsk_awgn_fft = fft(data_qpsk_awgn, fft_n);</span><br><span class="line">data_awgn_fft = fft(data_awgn, fft_n);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(f_1, <span class="number">20</span> * <span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(data_qpsk_awgn_fft)) / fft_n), <span class="string">&#x27;r&#x27;</span>); <span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(f_2, <span class="number">20</span> * <span class="built_in">log10</span>(<span class="built_in">abs</span>(fftshift(data_awgn_fft)) / fft_n), <span class="string">&#x27;b&#x27;</span>); grid on;</span><br><span class="line">xlabel(<span class="string">&#x27;Frequency (Hz)&#x27;</span>); ylabel(<span class="string">&#x27;Power (dB)&#x27;</span>); <span class="built_in">legend</span>(<span class="string">&#x27;QPSK&#x27;</span>, <span class="string">&#x27;QPSK-DSSS&#x27;</span>);</span><br><span class="line"><span class="comment">%===================扩频码生成函数===========================%</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[m]</span> = <span class="title">m_serial_generator</span><span class="params">(tap_set)</span></span></span><br><span class="line">    L = <span class="number">2</span> ^ (<span class="built_in">length</span>(tap_set) - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    x = [<span class="built_in">zeros</span>(<span class="number">1</span>, (<span class="built_in">length</span>(tap_set) - <span class="number">2</span>)) <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:L</span><br><span class="line">        m(<span class="built_in">i</span>) = x(<span class="keyword">end</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">length</span>(tap_set) - <span class="number">1</span></span><br><span class="line">            sum_vector(<span class="built_in">j</span>) = tap_set(<span class="built_in">j</span> + <span class="number">1</span>) * x(<span class="built_in">j</span>); <span class="comment">%#ok&lt;*AGROW&gt;</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        sum_x = <span class="built_in">mod</span>(sum(sum_vector), <span class="number">2</span>);</span><br><span class="line">        x = [sum_x x(<span class="number">1</span>:<span class="keyword">end</span> - <span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDS原理及简单应用</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1>DDS原理学习</h1><h2 id="何为DDS">何为DDS</h2><h3 id="DDS定义与优点">DDS定义与优点</h3><blockquote><p><strong>DDS: <em><strong><strong>Direct digital synthesis</strong></strong></em> 直接数字频率合成，可以用来合成周期性的信号序列。</strong></p></blockquote><blockquote><p><strong>优点：频率转换时间短；频率分辨率极高；相位变化连续；输出波形灵活</strong></p></blockquote><h3 id="DDS原理">DDS原理</h3><blockquote><p>在参考时钟的驱动下，相位累加器对频率控制字进行线性累加，得到的相位码对波形存储器寻址，使之输出相应的幅度码，经过模数转换器得到相应的阶梯波。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_IWHYjLWaOk.png" alt></p><blockquote><p>也就是，我们事先将想要的波形所对应的数值按照一定的要求存储于ROM 中，然后在硬件工作的时候，对 ROM 进行寻址，得到相应的波形数据，再通过 D/A 输出，以此获得我们目标波形。</p></blockquote><h4 id="角度与波形">角度与波形</h4><blockquote><p>从 DDS 的原理可以看出，DDS 可以产生任意周期性的波形，比如 sine，cosine，三角波等。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_qPrM5dDBAV.png" alt></p><blockquote><p>以 sine 为例，可以看出来，波形电平最大值等于圆的半径，产生的波形的频率等价于扫过 2π 角度的速度。</p></blockquote><h4 id="频率控制字">频率控制字</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_AM9mHRx6cW.png" alt></p><blockquote><p>从上图可以看出来，输出信号的频率与扫描的角速度是有关系的。</p></blockquote><p>$$<br>频率=\frac{2π}{角速度}<br>$$</p><blockquote><p>但由于波形数据是存储在 ROM 中的，这就意味着其相位的步进是离散的，这时候需要引入频率控制字的概念。</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_Hc8tgdOJIG.png" alt></p><ul><li><p><strong>举例</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_TC5wozAp-N.png" alt></p><ul><li><strong>频率控制字与输出信号频率之间的关系</strong><blockquote><p>当前你在 ROM 中存储了 1024 个 sine 波形数据，而你要读取哪个波形数据是完全取决于相位累加器的输出的，比如当前相位累加器输出是 10，则你会读取 ROM 中地址为 10 的数据。相位累加器的步进值又取决于频率控制字 <em>M</em>，如果 <em>M</em> = 1，则系统会按照顺序读取所有 ROM 中的数据，那如果频率控制字 <em>M</em> = 10，则系统会在 ROM 中每 10 个数据读取一次，可想而知，波形没那么好看了（可能会产生锯齿），但是由于扫描一周的时间变短了，所以对应频率更高。</p></blockquote></li></ul></li></ul><h2 id="硬件实现">硬件实现</h2><h4 id="思考">思考</h4><ol><li><p>求 $131.072MHz $系统时钟，要求精度为 $1kHz$ 时的 $N$。输出精度相当于$M = 1$$ $时的输出频率。</p><p>答：$N = 17$，意味着 $ROM$ 核的地址有 $17bit$，因此深度为$2 ^ {17} = 131, 072$。若要求精度为 $1Hz$，深度就会更大。</p></li><li><p>如果我想获得更大的可调频率范围，那频率控制字 $M$ 有可能为小数吗？或者是当前 $ROM $的寻址范围有限，那我有可能产生比取 $M = 1$还低的输出信号频率吗？如果可以，那频率控制字$ M = 0.5, M = 0.25$ 在$ Verilog$ 中该怎么实现呢？</p><p>答：可以通过对相位累加器的输出进行截断来实现。</p></li></ol><h4 id="地址截断">地址截断</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_rw72jKJDEb.png" alt></p><blockquote><p>一般舍去较低为位数，只取 N 的高 A 位（如高 10 位或 14 位）做为存储器地址，使得相位的低位被截断（即相位截尾）。可以参考如下代码。</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">reg</span>    [<span class="number">19</span>:<span class="number">0</span>] addr = <span class="number">20&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">parameter</span> add_M = <span class="number">20&#x27;d1</span>;</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (rst_n == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= addr[<span class="number">19</span>:<span class="number">0</span>] + add_M;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line">sine_rom sin_rom_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.addra</span>(addr[<span class="number">19</span>:<span class="number">10</span>]),  <span class="comment">// input wire [9 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(dds_out)  <span class="comment">// output wire [13 : 0] douta</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="具体实现步骤">具体实现步骤</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_9Nanu4Ox4o.png" alt></p><h1>仿真设计实现</h1><h2 id="MATLAB">MATLAB</h2><h3 id="生成coe文件">生成coe文件</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clear;clc;close all;</span><br><span class="line">t = <span class="number">0</span>:<span class="number">1</span>/<span class="number">2</span>^<span class="number">10</span>:<span class="number">1</span><span class="number">-1</span>/<span class="number">2</span>^<span class="number">10</span>;</span><br><span class="line">sin_1 = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*t);</span><br><span class="line">sin_14bit = <span class="built_in">round</span>((<span class="number">2</span>^<span class="number">13</span><span class="number">-1</span>)*sin_1/<span class="built_in">max</span>(sin_1));</span><br><span class="line">fid = fopen(<span class="string">&#x27;sin_14bit.coe&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">%创建COE文件</span></span><br><span class="line">fprintf(fid, <span class="string">&#x27;memory_initialization_radix=10;\n&#x27;</span>);</span><br><span class="line">fprintf(fid, <span class="string">&#x27;memory_initialization_vector=\n&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(sin_14bit)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span> &lt; <span class="built_in">length</span>(sin_14bit))</span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d\n&#x27;</span>,sin_14bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fprintf(fid,<span class="string">&#x27;%d&#x27;</span>,sin_14bit(<span class="built_in">i</span>));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="comment">% fprintf(fid,&#x27;%d\n&#x27;,sin_14bit);</span></span><br><span class="line">fclose(fid);</span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(sin_14bit);</span><br></pre></td></tr></table></figure><blockquote><p>上述代码，$N = 1024$，正弦函数，量化时乘以$2^{13}-1$，其原因在于量化$14Bit$，<strong>有符号数的范围</strong>为$-2^{13}$~$2^{13}-1$;正数少一个，所以只能量化到$2^{13}-1$</p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_VJOrqUryEJ.png" alt></p><h2 id="Vivado">Vivado</h2><h3 id="仿真中遇到的问题及注意事项">仿真中遇到的问题及注意事项</h3><h3 id="无地址截断仿真">无地址截断仿真</h3><ul><li><strong>Design文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> dds_work(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">13</span>:<span class="number">0</span>] dds_out</span><br><span class="line">    );</span><br><span class="line">   <span class="keyword">reg</span>    [<span class="number">9</span>:<span class="number">0</span>] addr = <span class="number">10&#x27;d0</span>;</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">    addr &lt;= <span class="number">10&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    addr &lt;= addr + <span class="number">10&#x27;d1</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line">sin_rom sin_rom_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.addra</span>(addr),  <span class="comment">// input wire [9 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(dds_out)  <span class="comment">// output wire [13 : 0] douta</span></span><br><span class="line">);   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><strong>testbench文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="keyword">module</span> tb_sinrom(</span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">reg</span>        clk;</span><br><span class="line">  <span class="keyword">reg</span>        rst_n;</span><br><span class="line">  <span class="keyword">wire</span>  [<span class="number">13</span>:<span class="number">0</span>]  dds_out;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;    <span class="comment">//50MHz clock</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    #<span class="number">200</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  dds_work dds_work_m (</span><br><span class="line">    <span class="variable">.clk</span>(clk), </span><br><span class="line">    <span class="variable">.rst_n</span>(rst_n), </span><br><span class="line">    <span class="variable">.dds_out</span>(dds_out)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><p>仿真波形</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_phE8r_rdR6.png" alt></p><blockquote><p>$T = 20.66us$（稍有误差，手拖动的）<br>$$<br>f_o={M×f_{clk} \over 2^N}</p></blockquote><p>$$<br>即$fo={1×50×10^6 \over 2^{10}}$; 所以$T = $$1/f_o$$=1024/50us$=$20.48us$</p><p>故而可以认为输出正确</p></li></ul></li></ul><h3 id="有地址截断仿真">有地址截断仿真</h3><ul><li><strong>Design文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dds_top(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">input</span> rst_n,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">13</span>:<span class="number">0</span>] dds_out</span><br><span class="line">    );</span><br><span class="line">   <span class="keyword">reg</span>    [<span class="number">19</span>:<span class="number">0</span>] addr = <span class="number">20&#x27;d0</span>;</span><br><span class="line">   <span class="keyword">parameter</span> add_M = <span class="number">20&#x27;d1</span>;</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> (rst_n == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= <span class="number">20&#x27;d0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    addr[<span class="number">19</span>:<span class="number">0</span>] &lt;= addr[<span class="number">19</span>:<span class="number">0</span>] + add_M;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>   </span><br><span class="line">sine_rom sin_rom_m (</span><br><span class="line">  <span class="variable">.clka</span>(clk),    <span class="comment">// input wire clka</span></span><br><span class="line">  <span class="variable">.addra</span>(addr[<span class="number">19</span>:<span class="number">10</span>]),  <span class="comment">// input wire [9 : 0] addra</span></span><br><span class="line">  <span class="variable">.douta</span>(dds_out)  <span class="comment">// output wire [13 : 0] douta</span></span><br><span class="line">);   </span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li><li><strong>Testbench文件</strong><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> tb_sinrom( </span><br><span class="line">    );</span><br><span class="line">  <span class="keyword">reg</span>        clk;</span><br><span class="line">  <span class="keyword">reg</span>        rst_n;</span><br><span class="line">  <span class="keyword">wire</span>  [<span class="number">13</span>:<span class="number">0</span>]  dds_out;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">always</span> #<span class="number">10</span> clk = ~clk;    <span class="comment">//50MHz clock</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b1</span>;</span><br><span class="line">    #<span class="number">200</span></span><br><span class="line">    rst_n = <span class="number">1&#x27;b0</span>;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">  dds_top dds_top_m (</span><br><span class="line">    <span class="variable">.clk</span>(clk), </span><br><span class="line">    <span class="variable">.rst_n</span>(rst_n), </span><br><span class="line">    <span class="variable">.dds_out</span>(dds_out)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li><p>仿真输出</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/03DDS/DDS%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/image_W7ShSNx0DR.png" alt></p><p>上述图看到，周期大约为21ms</p><p>计算验证：$T = 1/f_o = 2^{20}\times1\times10^3/50\times10^6 ms = 20.97152ms$</p><p>该设计是为了证明可通过截取地址来实现更低频率的信号，解决了N有限导致的问题</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BPSK收发系统</title>
      <link href="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1>BPSK收发系统</h1><h2 id="理论部分">理论部分</h2><h3 id="数字调制信号的表示">数字调制信号的表示</h3><h4 id="调制方式的种类">调制方式的种类</h4><p><strong>有记忆调制</strong></p><blockquote><p>📌<strong>无记忆调制</strong></p></blockquote><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/figure1.png" alt="figure1"></p><p>在无记忆调制方式中，二进制序列分成每段长度为$k$的序列，再将每段序列映射成$s_m(t)$ ，而不考虑先前发送的信号如何。</p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_Wg3DHHwqwb.png" alt="figure"></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_MCixJMqzN4.png" alt="figure"></p><h3 id="无记忆调制方式——以BPSK为例">无记忆调制方式——以BPSK为例</h3><h4 id="MPSK表达式">MPSK表达式</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_o0xXPboPKM.png" alt="figure"></p><h4 id="BPSK表达式">BPSK表达式</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_rQ-WCXIHTJ.png" alt="figure"></p><p><strong>图形简述过程如下：</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_MgkwiCZF2e.png" alt="figure"></p><h4 id="PSK和QAM">PSK和QAM</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_E8g0Q6xpuJ.png" alt="figure"></p><ul><li><strong>QAM 和 PSK 的区别</strong></li></ul><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_kHjCVSxY3c.png" alt="figure"></p><p><strong>从左边的星座图可以很显然看出，QAM 的幅度是不恒定的，而 PSK 的幅度是恒定的，即 PSK 只会改变信号的相位，而 QAM 不仅改变信号的相位，还改变信号的幅度。</strong></p><h4 id="根升余弦成型">根升余弦成型</h4><ul><li><p><strong>带限信道</strong></p><p>我们的所有通信信道都一定不是无限带宽的，对于带限信道，我们可以将其表征为等效<strong>低通频率响应</strong> $C(f)$。根据以前通信原理相关知识，我们可以知道信号通过带限滤波器后，其非理想信道频率响应特性 $C(f)$ 会引起幅度和延时失真，在接收端特定时间采样时，不同信号间产生重叠，因此出现符号间干扰。这个时候，我们就要从想办法克服码间串扰 $ISI$。</p></li><li><p><strong>奈奎斯特准则</strong></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_gcm_CPfwZZ.png" alt="figure"></p><ul><li>情况1<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_gKEEAwW1yw.png" alt="figure"></li><li>情况2<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_sVRceAqpP4.png" alt="figure"></li><li>情况3<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_GEynPZR-id.png" alt="figure"></li><li>拓展<br><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_8JjCSvXjs2.png" alt="figure"></li></ul></li><li><p><strong>升余弦</strong></p></li><li><p><strong>根升余弦滤波器</strong></p></li></ul><h4 id="AWGN-信道的最佳接收机——理论部分">AWGN 信道的最佳接收机——理论部分</h4><ul><li>AWGN信道</li><li>最佳判决的定义</li><li></li></ul><h2 id="MATLAB仿真设计">MATLAB仿真设计</h2><h3 id="系统实现">系统实现</h3><h4 id="收发系统框图">收发系统框图</h4><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image.png" alt="figure"></p><h2 id="MATLAB代码实现">MATLAB代码实现</h2><h3 id="系统分模块实现">系统分模块实现</h3><h4 id="发射序列">发射序列</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_len = <span class="number">10</span>;                            <span class="comment">%数据长度</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);            <span class="comment">%发射随机1，0序列</span></span><br><span class="line"><span class="comment">%data = round(rand(1,data_len));</span></span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line"><span class="comment">%data = zeros(1,data_len);</span></span><br></pre></td></tr></table></figure><h4 id="映射-0-1">映射(0 -&gt; -1)</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stem(data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&quot;发送端数据&quot;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stairs(s);title(<span class="string">&#x27;映射之后序列&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_Iq5ZgKPrM0.png" alt="figure"></p><h4 id="成型滤波">成型滤波</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alfs = <span class="number">0.35</span>;                                   <span class="comment">% 滚降系数</span></span><br><span class="line">osr = <span class="number">8</span>;                                       <span class="comment">% 上采样倍数</span></span><br><span class="line">data_up = upsample(s,osr);                     <span class="comment">%上采样</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);      <span class="comment">%根升余弦滤波器</span></span><br><span class="line">N = <span class="built_in">length</span>(fir_rcos);                          <span class="comment">%滤波器长度</span></span><br><span class="line">data_bx = conv(fir_rcos,data_up);              <span class="comment">%通过滤波器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>上采样：</strong><code>upsample(x,n)</code>函数；在序列x的每个数后插入n-1个0</p><p><em>上采样又称信号插值，即在原序列_x_(n)的两点之间插入L个0，等效于其在频域上做了频谱压缩。数据内插补零后，其贡献为零，因此傅里叶频谱形态只是更加细致。</em></p></li><li><p><strong>根升余弦函数：</strong><code>rcosdesign(alfs,span,sps,shape)</code>；</p><ul><li><strong><code>alfs</code><strong>为滚降系数；</strong><code>span</code><strong>为表示截断的符号范围；</strong><code>sps</code><strong>为单个符号采样的个数(数值上等于</strong><code>osr</code></strong>，即上采样倍数)；<strong><code>shape</code><strong>处可加上’</strong><code>normal'</code></strong>，可加上’**<code>sqrt'，</code><strong>不加默认</strong><code>'sqrt'</code>*</li></ul></li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(fir_rcos);title(<span class="string">&#x27;根升余弦时域波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>(data_bx);title(<span class="string">&#x27;成形之后的波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_IfYgWZKsXC.png" alt="figure"></p><h4 id="上变频（乘以载波）">上变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs = <span class="number">16000</span>;                                       <span class="comment">% 采样率 </span></span><br><span class="line">fc = <span class="number">2000</span>;                                        <span class="comment">% 载波频率</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*t);                      <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx .* carrier;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(carrier);title(<span class="string">&#x27;载波时域波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>(s_up);title(<span class="string">&#x27;上变频之后的波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_h-sNv-ENfj.png" alt="figure"></p><h4 id="物理信道（添加噪声）">物理信道（添加噪声）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_n = awgn(s_up,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>awgn</code><em>函数：</em><code>y= awgn(x,snr,'measured')</code><em>将白高斯噪声添加到向量信号x中。标量snr指定了每一个采样点信号与噪声的比率，单位为dB。如果x是复数的，awgn将会添加复数噪声。</em><code>'measured'</code><em>在添加噪声之前测量了x的能量。</em></p><h4 id="下变频（乘以载波）">下变频（乘以载波）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r_down = r_n .* carrier;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(r_n);title(<span class="string">&#x27;添加高斯噪声波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line"><span class="built_in">plot</span>(r_down);title(<span class="string">&#x27;下变频之后波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_6dAAejPV3r.png" alt="figure"></p><h4 id="匹配滤波器接收">匹配滤波器接收</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r_bx = conv(fir_rcos,r_down);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">plot</span>(r_bx);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_HVHmC85t0p.png" alt="figure"></p><h4 id="采样-判决（最佳接收）">采样/判决（最佳接收）</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r_data = (r_bx(N:osr:<span class="keyword">end</span>-N+<span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">%recv_data = (r_bx(osr*6+1:osr:end-osr*6)) &gt; 0;</span></span><br><span class="line"><span class="comment">%recv_data = (r_bx(osr*6+1:osr:osr*6+1+osr*(data_len-1))) &gt; 0;</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">6</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stem(data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&#x27;发送端数据&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">stem(r_data,<span class="string">&#x27;filled&#x27;</span>);title(<span class="string">&quot;接受端数据&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_YwUfNj9aIZ.png" alt="figure"></p><p><em>由于发送端数据为10，长度较小，只是为了测试整个程序运行正常，因此最后采样判决输出结果应该基本完全一致，用这个思路可以初步检验代码是否正确。</em></p><h4 id="代码">代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% bpsk收发系统</span></span><br><span class="line">clc;clear all;close all;</span><br><span class="line"><span class="comment">%% 参数设置</span></span><br><span class="line">fs = <span class="number">16000</span>;            <span class="comment">% 采样率 </span></span><br><span class="line">Rb = <span class="number">1000</span>;             <span class="comment">% bit速率</span></span><br><span class="line">fc = <span class="number">2000</span>;             <span class="comment">% 载波频率</span></span><br><span class="line">symbol_rate = <span class="number">1000</span>;    <span class="comment">%符号速率</span></span><br><span class="line">alfs = <span class="number">0.6</span>;            <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">10</span>;        <span class="comment">%数据长度</span></span><br><span class="line"><span class="comment">% osr = fs/Rb;           % 过采样倍数 = 采样率 / 符号速率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 基带信号产生（发射序列）</span></span><br><span class="line"><span class="comment">%data = round(rand(1,data_len));</span></span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len); </span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 映射(0变-1）</span></span><br><span class="line">osr = <span class="number">8</span>;</span><br><span class="line">s = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">data_up = upsample(s,osr);                        <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 成型滤波器</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);</span><br><span class="line">N = <span class="built_in">length</span>(fir_rcos);                             <span class="comment">%滤波器长度</span></span><br><span class="line">data_bx = conv(fir_rcos,data_up);                 <span class="comment">%通过滤波器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 上变频（乘以载波）</span></span><br><span class="line">t = <span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>;</span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*t);                      <span class="comment">%载波</span></span><br><span class="line">s_up = data_bx .* carrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 物理信道（添加噪声）</span></span><br><span class="line">r_n = awgn(s_up,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 下变频（乘以载波）</span></span><br><span class="line">r_down = r_n .* carrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 匹配滤波器</span></span><br><span class="line">r_bx = conv(fir_rcos,r_down);</span><br><span class="line"><span class="comment">%% 采样判决（解调）</span></span><br><span class="line">r_data = (r_bx(N:osr:<span class="keyword">end</span>-N+<span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="comment">% recv_data = (r_bx(osr*6+1:osr:osr*6+1+osr*(data_len-1))) &gt; 0;</span></span><br><span class="line"><span class="comment">%r_data = (r_bx(97:osr:end-97)) &gt; 0;</span></span><br><span class="line"><span class="comment">%r_data = (r_bx(N-1:osr:N-1+osr*(data_len-1))) &gt; 0;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="误码率分析">误码率分析</h2><ul><li><p><strong>整体代码</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%仿真作业——-----——输出误码率图像</span></span><br><span class="line">clc;clear all;close all;</span><br><span class="line">fs = <span class="number">16000</span>;                   <span class="comment">% 采样率 </span></span><br><span class="line"><span class="comment">% Rb = 1000;                    % bit速率</span></span><br><span class="line">fc = <span class="number">2000</span>;                    <span class="comment">% 载波频率</span></span><br><span class="line"><span class="comment">% symbol_rate = 1000;           %符号速率</span></span><br><span class="line">alfs = <span class="number">0.35</span>;                   <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">1000000</span>;               <span class="comment">%数据长度</span></span><br><span class="line"><span class="comment">% osr = fs/Rb;                  % 过采样倍数 = 采样率 / 符号速率</span></span><br><span class="line">osr = <span class="number">8</span>;</span><br><span class="line">data = randi([<span class="number">0</span> <span class="number">1</span>],<span class="number">1</span>,data_len);      <span class="comment">%生成0/1序列</span></span><br><span class="line">data_bio = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;             <span class="comment">%映射，0变-1</span></span><br><span class="line">data_up = upsample(data_bio,osr); <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">data_bx = conv(data_up,fir_rcos); <span class="comment">%根升余弦滤波</span></span><br><span class="line"><span class="comment">% figure(1);</span></span><br><span class="line"><span class="comment">% plot(data_bx);title(&#x27;经过成型滤波之后的图像&#x27;);</span></span><br><span class="line"></span><br><span class="line">carrier = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*fc/fs*(<span class="number">0</span>:<span class="built_in">length</span>(data_bx)<span class="number">-1</span>)); <span class="comment">%载波</span></span><br><span class="line">s_up = carrier.*data_bx;                    <span class="comment">%上变频（乘以载波）</span></span><br><span class="line"><span class="comment">% figure(2);</span></span><br><span class="line"><span class="comment">% plot(s_carrier);title(&#x27;调制波形&#x27;);</span></span><br><span class="line"></span><br><span class="line">errbit = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">snr = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ebn0 = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  snr(<span class="built_in">i</span>) = ebn0 + <span class="number">10</span>*<span class="built_in">log10</span>(<span class="number">2</span>) - <span class="number">10</span>*<span class="built_in">log10</span>(osr); <span class="comment">%SNR和EbN0的转化</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%物理信道（加性高斯白噪声）</span></span><br><span class="line">  r_noise = awgn(s_up,snr(<span class="built_in">i</span>),<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%下变频（乘以载波）</span></span><br><span class="line">  r__down = r_noise.*carrier;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">%匹配滤波器</span></span><br><span class="line">  <span class="comment">%根升余弦滤波</span></span><br><span class="line">  r_bx = conv(r__down,fir_rcos);</span><br><span class="line"></span><br><span class="line">  <span class="comment">%判决</span></span><br><span class="line">  recv_data = (r_bx(osr*<span class="number">6</span>+<span class="number">1</span>:osr:<span class="keyword">end</span>-osr*<span class="number">6</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">  errbit(<span class="built_in">i</span>) = sum(<span class="built_in">abs</span>(recv_data-data))/data_len;</span><br><span class="line">  <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ebn0 = <span class="number">1</span>:<span class="number">10</span>;</span><br><span class="line">ber_theory = <span class="number">0.5</span>*<span class="built_in">erfc</span>(<span class="built_in">sqrt</span>(power(<span class="number">10</span>,ebn0/<span class="number">10</span>)));<span class="comment">%理论误码率</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">semilogy(ebn0,ber_theory,<span class="string">&#x27;-or&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">semilogy(ebn0,errbit,<span class="string">&#x27;-sb&#x27;</span>);</span><br><span class="line">grid on;<span class="built_in">hold</span> on;</span><br><span class="line">xlabel(<span class="string">&#x27;EbN0(dB)&#x27;</span>);ylabel(<span class="string">&#x27;BER&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;BPSK误码率曲线图&#x27;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;理论误码率曲线&#x27;</span>,<span class="string">&#x27;仿真误码率曲线&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_s1YQE9lLTB.png" alt="figure"></p></li><li><p><strong>仿真过程中的部分要求</strong></p><p><strong>观测根升余弦成型信号的频谱和方波成型信号的频谱形状</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">clc;clear all;close all;</span><br><span class="line">fs = <span class="number">16000</span>;            <span class="comment">% 采样率 </span></span><br><span class="line"><span class="comment">% Rb = 1000;             % bit速率</span></span><br><span class="line">fc = <span class="number">2000</span>;             <span class="comment">% 载波频率</span></span><br><span class="line"><span class="comment">% symbol_rate = 1000;    %符号速率</span></span><br><span class="line">alfs = <span class="number">0.35</span>;            <span class="comment">% 滚降系数</span></span><br><span class="line">data_len = <span class="number">100</span>;        <span class="comment">%数据长度</span></span><br><span class="line"><span class="comment">% osr = fs/Rb;           % 过采样倍数 = 采样率 / 符号速率</span></span><br><span class="line">osr = <span class="number">8</span>;</span><br><span class="line">data = <span class="built_in">round</span>(<span class="built_in">rand</span>(<span class="number">1</span>,data_len));</span><br><span class="line"><span class="comment">%data = ones(1,data_len);</span></span><br><span class="line"></span><br><span class="line">s = (data<span class="number">-1</span>/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">s_up = upsample(s,osr);                        <span class="comment">%上采样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%成型滤波器——---根升余弦</span></span><br><span class="line">fir_rcos = rcosdesign(alfs,<span class="number">6</span>,osr,<span class="string">&quot;sqrt&quot;</span>);</span><br><span class="line">N = <span class="built_in">length</span>(fir_rcos);                             <span class="comment">%滤波器长度</span></span><br><span class="line">data_bx = conv(fir_rcos,s_up);                 <span class="comment">%通过滤波器</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line"><span class="built_in">plot</span>(data_bx);title(<span class="string">&#x27;时域波形&#x27;</span>);</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">N1 = <span class="number">1024</span>;</span><br><span class="line">y = fft(data_bx,N1);</span><br><span class="line">x = (<span class="number">1</span>/N1).*(<span class="number">0</span>:<span class="built_in">length</span>(y)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,<span class="built_in">abs</span>(y));title(<span class="string">&#x27;频域波形&#x27;</span>);       <span class="comment">%画坐标轴理解有点不到位</span></span><br><span class="line"><span class="comment">%成型滤波器-----方波</span></span><br><span class="line">data_rect = rectpulse(s,osr);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">subplot(<span class="number">211</span>);</span><br><span class="line">stairs(data_rect);title(<span class="string">&#x27;时域波形&#x27;</span>);</span><br><span class="line">ylim([<span class="number">-1.5</span> <span class="number">1.5</span>]);</span><br><span class="line">N2 = <span class="number">1024</span>;</span><br><span class="line">subplot(<span class="number">212</span>);</span><br><span class="line">y1 = fft(data_rect,N2);</span><br><span class="line">x1 = (<span class="number">1</span>/N2).*(<span class="number">0</span>:<span class="built_in">length</span>(y1)<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x1,<span class="built_in">abs</span>(y1));title(<span class="string">&#x27;频域波形&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_P2o5QU1rJk.png" alt="figure"></p><p><img src="/2022/12/12/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/03-%E7%A1%AC%E4%BB%B6%E5%9F%B9%E8%AE%AD2022/01BPSK/BPSK%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/image_nE2anoTF2_.png" alt="figure"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工程实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FPGA </tag>
            
            <tag> MATLAB </tag>
            
            <tag> Verilog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
